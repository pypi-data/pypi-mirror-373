# Copyright (C) 2022 The Qt Company Ltd.
# SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only
from __future__ import annotations
"""
This file contains the exact signatures for all functions in module
_QuickGraphLib, except for defaults which are replaced by "...".

# mypy: disable-error-code="override, overload-overlap"
"""

# Module `_QuickGraphLib`

import QuickGraphLib._QuickGraphLib
import numpy
import typing
import PySide6.QtCore
import PySide6.QtGui
import PySide6.QtQuick

import typing
import collections.abc
from shiboken6 import Shiboken


class Helpers(PySide6.QtCore.QObject):

    def __init__(self, /) -> None: ...

    @staticmethod
    def exportToPicture(item: PySide6.QtQuick.QQuickItem, /) -> PySide6.QtGui.QPicture: ...
    @staticmethod
    def exportToPng(item: PySide6.QtQuick.QQuickItem, path: PySide6.QtCore.QUrl | str, /, dpi: int = ...) -> bool: ...
    @staticmethod
    def exportToSvg(item: PySide6.QtQuick.QQuickItem, path: PySide6.QtCore.QUrl | str, /) -> bool: ...
    @staticmethod
    def linspace(min: float, max: float, num: int, /) -> typing.List[float]: ...
    @staticmethod
    def mapPoints(points: typing.Any, dataTransform: PySide6.QtGui.QMatrix4x4 | PySide6.QtGui.QTransform, /) -> PySide6.QtGui.QPolygonF: ...
    @staticmethod
    def range(min: int, max: int, /, step: int = ...) -> typing.List[int]: ...
    @staticmethod
    def tickLocator(min: float, max: float, maxNum: int, /) -> typing.List[float]: ...


class QGLDoubleList(Shiboken.Object):

    @typing.overload
    def __init__(self, /) -> None: ...
    @typing.overload
    def __init__(self, QGLDoubleList: 'QuickGraphLib._QuickGraphLib.QGLDoubleList', /) -> None: ...
    @typing.overload
    def __init__(self, v: collections.abc.Sequence[float], /) -> None: ...

    def __add__(self, l: collections.abc.Sequence[float], /) -> typing.List[float]: ...
    def __copy__(self, /) -> typing.Self: ...
    def __iadd__(self, l: collections.abc.Sequence[float], /) -> typing.List[float]: ...
    def __lshift__(self, l: collections.abc.Sequence[float], /) -> typing.List[float]: ...
    @typing.overload
    def append(self, l: collections.abc.Sequence[float], /) -> None: ...
    @typing.overload
    def append(self, arg__1: float, /) -> None: ...
    def at(self, i: int, /) -> float: ...
    def back(self, /) -> float: ...
    def capacity(self, /) -> int: ...
    def clear(self, /) -> None: ...
    def constFirst(self, /) -> float: ...
    def constLast(self, /) -> float: ...
    def count(self, /) -> int: ...
    def empty(self, /) -> bool: ...
    @typing.overload
    def first(self, /) -> float: ...
    @typing.overload
    def first(self, n: int, /) -> typing.List[float]: ...
    @staticmethod
    def fromList(list: collections.abc.Sequence[float], /) -> typing.List[float]: ...
    @staticmethod
    def fromNDArray(data: collections.abc.Sequence[typing.Any], /) -> 'QuickGraphLib._QuickGraphLib.QGLDoubleList': ...
    @staticmethod
    def fromVector(vector: collections.abc.Sequence[float], /) -> typing.List[float]: ...
    def front(self, /) -> float: ...
    def insert(self, arg__1: int, arg__2: float, /) -> None: ...
    def isEmpty(self, /) -> bool: ...
    def isSharedWith(self, other: collections.abc.Sequence[float], /) -> bool: ...
    @typing.overload
    def last(self, /) -> float: ...
    @typing.overload
    def last(self, n: int, /) -> typing.List[float]: ...
    def length(self, /) -> int: ...
    @staticmethod
    def maxSize() -> int: ...
    def max_size(self, /) -> int: ...
    def mid(self, pos: int, /, len: int = ...) -> typing.List[float]: ...
    def move(self, from_: int, to: int, /) -> None: ...
    def pop_back(self, /) -> None: ...
    def pop_front(self, /) -> None: ...
    def prepend(self, arg__1: float, /) -> None: ...
    def push_back(self, arg__1: float, /) -> None: ...
    def push_front(self, arg__1: float, /) -> None: ...
    def remove(self, i: int, /, n: int = ...) -> None: ...
    def removeAll(self, arg__1: float, /) -> None: ...
    def removeAt(self, i: int, /) -> None: ...
    def removeFirst(self, /) -> None: ...
    def removeLast(self, /) -> None: ...
    def removeOne(self, arg__1: float, /) -> None: ...
    def reserve(self, size: int, /) -> None: ...
    def resize(self, size: int, /) -> None: ...
    def resizeForOverwrite(self, size: int, /) -> None: ...
    def shrink_to_fit(self, /) -> None: ...
    def size(self, /) -> int: ...
    @typing.overload
    def sliced(self, pos: int, /) -> typing.List[float]: ...
    @typing.overload
    def sliced(self, pos: int, n: int, /) -> typing.List[float]: ...
    def squeeze(self, /) -> None: ...
    def swap(self, other: Union[QuickGraphLib._QuickGraphLib.QGLDoubleList, collections.abc.Sequence[float]], /) -> None: ...
    def swapItemsAt(self, i: int, j: int, /) -> None: ...
    def takeAt(self, i: int, /) -> float: ...
    def toList(self, /) -> typing.List[float]: ...
    def toVector(self, /) -> typing.List[float]: ...
    def value(self, i: int, /) -> float: ...


class QGLPolygonF(PySide6.QtGui.QPolygonF):

    @typing.overload
    def __init__(self, /) -> None: ...
    @typing.overload
    def __init__(self, QGLPolygonF: 'QuickGraphLib._QuickGraphLib.QGLPolygonF', /) -> None: ...
    @typing.overload
    def __init__(self, v: collections.abc.Sequence[PySide6.QtCore.QPointF], /) -> None: ...
    @typing.overload
    def __init__(self, v: PySide6.QtGui.QPolygonF | collections.abc.Sequence[PySide6.QtCore.QPointF] | PySide6.QtGui.QPolygon | PySide6.QtCore.QRectF, /) -> None: ...

    def __copy__(self, /) -> typing.Self: ...
    @staticmethod
    def fromNDArray(data: collections.abc.Sequence[typing.Any], /) -> 'QuickGraphLib._QuickGraphLib.QGLPolygonF': ...
    def swap(self, other: Union[QuickGraphLib._QuickGraphLib.QGLPolygonF, collections.abc.Sequence[PySide6.QtCore.QPointF], PySide6.QtGui.QPolygonF], /) -> None: ...


class QIntList: ...


class QPointFList: ...


# eof
