Metadata-Version: 2.4
Name: ganessa
Version: 2.5.4
Summary: Python interface to Piccolo/Ganessa_SIM and Picalor simulation kernel
Author: Dr. Pierre Antoine Jarrige
Author-email: ganessa@safege.fr
License: EUPL-1.2
Keywords: Piccolo Picalor Ganessa
Classifier: Development Status :: 5 - Production/Stable
Classifier: Environment :: Win32 (MS Windows)
Classifier: Intended Audience :: Developers
Classifier: Intended Audience :: End Users/Desktop
Classifier: Intended Audience :: Science/Research
Classifier: Operating System :: Microsoft :: Windows
Classifier: Programming Language :: Fortran
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Programming Language :: Python :: 3.13
Classifier: Programming Language :: Python :: Implementation :: CPython
Classifier: Topic :: Scientific/Engineering
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Topic :: Utilities
Requires-Python: >=3.5, <4
Description-Content-Type: text/x-rst
Requires-Dist: numpy>=2.0
Dynamic: author
Dynamic: author-email
Dynamic: classifier
Dynamic: description
Dynamic: description-content-type
Dynamic: keywords
Dynamic: license
Dynamic: requires-dist
Dynamic: requires-python
Dynamic: summary

Piccolo5/Piccolo6/Picalor6 and Ganessa_SIM API python calling interface

What is it?
-----------
A python package enabling users to call a set of Picwin32.dll or Ganessa_SIM.dll API functions and subroutines within python scripts. Initially provided for python 2.7 32 bits only. 1.9.x versions served as python 3.5 / 3.6 pre-release.

Starting with version 2.0.0, the wheel package is provided for 32 bits version for python 2.7 / 3.5 / 3.6 / 3.7 (Piccolo kernel is a 32 bits application) and 64 bits version for python 3.6 / 3.7 (Ganessa_SIM is available as 32 and 64 bits).

Starting with version 2.1.0, the wheel package is provided for 32 bits version for python 2.7 / 3.7 / 3.8 (Piccolo kernel is a 32 bits application) and 64 bits version for python 3.7 / 3.8 (Ganessa_SIM is available as 32 and 64 bits).

Starting with version 2.1.8, the wheel package is provided for 32 bits version for python 2.7 / 3.7 / 3.8 / 3.9 (Piccolo kernel is a 32 bits application) and 64 bits version for python 3.7 / 3.8 / 3.9 (Ganessa_SIM is available as 32 and 64 bits).

Version 2.1.9 is the last version that supported python 2.7.
Version 2.2.4 is the last version for which a wheel is provided for python 3.7.

Starting with version 2.2.5, the wheel package is provided for 32 bits version for python 3.8 / 3.9 / 3.10 (Piccolo kernel is a 32 bits application) and 64 bits version for python 3.8 / 3.9 / 3.10 (Ganessa_SIM is available as 32 and 64 bits).

Starting with version 2.3.3, the wheel package is provided for 32 bits version for python 3.8 / 3.9 / 3.10 / 3.11 (Piccolo kernel is a 32 bits application) and 64 bits version for python 3.8 / 3.9 / 3.10 / 3.11 (Ganessa_SIM is available as 32 and 64 bits).

Starting with version 2.3.10, the wheel package is provided for 32 bits version for python 3.8 / 3.9 / 3.10 / 3.11 / 3.12 (Piccolo kernel is a 32 bits application) and 64 bits version for python 3.8 / 3.9 / 3.10 / 3.11 / 3.12 (Ganessa_SIM is available as 32 and 64 bits).

Starting with version 2.4.2, the wheel package is provided for 32 bits version for python 3.8 / 3.9 / 3.10 / 3.11 / 3.12 / 3.13 (Piccolo kernel is a 32 bits application) and 64 bits version for python 3.8 / 3.9 / 3.10 / 3.11 / 3.12 / 3.13 (Ganessa_SIM is available as 32 and 64 bits).

Installation
------------
*Windows only* :: 

    pip install ganessa

Obsolete Requirements (32 bits)
-------------------------------
  #) python 2.7, 3.5, 3.6, 3.7
  #) obsolete python requirements: numpy 1.11 or above (python 2.7) / numpy 1.13.1 or above (python 3.5 - 3.6) / numpy 1.15.1 (python 3.7)
  #) Piccolo or Picalor kernel library (picwin32.dll), starting from version 5 (141203) for python 2.7
  #) valid Piccolo or Picalor or Ganessa_SIM license

Requirements (32 bits)
----------------------
  #) python 3.8 - 3.13
  #) numpy 1.15.1 (python 3.8) / numpy 1.19.4 (python 3.9) / numpy 1.21.3 (python 3.10) / numpy 1.23.3 (python 3.11+)
  #) numpy < 2.0 if python < 3.12 or ganessa < 2.4.4
  #) Piccolo6 or Picalor6 kernel library (picwin32.dll), or recent Ganessa_SIM.dll.
     Note that a recent (2020 or newer) version of Piccolo kernel is required for use with python 3.12+
  #) valid Piccolo or Picalor or Ganessa_SIM license (for commercial releases)

Requirements (64 bits)
----------------------
  #) python 3.8 - 3.13
  #) numpy 1.15.1 (python 3.8) / numpy 1.19.4 (python 3.9) / numpy 1.21.3 (python 3.10) / numpy 1.23.3 (python 3.11+)
  #) numpy < 2.0 if python < 3.12 or ganessa < 2.4.4
  #) recent Ganessa_SIM_x64.dll (64 bit dll)
  #) valid Ganessa_SIM license (for commercial releases)


This tool expects Picwin32.dll to be in the PATH or in one of the following folders::

                 %localappdata%/Programs/Safege/Piccolo_ or
                 %localappdata%/Programs/Suez/Piccolo_ or
                 %localappdata%/Programs/Gfi Progiciels/Piccolo6_ or
                 %localappdata%/Programs/Inetum/Piccolo6_ or
 [[E: or D:] or C:] / [
                 'Program Files (x86)/Safege/Piccolo_' or
                 'Program Files (x86)/Suez/Piccolo_' or
                 'Program Files (x86)/Gfi Progiciels/Piccolo6_'  or
                 'Program Files (x86)/Inetum/Piccolo6_'  or
                 'Program Files (x86)/Suez/Piccolo6_'  or
                 'Program Files (x86)/Gfi Progiciels/Picalor6_' or
                 'Program Files/Adelior/Piccolo5_'
                ]
              + ['fr' or 'uk' or 'esp' or 'eng'] + ['' or '_ck']

Or one of Ganessa_SIM.dll or Ganessa_TH.dll or Ganessa_SIM_x64.dll in::

            '%localappdata%/Programs/Safege/Ganessa_ or
            '%localappdata%/Programs/Suez/Ganessa_ or
 [[E: or D:] or C:] / [
                'Program Files (x86)/Safege/Ganessa_' or 
                'Program Files (x86)/Suez/Ganessa_' or
                'Program Files/Safege/Ganessa_' (Ganessa_SIM_x64 only) or 
                'Program Files/Suez/Ganessa_' (Ganessa_SIM_x64 only)
               ]
              + ['fr' or 'SIM' or 'uk' or 'esp' or 'eng']

With custom installations, PICCOLO_DIR or GANESSA_DIR environment variables can be set to define the dll path. 

Content
-------

The package provides:
 #) 'sim' package:
     - a few basic functions for reading or loading a model, running hydraulic and WQ simulations.
     - 'getter' functions for individual objects and attributes, time series vectors, attribute vector of all object (attribute maps).
     - iterators over links, nodes, tanks, demands, and tables, or over Piccolo command language selections.
     - a Graph class built from the current model graph, with propagation functions.
     - almost no 'setter' functions, but 'cmd', 'execute' and 'cmdfile' any Piccolo command language instruction(s)/file.
     - 'is_embedded()' returns True when the package is called from python embedded in Piccolo.
 #) 'th' package: same functions for Picalor except running extended period simulations and time series getters.
 #) 'util' package: conversion and formatting and other miscellaneous functions.
 #) 'OpenFileMMI' provides classes for opening dialog frame for a .dat/.bin/.pic/.inp model file (see en2emu below), folder, and input/output (result) file. It should be imported after 'sim' or 'th'.
 #) 'plot' provides easy multiple simulation vs reference graphs plot settings - requires matplotlib.
 #) 'proj' provides a 'guess_proj' function returning the model CRS as EPSG:xxxx or mnemonic, and 'get_spatial_ref'
 #) 'sort' provides a heapsort based on heapq.
 #) 'midfile' provides minimal mif/mid functions similar to shp/dbf shapefile handler (pyshp package).
 #) 'geojsonfile' provides minimal geojson functions similar to shp/dbf shapefile handler (pyshp package).
 #) 'epanet2' provides limited epanet 2.0.12 python API for win32 (thanks to Assela Pathirana - mailto: assela@pathirana.net) similar to EpanetTools-0.4.2; with epanet.getlinknodes and calculation of tank diameter corrected (from 0.9.2 and 1.0.0).
 #) 'epanet22' provides a single threaded, low-level python API for epanet 2.2, equivalent/compatible with above epanet2.
 #) 'owa_epanet22' provides an EpanetTools compatibility layer for owa-epanet 2.2.3/2.2.4: it defines EN_XXX constants and single project ENxxx API functions. All owa-epanet API functions are available.
 #) 'en2emu' provides minimal 'sim' compatibility for Epanet models being opened with OpenFileMMI.SelectModel, wrapper functions for running hydraulic and WQ simulations and collecting results as numpy arrays, iterators etc. See the doc.
 #) 'parallel' provides a simple parallel simulations handling framework based on multiprocessing, returning either elementary or reduced results.

Model objects and parameters can be modified using Piccolo command language (see cmd, cmdfile and execute).

Recently introduced functions and classes may not be functional with old versions of Piccolo / Ganessa_SIM kernel.

Documentation
-------------
Documentation is provided as pyGanessa.html in the installation folder, possibly in docs subfolder. It includes package history.

History of the README document
------------------------------
 - Created 2013-07-04
 - Revised 2015-05-03: since 2014-12-04 Picwin32.dll is compatible with this API.
 - Revised 2016-07-07: provided as .rst.
 - Revised 2017-08-08: install using pip; Piccolo/Ganessa dll folder search order.
 - Revised 2017-09-12: split sim into core, core_sim, core_th.
 - Revised 2017-11-13: added sort, midfile, epanet2 modules.
 - Revised 2017-11-30: added parallel.
 - Revised 2018-03-29: minor changes / extension to python 3.5-3.6.
 - Revised 2018-06-08: OpenFileMMI and epanet2 details, added example.
 - Revised 2018-08-16: 64 bits compatibility (Ganessa_SIM and python 3.7 / 3.8 only).
 - Revised 2018-08-27: numpy requirements.
 - Revised 2019-09-13: minor changes.
 - Revised 2019-10-09: extension to python 3.8.
 - Revised 2019-10-15: README rst fix.
 - Revised 2020-02-05: added sim.Graph; README rst fix.
 - Revised 2020-11-20: README rst fix.
 - Revised 2021-04-29: extension to python 3.9.
 - Revised 2021-06-17: python 2.7 compatibility removed since 2.2.0; folder lookup paths.
 - Revised 2021-10-27: python 3.7 removed & python 3.10 added since 2.2.5.
 - Revised 2022-04-21: dll lookup order as E:, D:, C:; example updated.
 - Revised 2022-09-27: python 3.11 added; proj package added.
 - Revised 2023-07-12: added epanet22.
 - Revised 2023-08-10: added owa_epanet22.
 - Revised 2023-10-18: added en2emu.
 - Revised 2023-11-06: added python 3.12.
 - Revised 2024-01-17: updated 64 bits requirements.
 - Revised 2024-03-18: updated .dll search paths.
 - Revised 2024-06-16: added python 3.13; fixed lookup paths.
 - Revised 2024-07-11: numpy 2.0 restriction to ganessa >= 2.4.4 and python >= 3.12.
 - Revised 2025-04-22: added SIM suffix alternative to language folder dll lookup.
 - Revised 2025-06-29: added an example of embedded script. 
 - Revised 2025-08-30: search path includes Suez/Piccolo6_xx.

Examples
--------

::


 
 # file: Example_EN.py
 """Example program for ganessa
 requires a Piccolo model 'model.dat' in the current folder
 Example using English command language"""
 
 import os
 import matplotlib.pyplot as plt
 import ganessa.sim as pic
 
 # This code sample runs under python 3.8+
 # but requires ganessa 2.3.0 or higher
 
 if __name__ == "__main__":
     wkfold = os.path.dirname(__file__)
     if not wkfold:
         wkfold = os.getcwd()
         print("Current folder is:", wkfold)
     os.chdir(wkfold)
     # will create work files here
     pic.init(wkfold)
     # loads the model - change the name here...
     pic.cmdfile("model.dat")
     # select small pipe (diameter below 155)
     # using iterator and D getter, by id
     def pipefilter(diameter):
         return 0 < diameter < 155
     pipes = [p for p in pic.Links() if pipefilter(pic.linkattr(p, "D"))]
     # using iterator and D getter, by index (less concise but slightly faster)
     pipes = [
         pic.getid(pic.LINK, k)
         for k in range(1, pic.nbobjects(pic.LINK) + 1)
         if pipefilter(pic.nlinkattr(k, "D"))
     ]
     # Most Piccoloic, using (english) command language selection
     pic.setlang("English")
     # Selectid has been introduced in 2.3.0; it is equivalent to Selected(..., False)
     pipes = list(pic.Selectid("PIPE (D < 155) END"))
     # minimal setter functions for links, nodes, tanks attributes
     pid = pipes[len(pipes) // 2]
     diam = pic.linkattr(pid, "D")
     pic.setlinkattr(pid, "D", diam * 2)
     # language-independant commands: MODIF MULT D 2 BRANCH {pid} END
     KWEND = pic.getkeyword(pic.DICT.END)
     pic.gencmdw(pic.M.MOD, pic.M.MOD.MULT, pic.M.NONE, "D 2")
     pic.gencmd(pic.M.LNK, pic.M.LNK.NONE, pic.M.NONE, pid + " " + KWEND, 1)
     # Use command language to set / modify / delete objects
     pic.execute("MODIF", f"DELETE BRANCH {pid} END")
     pic.execute("MODIF", "MERGE NODE (AB = 1) END", "MERGE NODE (AB = 1) END")
     # or change parameters
     pic.execute("SIMUL", "CRITX 0.05", "MXITER 75")
     # get demand profile TS
     nb = pic.tsdemandlen("DEFAUT", "HAUT")
     print("Profile length for area HAUT:", nb)
     res = pic.tsdemand("DEFAUT", "HAUT")
     # Unlike epanet, first run simulation then browse/ query results
     pic.full_solveH(silent=True, retry=True)
     print("Simulation done.")
     pic.browseH(3600 * 8.5)
     fig = plt.figure(figsize=(16 - 1, 9 - 1))
     # plot 3D elevation and hydraulic head
     ax = fig.add_subplot(projection="3d")
     for a in pic.Links():
         x, y, z, v, nb = pic.linkXYZV(a, "HH")
         if nb > 0:
             ax.plot(x, y, z, "r-")
             ax.plot(x, y, v, "b-")
     plt.title("Hydraulic head at t= 08:30")
     plt.show()
     # print min/max pressure over the EPS
     attr = "P"
     minpax_p = list(pic.getMinMax(pic.NODE, attr))
     for nid, vmin, vmax, vmoy in minpax_p[:10]:
         print(nid, attr + "min:", vmin, attr + "max:", vmax)
     print("\t...")
     for nid, vmin, vmax, vmoy in minpax_p[-10:]:
         print(nid, attr + "min:", vmin, attr + "max:", vmax)
     # get current volume simulation (internal variable steps) and measurement TS
     for tid in pic.Tanks():
         t1, v1, nb1 = pic.tsval(pic.TANK, tid, "CV")
         t2, v2, nb2 = pic.msval(pic.TANK, tid, "CV")
     # get current volume simulation results at measurement sampling
     for tid in pic.Tanks():
         t3, v3, nb3 = pic.tsvalbymts(pic.TANK, tid, "CV")
     # export as Epanet .inp
     pic.exportEpanet("model.inp")
     pic.execute("XXMEM BRANCH : D")
     pic.savemodel("model_xx.dat", extra_data=[("BRANCH (D > 149) END", "XX")])
     # WQ source data optional argument is a specific node - not used here
     print("\nWQ source data (input forcing and TS at nodes):")
     for n, cd, attr, t, c, nb in pic.WQSources():
         print(n, cd, attr, nb, t, c)
     print("Done.")
     # use reset() for switching model, close() to terminate
     pic.close()

 
 
 # file: Example_FR.py
 """Example d'utilisation du package ganessa
 Utilise un modele Piccolo 'model.dat' dans le dossier Courant
 Example en langage de commande Piccolo en Francais"""
 
 import os
 import matplotlib.pyplot as plt
 import ganessa.sim as pic
 
 # This code sample runs under python 3.8+
 # but requires ganessa 2.3.0 or higher
 
 if __name__ == "__main__":
     wkfold = os.path.dirname(__file__)
     if not wkfold:
         wkfold = os.getcwd()
         print("Current folder is:", wkfold)
     os.chdir(wkfold)
     # pour creer les fichier dans le meme dossier
     pic.init(wkfold)
     # ouvre le modele 'model.dat'...
     pic.cmdfile("model.dat")
     # filtre les conduites de faible diametre (diametre < 155)
     # avec iterateur et recuperation de D
     def pipefilter(diameter):
         return 0 < diameter < 155
     pipes = [p for p in pic.Links() if pipefilter(pic.linkattr(p, "D"))]
     # avec iterateur et recuperation de D, par index (moins concis mais plus rapide)
     pipes = [
         pic.getid(pic.LINK, k)
         for k in range(1, pic.nbobjects(pic.LINK) + 1)
         if pipefilter(pic.nlinkattr(k, "D"))
     ]
     # En langage de commande Piccolo (operateur de selection)
     pic.setlang("French")
     # Selectid existe depuis 2.3.0; c'est equivalent a Selected(..., False)
     pipes = list(pic.Selectid("TUYAU (D < 155) FIN"))
     # Il existe quelques fonctions de modification des attributs des arcs, noeuds, reservoirs
     pid = pipes[len(pipes) // 2]
     diam = pic.linkattr(pid, "D")
     pic.setlinkattr(pid, "D", diam * 2)
     # Generation de langage de commande dans la langue courante -> MODIF MULT D 2 ARC {pid} FIN
     KWEND = pic.getkeyword(pic.DICT.END)
     pic.gencmdw(pic.M.MOD, pic.M.MOD.MULT, pic.M.NONE, "D 2")
     pic.gencmd(pic.M.LNK, pic.M.LNK.NONE, pic.M.NONE, pid + " " + KWEND, 1)
     # Utilisation du language de commande pour modifier / detruire / redefinir des objets
     pic.execute("MODIF", f"DETR ARC {pid} FIN")
     pic.execute("MODIF", "FUSION NOEU (AA = 1) FIN", "FUSION NOEU (AA = 1) FIN")
     # ou changer des parametres
     pic.execute("SIMUL", "CRITX 0.05", "MXITER 75")
     # recuperer la TS d'un profil de besoins
     nb = pic.tsdemandlen("DEFAUT", "HAUT")
     print("Profile length for area HAUT:", nb)
     res = pic.tsdemand("DEFAUT", "HAUT")
     # Contrairement a epanet, faire le calcul complet puis parcourir les resultats
     pic.full_solveH(silent=True, retry=True)
     print("Simulation done.")
     pic.browseH(3600 * 8.5)
     fig = plt.figure(figsize=(16 - 1, 9 - 1))
     # trace une vue 3D de l'altitude et la charge hydraulique
     ax = fig.add_subplot(projection="3d")
     for a in pic.Links():
         x, y, z, v, nb = pic.linkXYZV(a, "CH")
         if nb > 0:
             ax.plot(x, y, z, "r-")
             ax.plot(x, y, v, "b-")
     plt.title("Plan de charge a t= 08:30")
     plt.show()
     # Affiche les pressions min/max sur la duree de la simulation
     attr = "P"
     minpax_p = list(pic.getMinMax(pic.NODE, attr))
     for nid, vmin, vmax, vmoy in minpax_p[:10]:
         print(nid, attr + "min:", vmin, attr + "max:", vmax)
     print("\t...")
     for nid, vmin, vmax, vmoy in minpax_p[-10:]:
         print(nid, attr + "min:", vmin, attr + "max:", vmax)
     # TS du volume des reservoirs (pas de temps interne variable) et TS mesure (niveau converti en volume)
     for tid in pic.Tanks():
         t1, v1, nb1 = pic.tsval(pic.TANK, tid, "VC")
         t2, v2, nb2 = pic.msval(pic.TANK, tid, "VC")
     # TS du volume des reservoirs au pas de temps de chaque mesure
     for tid in pic.Tanks():
         t3, v3, nb3 = pic.tsvalbymts(pic.TANK, tid, "VC")
     # export en Epanet .inp
     pic.exportEpanet("model.inp")
     pic.execute("XXMEM ARC : D")
     pic.savemodel("model_xx.dat", extra_data=[("ARC (D > 149) FIN", "XX")])
     # Parcours des definitions des sources pour la simulation qualite
     print("\nWQ source data (input forcing and TS at nodes):")
     for n, cd, attr, t, c, nb in pic.WQSources():
         print(n, cd, attr, nb, t, c)
     print("Done.")
     # reset() permet de reinitialiser le modele, close() termine definitivement.
     pic.close()

 
 
 # file: Extract_Interior_Nodes.py
 """
 Cette fonction montre l'utilisation de "is_embedded" et "ask_for_single_input" pour
 charger ou pas le modele , recuperer le nom du dossier de travail (celui du modele),
 ouvrir un dialogue utilisateur simplifie pour recuperer un parametre (nom de fichier).
 
 En mode "non embedded", il convient de glisser-deposer les 2 fichiers (modele et
 parametres de bief) sur le script.
 
 En mode embedded, le modele est deja charge, le fichier bief est recupere via la
 fonction "ask_for_single_input".
 """
 
 import os.path as OP
 from os import remove, chdir
 import sys
 from time import sleep
 import ganessa.sim as pic
 from ganessa.util import PICFILE_ENCODING
 from ganessa.OpenFileMMI import ask_for_single_input
 from tkinter.messagebox import showinfo
 
 def getbiefs(ficparname, min_cols=2):
     '''Lecture du fichier biefs'''
     def read_biefs_with_separator(ficparname, min_cols, sep):
         items = []
         try:
             with open(ficparname, 'r', encoding='utf8') as fpar:
                 for line in fpar:
                     stripline = line.strip()
                     if stripline:
                         if stripline[0] in ('*', '#'):
                             continue
                         if stripline[0:2] in ('/*', '::'):
                             continue
                         if len(line) > 1 and line[1] == '*':
                             continue
                         item = stripline.split(sep)
                         if len(item) < min_cols:
                             continue
                         if min_cols > 1:
                             items.append(tuple(item))
                         else:
                             items.extend(item)
         except Exception:
             pass
         return items
     # detection du separateur = celui qui renvoie la plus longue liste
     maxcount, result = -1, []
     for separator in (None, ";", ","):
         res = read_biefs_with_separator(ficparname, min_cols, separator)
         count = sum((len(x) for x in res)) if min_cols > 1 else len(res)
         if count > maxcount:
             result = res
             maxcount = count
     return result
 
 def selection_bief(items):
     '''Renvoie la selection des arcs du bief: en enum ou fichier si trop long'''
     selection = ' arc ' + ' '.join(items[1:]) + ' fin '
     if len(selection) < 240:
         return selection, ""
     sel_file = items[0] + '.sel'
     with open(sel_file, 'w', encoding=PICFILE_ENCODING) as fsel:
         fsel.write('\n'.join(items[1:]))
     selection = ' arc  @' + sel_file + ' fin '
     return selection, sel_file
 
 def extract_interior_modes(biefs, file_name):
     """extrait les noeuds interieurs a un bief"""
     count = 0
     with open(file_name, "w", encoding=PICFILE_ENCODING) as f:
         for bief_tuple in biefs:
             sel_links_bief, sel_file = selection_bief(bief_tuple)
             sel_int_nodes = f"noeu {sel_links_bief} && ! noeu ! {sel_links_bief}"
             bief = bief_tuple[0]
             for node in pic.Selectid(sel_int_nodes):
                 f.write(f" {bief}\t{node}\n")
                 count += 1
             if sel_file:
                 remove(sel_file)
     return count
 
 
 if pic.is_embedded():
     modele = pic.model_filename()
     bief_file = ask_for_single_input("Nom du fichier des biefs ?", "Biefs.txt")
 elif len(sys.argv) < 3:
     print("Glisser-déposer le fichier modèle et le fichier bief ")
     input("Presser une touche pour terminer")
     modele = ""
 else:
     modele, bief_file = sys.argv[1:3]
     if bief_file.lower().endswith(".dat"):
         modele, bief_file = bief_file, modele
     pic.cmdfile(modele)
 if modele:
     chdir(OP.dirname(modele))
     biefs = getbiefs(bief_file)
     print(len(biefs), "biefs lus.")
     nb = extract_interior_modes(biefs, "Noeuds_interieurs.txt")
     print(nb, "noeuds intérieurs")
     showinfo("Calcul des noeuds intérieurs aux biefs", str(nb) + " noeuds identifiés !")
     print("Done.")
 if not pic.is_embedded():
     sleep(2)

 
