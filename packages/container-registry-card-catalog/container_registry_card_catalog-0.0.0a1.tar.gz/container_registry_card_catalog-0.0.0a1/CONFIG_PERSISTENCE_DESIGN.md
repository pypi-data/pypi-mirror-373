# Configuration Persistence Design

<!--
AI Attribution (AIA) Notice:
- Generated by: Claude (Anthropic AI Assistant)
- Session Date: 2025-08-27
- Vibe-Coder: Andrew Potozniak <potozniak@redhat.com>
-->

## Overview

Design for persistent storage of registry configurations, monitored repositories, and authentication credentials to survive application restarts.

## Requirements

### Must Have
- ✅ Persist monitored repositories per registry
- ✅ Save authentication credentials securely (encrypted)
- ✅ Restore configuration on application startup
- ✅ Registry-specific settings (max_repos, cache_ttl, auth_scope)
- ✅ Cross-platform compatibility (Linux, macOS, Windows)

### Security Requirements
- 🔐 Credentials encrypted at rest
- 🔐 Config file permissions restricted (600)
- 🔐 No plain text passwords/tokens in files
- 🔐 Optional keyring integration for enhanced security

## File Location Strategy

```
~/.config/container-registry-card-catalog/
├── config.json                    # Main configuration
├── registries.json               # Registry definitions  
└── credentials.encrypted         # Encrypted credentials
```

**Alternative locations by platform:**
- Linux: `~/.config/container-registry-card-catalog/`
- macOS: `~/Library/Application Support/container-registry-card-catalog/`
- Windows: `%APPDATA%\container-registry-card-catalog\`

## Configuration File Format

### Main Configuration (`config.json`)
```json
{
  "version": "1.0",
  "last_updated": "2025-08-27T13:45:00Z",
  "app_settings": {
    "debug_enabled": false,
    "mock_mode": false,
    "default_page_size": 50
  },
  "registries": [
    {
      "id": "quay-io-main",
      "name": "Quay.io",
      "url": "https://quay.io",
      "enabled": true,
      "auth_type": "token",
      "settings": {
        "max_repos": 100,
        "cache_ttl": 900,
        "auth_scope": "repository:*:pull"
      },
      "monitored_repos": [
        "redhat/ubi8",
        "redhat/ubi9",
        "prometheus/prometheus"
      ]
    },
    {
      "id": "gcr-mirror",
      "name": "GCR Mirror",
      "url": "https://mirror.gcr.io",
      "enabled": true,
      "auth_type": "bearer",
      "settings": {
        "max_repos": 50,
        "cache_ttl": 600,
        "auth_scope": "registry:catalog:*"
      },
      "monitored_repos": [
        "library/ubuntu",
        "library/alpine"
      ]
    }
  ]
}
```

### Encrypted Credentials (`credentials.encrypted`)
```
# Encrypted using Fernet (cryptography library)
# Contains JSON with registry_id -> credentials mapping
{
  "quay-io-main": {
    "username": "robot_user",
    "password": "encrypted_token_here"
  },
  "gcr-mirror": {
    "username": "",
    "password": "encrypted_bearer_token"
  }
}
```

## Implementation Plan

### Phase 1: Basic File Storage
1. ✅ Create config directory structure
2. ✅ Implement JSON serialization/deserialization
3. ✅ Save monitored repositories (no credentials yet)
4. ✅ Load configuration on startup

### Phase 2: Credential Encryption
1. 🔐 Implement Fernet encryption for credentials
2. 🔐 Generate/store encryption key securely
3. 🔐 Encrypt credentials before saving
4. 🔐 Decrypt credentials on load

### Phase 3: Enhanced Security (Future)
1. 🚀 Keyring integration (python-keyring)
2. 🚀 Master password option
3. 🚀 Credential expiration tracking

## Security Implementation

### Encryption Strategy
```python
from cryptography.fernet import Fernet
import base64
import os

class CredentialManager:
    def __init__(self, config_dir):
        self.config_dir = config_dir
        self.key_file = os.path.join(config_dir, '.key')
        self.credentials_file = os.path.join(config_dir, 'credentials.encrypted')
        
    def _get_or_create_key(self):
        if os.path.exists(self.key_file):
            with open(self.key_file, 'rb') as f:
                return f.read()
        else:
            key = Fernet.generate_key()
            with open(self.key_file, 'wb') as f:
                f.write(key)
            os.chmod(self.key_file, 0o600)  # Restrict permissions
            return key
    
    def encrypt_credentials(self, credentials_dict):
        key = self._get_or_create_key()
        f = Fernet(key)
        json_data = json.dumps(credentials_dict).encode()
        encrypted_data = f.encrypt(json_data)
        return encrypted_data
```

### File Permissions
```python
def save_config_securely(file_path, data):
    # Write file
    with open(file_path, 'w') as f:
        json.dump(data, f, indent=2)
    
    # Restrict permissions to user only
    os.chmod(file_path, 0o600)
```

## Migration Strategy

### Version 1.0 (Current)
- In-memory only
- No persistence

### Version 1.1 (Target)
- File-based persistence
- Encrypted credentials
- Backward compatible (no existing config to migrate)

### Future Versions
- Schema versioning for config format changes
- Migration utilities for config upgrades

## Error Handling

### Common Scenarios
1. **Config directory doesn't exist** → Create it
2. **Config file corrupted** → Backup and regenerate
3. **Encryption key missing** → Regenerate (lose existing credentials)
4. **Permission denied** → Fallback to temp directory or in-memory
5. **Disk full** → Graceful degradation, warn user

### Fallback Strategy
```python
def load_config():
    try:
        return load_from_file()
    except FileNotFoundError:
        logger.info("No config file found, starting with defaults")
        return default_config()
    except PermissionError:
        logger.warning("Config file permission denied, using in-memory mode")
        return default_config()
    except Exception as e:
        logger.error(f"Config loading failed: {e}, using defaults")
        return default_config()
```

## Testing Strategy

### Unit Tests
- ✅ Config serialization/deserialization
- ✅ Encryption/decryption round-trip
- ✅ File permission handling
- ✅ Error scenarios and fallbacks

### Integration Tests  
- ✅ End-to-end save/load cycle
- ✅ Cross-platform path handling
- ✅ Authentication flow with persisted credentials

## Implementation Files

### New Files to Create
```
config_manager.py           # Main configuration management
credential_encryption.py   # Credential encryption utilities
config_migration.py        # Future schema migration support
```

### Files to Modify
```
container_registry_card_catalog.py  # Add config loading on startup
registry_config_modal.py           # Save config when changed
```

## Success Criteria

✅ **User Experience**: Configured monitored repos and auth persist across restarts
✅ **Security**: Credentials encrypted at rest, no plain text exposure  
✅ **Reliability**: Graceful handling of missing/corrupted config files
✅ **Cross-platform**: Works on Linux, macOS, Windows
✅ **Performance**: Fast startup (config loading < 100ms)

---

This design provides a secure, robust foundation for persistent configuration storage while maintaining the current in-memory performance and user experience.