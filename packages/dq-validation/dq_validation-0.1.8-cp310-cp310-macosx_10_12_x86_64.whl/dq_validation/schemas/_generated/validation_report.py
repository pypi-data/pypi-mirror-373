# generated by datamodel-codegen:
#   filename:  validation_report.json

from __future__ import annotations

from enum import Enum
from typing import Optional, Sequence

from pydantic import BaseModel, Field, RootModel, conint


class Version(Enum):
    v0 = 'v0'


class CellLocation(BaseModel):
    column: conint(ge=0)
    row: conint(ge=0)


class CellValidationErrorCode(Enum):
    EMPTY_CELL = 'EMPTY_CELL'
    INTERNAL_VALIDATION_ERROR = 'INTERNAL_VALIDATION_ERROR'
    INVALID_NUMBER_FORMAT = 'INVALID_NUMBER_FORMAT'
    INVALID_INTEGER_FORMAT = 'INVALID_INTEGER_FORMAT'
    INVALID_EMAIL_FORMAT = 'INVALID_EMAIL_FORMAT'
    INVALID_ISO_DATE_FORMAT = 'INVALID_ISO_DATE_FORMAT'
    INVALID_PHONE_E164_NUMBER = 'INVALID_PHONE_E164_NUMBER'
    INVALID_FLOAT_FORMAT = 'INVALID_FLOAT_FORMAT'
    INVALID_SHA256_HEX_FORMAT = 'INVALID_SHA256_HEX_FORMAT'
    INVALID_NUMERIC_RANGE = 'INVALID_NUMERIC_RANGE'


class DropInvalidRows(BaseModel):
    numInvalidRowsDropped: conint(ge=0)


class DuplicationValidationErrorCode(Enum):
    DUPLICATE_VALUES = 'DUPLICATE_VALUES'


class MultiColumnLocation(BaseModel):
    columns: Sequence[conint(ge=0)]
    row: conint(ge=0)


class SchemaValidationErrorCode(Enum):
    INTERNAL_VALIDATION_ERROR = 'INTERNAL_VALIDATION_ERROR'
    DUPLICATE_VALUES = 'DUPLICATE_VALUES'
    NOT_ENOUGH_COLUMNS_PROVIDED = 'NOT_ENOUGH_COLUMNS_PROVIDED'
    TOO_MANY_COLUMNS_PROVIDED = 'TOO_MANY_COLUMNS_PROVIDED'
    EMPTY_FILE = 'EMPTY_FILE'


class TableValidationErrorCode(Enum):
    EMPTY_FILE = 'EMPTY_FILE'
    INVALID_NUMBER_OF_ROWS = 'INVALID_NUMBER_OF_ROWS'


class ValidationOutcome(Enum):
    PASSED = 'PASSED'
    FAILED = 'FAILED'


class CellValidationError(BaseModel):
    code: CellValidationErrorCode
    location: CellLocation
    message: str


class DuplicationValidationError(BaseModel):
    code: DuplicationValidationErrorCode
    location: MultiColumnLocation


class SchemaValidationError(BaseModel):
    code: SchemaValidationErrorCode
    message: str
    row: conint(ge=0)


class TableValidationError(BaseModel):
    code: TableValidationErrorCode
    message: str


class ValidatedColumnV0(BaseModel):
    column: conint(ge=0)
    numErrorsTotal: conint(ge=0)
    recordedErrors: Sequence[CellValidationError]


class ValidatedSchemaV0(BaseModel):
    numErrorsTotal: conint(ge=0)
    recordedErrors: Sequence[SchemaValidationError]


class ValidatedTableV0(BaseModel):
    numErrorsTotal: conint(ge=0)
    recordedErrors: Sequence[TableValidationError]


class ValidatedUniqueness(BaseModel):
    numErrorsTotal: conint(ge=0)
    recordedErrors: Sequence[DuplicationValidationError]


class ValidationReportV0(BaseModel):
    columns: Sequence[ValidatedColumnV0]
    detectedFileType: Optional[str] = None
    dropInvalidRows: Optional[DropInvalidRows] = None
    numInvalidRowsTotal: conint(ge=0)
    numRowsTotal: Optional[conint(ge=0)] = 0
    originalFileSizeBytes: Optional[conint(ge=0)] = None
    outcome: ValidationOutcome
    schema_: ValidatedSchemaV0 = Field(..., alias='schema')
    table: ValidatedTableV0
    uniqueness: Optional[ValidatedUniqueness] = None


class ValidationReport1(BaseModel):
    report: ValidationReportV0
    version: Version


class ValidationReport(RootModel[ValidationReport1]):
    root: ValidationReport1 = Field(..., title='ValidationReport')
