Metadata-Version: 2.4
Name: rapidgeo
Version: 0.1.1
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: License :: OSI Approved :: Apache Software License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Programming Language :: Rust
Classifier: Topic :: Scientific/Engineering :: GIS
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Requires-Dist: numpy>=1.19.0 ; extra == 'numpy'
Provides-Extra: numpy
Summary: Fast geographic and planar distance calculations with Python bindings
Keywords: distance,geodesic,haversine,vincenty,geometry,gis
Home-Page: https://github.com/gaker/rapidgeo
Author: gaker
License: MIT OR Apache-2.0
Requires-Python: >=3.8
Description-Content-Type: text/markdown; charset=UTF-8; variant=GFM
Project-URL: Homepage, https://github.com/gaker/rapidgeo
Project-URL: Repository, https://github.com/gaker/rapidgeo
Project-URL: Documentation, https://rapidgeo.readthedocs.io/
Project-URL: Issues, https://github.com/gaker/rapidgeo/issues

# rapidgeo

[![PyPI](https://img.shields.io/pypi/v/rapidgeo.svg)](https://pypi.org/project/rapidgeo/)
[![License](https://img.shields.io/badge/license-MIT%20OR%20Apache--2.0-blue.svg)](LICENSE)

Fast geographic and planar distance calculations for Python.

## Installation

```bash
pip install rapidgeo          # Base package
pip install rapidgeo[numpy]   # With NumPy support
```

## Quick Start

```python
from rapidgeo.distance import LngLat
from rapidgeo.distance.geo import haversine, vincenty_distance
from rapidgeo.distance.euclid import euclid
from rapidgeo.distance.batch import pairwise_haversine

# Create coordinates (longitude, latitude)
sf = LngLat.new_deg(-122.4194, 37.7749)   # San Francisco
nyc = LngLat.new_deg(-74.0060, 40.7128)   # New York City

# Haversine: 0.5% accuracy for distances <1000km
distance = haversine(sf, nyc)
print(f"Distance: {distance / 1000:.1f} km")

# Vincenty: 1mm accuracy globally
precise = vincenty_distance(sf, nyc)
print(f"Precise: {precise / 1000:.3f} km")

# Euclidean: Fast but inaccurate for large distances
euclidean = euclid(sf, nyc)
print(f"Euclidean: {euclidean:.6f}ï¿½")

# Batch processing
path = [sf, nyc, LngLat.new_deg(-87.6298, 41.8781)]  # Add Chicago
distances = list(pairwise_haversine(path))
```

## Coordinate System

All coordinates use **longitude, latitude** ordering (lng, lat):

```python
# Correct
point = LngLat.new_deg(-122.4194, 37.7749)  # lng first, lat second

# Common mistake
# point = LngLat.new_deg(37.7749, -122.4194)  # lat, lng - WRONG
```


## License

Licensed under either of [Apache License, Version 2.0](LICENSE-APACHE) or [MIT License](LICENSE-MIT) at your option.
