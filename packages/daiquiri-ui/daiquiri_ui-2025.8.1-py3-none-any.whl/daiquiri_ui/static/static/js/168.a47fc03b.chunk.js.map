{"version":3,"file":"static/js/168.a47fc03b.chunk.js","mappings":"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","sources":["connect/scans/ScanPlot0dValue.js","components/scans/ScanPlot0dValue.tsx","components/yaml-layout/components/scans/ScanPlot0dValue.tsx","connect/ConnectUtils.ts"],"sourcesContent":["import ScanPlot0dValue from 'components/scans/ScanPlot0dValue';\nimport { withNamespace } from 'providers/namespace';\nimport scans from 'providers/scans';\nimport { connect } from 'react-redux';\n\nimport mapStateToPropsWithCache from '../ConnectUtils';\n\nconst mapStateAndCacheToProps = (state, own, cache) => {\n  const { data, list } = own.providers.scans;\n  return {\n    data: data.selector('results', state),\n    scans: list.selector('results', state),\n    currentPoint: scans.selector('currentPoint', state),\n    selectedScan: scans.selector('selectedScan', state)\n  };\n};\n\nconst mapDispatchToProps = (dispatch, own) => ({\n  actions: {\n    setFollow: () => {\n      if (own.selectedScan === undefined) {\n        scans.dispatch('RESET_SCAN_SELECTION');\n      }\n    },\n    setPageSize: payload => own.providers.scans.data.setPageSize(payload, true),\n    setPage: (payload, fetch) =>\n      own.providers.scans.data.setPage(payload, fetch),\n    setParams: (payload, fetch) =>\n      own.providers.scans.data.setParams(payload, fetch)\n  }\n});\n\nexport default withNamespace({ scans })(\n  connect(\n    mapStateToPropsWithCache(mapStateAndCacheToProps),\n    mapDispatchToProps\n  )(ScanPlot0dValue)\n);\n","import { useEffect } from 'react';\nimport { Row, Col, Badge } from 'react-bootstrap';\nimport { dynamicOp } from '@esrf/daiquiri-lib';\nimport type { Scan, PagedScanData } from './models';\nimport { findLastScanId } from './utils';\n\nexport interface ScanPlot0dValueOptions {\n  /** Selected data series to display */\n  series: string;\n  /** Name for the value (overrides `series` name) */\n  name?: string;\n  /** Round the value to n digits (if float) */\n  round?: number;\n  /** Comparison to show value as ok */\n  comparison?: string;\n  /** Comparator to use */\n  comparator?: string;\n}\n\ninterface Props {\n  scans: Record<string, Scan>;\n  data: Record<string, PagedScanData>;\n  actions: {\n    setPageSize: (size: number) => void;\n    setPage: (pageNumber?: number, fetch?: boolean) => void;\n    setParams: (\n      p: { scalars?: string[]; scanid?: number },\n      fetch?: boolean\n    ) => void;\n    setFollow: () => void;\n  };\n  selectedScan: number;\n  currentPoint: number;\n  options: ScanPlot0dValueOptions;\n}\n\nexport default function ScanPlot0dValue(props: Props) {\n  const { options, selectedScan, currentPoint, data, scans, actions } = props;\n  const { series } = options;\n\n  const lastScanId = findLastScanId(scans);\n\n  useEffect(() => {\n    actions.setFollow();\n    actions.setPage(undefined);\n    actions.setParams({\n      scalars: [series],\n    });\n    if (lastScanId) {\n      actions.setParams(\n        {\n          scanid: lastScanId,\n        },\n        true\n      );\n    }\n  }, []);\n\n  useEffect(() => {\n    let scanid = selectedScan;\n    if (!scanid) {\n      // Follow latest scan\n      if (lastScanId) scanid = lastScanId;\n    }\n\n    if (scanid) {\n      actions.setParams(\n        {\n          scanid,\n        },\n        true\n      );\n    }\n  }, [selectedScan]);\n\n  if (!series) {\n    return (\n      <div className=\"bg-warning rounded p-1\">\n        <i className=\"fa fa-warning m-1\" />\n        Please specify a `series` in the config\n      </div>\n    );\n  }\n\n  const name = options.name || series;\n\n  if (lastScanId === null) {\n    return <span>{name}: No scan loaded.</span>;\n  }\n\n  const scanid = selectedScan || lastScanId;\n  const obj = data[scanid] || {};\n  if (!obj.data) {\n    return <span>{name}: Waiting for scan data</span>;\n  }\n\n  if (!obj.axes.ys.scalars.includes(series)) {\n    return (\n      <div className=\"bg-warning rounded p-1\">\n        Scan does not include `{series}`\n      </div>\n    );\n  }\n\n  const y = obj.data[series];\n  if (!y) {\n    return (\n      <div className=\"bg-warning rounded p-1\">No y data yet for `{series}`</div>\n    );\n  }\n\n  if (!y.data) {\n    return (\n      <div className=\"bg-warning rounded p-1\">\n        Data not yet loaded for `{series}`\n      </div>\n    );\n  }\n\n  // Follow latest point if `currentPoint` is null (not undefined!)\n  const point = currentPoint !== null ? currentPoint : y.data.length - 1;\n  const value = y.data[point];\n\n  let checkClass = 'primary';\n  if (options.comparator && options.comparison) {\n    const check = dynamicOp(options.comparator, value, options.comparison);\n    checkClass = check ? 'success' : 'danger';\n  }\n\n  let valueString = String(value);\n  if (options.round !== undefined) {\n    if (value !== undefined && !Number.isNaN(value)) {\n      valueString = value.toFixed(options.round);\n    }\n  }\n\n  return (\n    <div className=\"scanplot0d-value\">\n      <Row>\n        <Col>{name}:</Col>\n        <Col>\n          <Badge bg={checkClass}>{valueString}</Badge>\n          <span className=\"invisible\">\n            [{point}, {obj.page}]\n          </span>\n        </Col>\n      </Row>\n    </div>\n  );\n}\n","import type { YamlComponent } from '@esrf/daiquiri-lib';\nimport { YamlAsserts } from '@esrf/daiquiri-lib';\nimport ScanPlot0dValue from 'connect/scans/ScanPlot0dValue';\n\nexport default function Yaml(props: YamlComponent) {\n  const {\n    yamlNode,\n    providers,\n    series,\n    name,\n    round,\n    comparison,\n    comparator,\n    ...unknownOptions\n  } = props;\n  YamlAsserts.assertString(yamlNode, 'series', series);\n  YamlAsserts.assertOptionalString(yamlNode, 'name', name);\n  YamlAsserts.assertOptionalNumber(yamlNode, 'round', round);\n  YamlAsserts.assertOptionalString(yamlNode, 'comparison', comparison);\n  YamlAsserts.assertOptionalString(yamlNode, 'comparator', comparator);\n\n  YamlAsserts.assertNoUnknownKeys(yamlNode, unknownOptions);\n  return (\n    <ScanPlot0dValue\n      providers={providers}\n      options={{ series, name, round, comparison, comparator }}\n    />\n  );\n}\n","import lodash from 'lodash';\n\nexport class Cache {\n  private cache: Record<string, any>;\n\n  public constructor() {\n    this.cache = {};\n  }\n\n  /**\n   * Returns and store value if the previous stored value deep differ.\n   *\n   * Else returns the previous stored value\n   */\n  public debounce<T>(name: string, value: T): T {\n    const previous = this.cache[name];\n    if (lodash.isEqual(previous, value)) {\n      return previous;\n    }\n    this.cache[name] = value;\n    return value;\n  }\n\n  /**\n   * Compute and returns and cache a value if the previous stored value deep differ.\n   *\n   * Else returns the previous computed result.\n   */\n  public memo<T>(name: string, callable: () => T, deps: unknown[]): T {\n    const defaultResult = [undefined, undefined];\n    const [previousResult, previousDeps] = this.cache[name] || defaultResult;\n    if (lodash.isEqual(previousDeps, deps)) {\n      return previousResult;\n    }\n    const result = callable();\n    this.cache[name] = [result, deps];\n    return result;\n  }\n}\n\nexport default function mapStateToPropsWithCache<S, O, R>(\n  mapStateToProps: (state: S, own: O, cache: Cache) => R\n): (state: S, own: O) => R {\n  const cache = new Cache();\n  return (state, own) => mapStateToProps(state, own, cache);\n}\n"],"names":["withNamespace","scans","connect","mapStateToPropsWithCache","mapStateAndCacheToProps","state","own","cache","data","list","providers","selector","currentPoint","selectedScan","mapDispatchToProps","dispatch","actions","setFollow","undefined","setPageSize","payload","setPage","fetch","setParams","props","options","series","lastScanId","findLastScanId","useEffect","scalars","scanid","_jsxs","className","children","_jsx","name","obj","axes","ys","includes","y","point","length","value","checkClass","comparator","comparison","dynamicOp","valueString","String","round","Number","isNaN","toFixed","Row","Col","Badge","bg","page","Yaml","yamlNode","unknownOptions","YamlAsserts","ScanPlot0dValue","Cache","constructor","this","debounce","previous","lodash","memo","callable","deps","defaultResult","previousResult","previousDeps","result","mapStateToProps"],"sourceRoot":""}