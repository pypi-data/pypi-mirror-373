{
  "timestamp": "2025-08-22T16:18:06.162021",
  "components": {
    "data_generators": {
      "ARFIMAModel": {
        "class_name": "ARFIMAModel",
        "module_name": "models.data_models.arfima.arfima_model",
        "file_path": "models\\data_models\\arfima\\arfima_model.py",
        "constructor_params": {
          "d": {
            "type": "any",
            "default": null,
            "required": true
          },
          "ar_params": {
            "type": "any",
            "default": null,
            "required": false
          },
          "ma_params": {
            "type": "any",
            "default": null,
            "required": false
          },
          "sigma": {
            "type": "any",
            "default": 1.0,
            "required": false
          },
          "method": {
            "type": "any",
            "default": "spectral",
            "required": false
          }
        },
        "type": "stochastic",
        "description": "\nAutoregressive Fractionally Integrated Moving Average (ARFIMA) model.\n\nARFIMA(p,d,q) process combines autoregressive (AR), fractionally integrated (FI),\nand moving average (MA) components. The fractional integration parameter d\ncontrols long-range dependence.\n\nParameters\n----------\nd : float\n    Fractional integration parameter (-0.5 < d < 0.5)\nar_params : List[float], optional\n    Autoregressive parameters (default: [])\nma_params : List[float], optional\n    Moving average parameters (default: [])\nsigma : float, optional\n    Standard deviation of innovations (default: 1.0)\nmethod : str, optional\n    Generation method (default: 'spectral')\n"
      },
      "BaseModel": {
        "class_name": "BaseModel",
        "module_name": "models.data_models.mrw.mrw_model",
        "file_path": "models\\data_models\\mrw\\mrw_model.py",
        "constructor_params": {},
        "type": "stochastic",
        "description": "\nAbstract base class for all stochastic models.\n\nThis class defines the interface that all stochastic models must implement,\nincluding methods for parameter validation, data generation, and model\ninformation retrieval.\n"
      },
      "FractionalBrownianMotion": {
        "class_name": "FractionalBrownianMotion",
        "module_name": "models.data_models.fbm.fbm_model",
        "file_path": "models\\data_models\\fbm\\fbm_model.py",
        "constructor_params": {
          "H": {
            "type": "any",
            "default": null,
            "required": true
          },
          "sigma": {
            "type": "any",
            "default": 1.0,
            "required": false
          },
          "method": {
            "type": "any",
            "default": "davies_harte",
            "required": false
          }
        },
        "type": "stochastic",
        "description": "\nFractional Brownian Motion (fBm) model.\n\nFractional Brownian motion is a self-similar Gaussian process with\nstationary increments. It is characterized by the Hurst parameter H,\nwhere 0 < H < 1.\n\nParameters\n----------\nH : float\n    Hurst parameter (0 < H < 1)\n    - H = 0.5: Standard Brownian motion\n    - H > 0.5: Persistent (long-range dependence)\n    - H < 0.5: Anti-persistent\nsigma : float, optional\n    Standard deviation of the process (default: 1.0)\nmethod : str, optional\n    Method for generating fBm:\n    - 'davies_harte': Davies-Harte method (default)\n    - 'cholesky': Cholesky decomposition method\n    - 'circulant': Circulant embedding method\n"
      },
      "FractionalGaussianNoise": {
        "class_name": "FractionalGaussianNoise",
        "module_name": "models.data_models.fgn.fgn_model",
        "file_path": "models\\data_models\\fgn\\fgn_model.py",
        "constructor_params": {
          "H": {
            "type": "any",
            "default": null,
            "required": true
          },
          "sigma": {
            "type": "any",
            "default": 1.0,
            "required": false
          },
          "method": {
            "type": "any",
            "default": "circulant",
            "required": false
          }
        },
        "type": "stochastic",
        "description": "\nFractional Gaussian Noise (fGn) generator.\n\nfGn is the stationary increment process of fractional Brownian motion (fBm).\nThis class generates fGn directly using the circulant embedding approach on\nthe autocovariance function of fGn.\n"
      },
      "MultifractalRandomWalk": {
        "class_name": "MultifractalRandomWalk",
        "module_name": "models.data_models.mrw.mrw_model",
        "file_path": "models\\data_models\\mrw\\mrw_model.py",
        "constructor_params": {
          "H": {
            "type": "any",
            "default": null,
            "required": true
          },
          "lambda_param": {
            "type": "any",
            "default": null,
            "required": true
          },
          "sigma": {
            "type": "any",
            "default": 1.0,
            "required": false
          },
          "method": {
            "type": "any",
            "default": "cascade",
            "required": false
          }
        },
        "type": "stochastic",
        "description": "\nMultifractal Random Walk (MRW) model.\n\nMRW is a multifractal process that exhibits scale-invariant properties\nand is characterized by a log-normal volatility cascade. It is defined\nby the Hurst parameter H and the intermittency parameter \u03bb.\n\nParameters\n----------\nH : float\n    Hurst parameter (0 < H < 1)\nlambda_param : float\n    Intermittency parameter (\u03bb > 0)\nsigma : float, optional\n    Base volatility (default: 1.0)\nmethod : str, optional\n    Generation method (default: 'cascade')\n"
      }
    },
    "estimators": {
      "BaseMLEstimator": {
        "class_name": "BaseMLEstimator",
        "module_name": "analysis.machine_learning.transformer_estimator",
        "file_path": "analysis\\machine_learning\\transformer_estimator.py",
        "constructor_params": {},
        "category": "other",
        "description": "\nAbstract base class for all machine learning-based estimators.\n\nThis class defines the interface that all ML estimators must implement,\nincluding methods for feature extraction, model training, prediction,\nand performance evaluation.\n"
      },
      "CNNEstimator": {
        "class_name": "CNNEstimator",
        "module_name": "analysis.machine_learning.cnn_estimator",
        "file_path": "analysis\\machine_learning\\cnn_estimator.py",
        "constructor_params": {},
        "category": "other",
        "description": "\nConvolutional Neural Network estimator for Hurst parameter estimation.\n\nThis estimator uses CNN to learn the mapping from time series data\nto Hurst parameters. Currently a placeholder for future implementation.\n"
      },
      "GradientBoostingEstimator": {
        "class_name": "GradientBoostingEstimator",
        "module_name": "analysis.machine_learning.gradient_boosting_estimator",
        "file_path": "analysis\\machine_learning\\gradient_boosting_estimator.py",
        "constructor_params": {},
        "category": "other",
        "description": "\nGradient Boosting estimator for Hurst parameter estimation.\n\nThis estimator uses gradient boosting to learn the mapping\nfrom time series features to Hurst parameters.\n"
      },
      "GRUEstimator": {
        "class_name": "GRUEstimator",
        "module_name": "analysis.machine_learning.gru_estimator",
        "file_path": "analysis\\machine_learning\\gru_estimator.py",
        "constructor_params": {},
        "category": "other",
        "description": "GRU estimator for Hurst parameter estimation using PyTorch."
      },
      "LSTMEstimator": {
        "class_name": "LSTMEstimator",
        "module_name": "analysis.machine_learning.lstm_estimator",
        "file_path": "analysis\\machine_learning\\lstm_estimator.py",
        "constructor_params": {},
        "category": "other",
        "description": "\nLSTM estimator for Hurst parameter estimation using PyTorch.\n"
      },
      "NeuralNetworkEstimator": {
        "class_name": "NeuralNetworkEstimator",
        "module_name": "analysis.machine_learning.neural_network_estimator",
        "file_path": "analysis\\machine_learning\\neural_network_estimator.py",
        "constructor_params": {},
        "category": "other",
        "description": "\nNeural Network estimator for Hurst parameter estimation.\n\nThis estimator uses a multi-layer perceptron (MLP) to learn the mapping\nfrom time series features to Hurst parameters.\n"
      },
      "RandomForestEstimator": {
        "class_name": "RandomForestEstimator",
        "module_name": "analysis.machine_learning.random_forest_estimator",
        "file_path": "analysis\\machine_learning\\random_forest_estimator.py",
        "constructor_params": {},
        "category": "other",
        "description": "\nRandom Forest estimator for Hurst parameter estimation.\n\nThis estimator uses an ensemble of decision trees to learn the mapping\nfrom time series features to Hurst parameters.\n"
      },
      "SVREstimator": {
        "class_name": "SVREstimator",
        "module_name": "analysis.machine_learning.svr_estimator",
        "file_path": "analysis\\machine_learning\\svr_estimator.py",
        "constructor_params": {},
        "category": "other",
        "description": "\nSupport Vector Regression estimator for Hurst parameter estimation.\n\nThis estimator uses support vector regression to learn the mapping\nfrom time series features to Hurst parameters.\n"
      },
      "TransformerEstimator": {
        "class_name": "TransformerEstimator",
        "module_name": "analysis.machine_learning.transformer_estimator",
        "file_path": "analysis\\machine_learning\\transformer_estimator.py",
        "constructor_params": {},
        "category": "other",
        "description": "\nTransformer estimator for Hurst parameter estimation.\n\nThis estimator uses transformer architecture to learn the mapping from time series data\nto Hurst parameters. Currently a placeholder for future implementation.\n"
      },
      "BaseEstimator": {
        "class_name": "BaseEstimator",
        "module_name": "models.estimators.base_estimator",
        "file_path": "models\\estimators\\base_estimator.py",
        "constructor_params": {},
        "category": "other",
        "description": "\nAbstract base class for all parameter estimators.\n\nThis class defines the interface that all estimators must implement,\nincluding methods for parameter estimation, confidence intervals,\nand result reporting.\n"
      },
      "CWTEstimator": {
        "class_name": "CWTEstimator",
        "module_name": "analysis.wavelet.cwt.cwt_estimator",
        "file_path": "analysis\\wavelet\\cwt\\cwt_estimator.py",
        "constructor_params": {
          "wavelet": {
            "type": "any",
            "default": "cmor1.5-1.0",
            "required": false
          },
          "scales": {
            "type": "any",
            "default": null,
            "required": false
          },
          "confidence": {
            "type": "any",
            "default": 0.95,
            "required": false
          }
        },
        "category": "wavelet",
        "description": "\nContinuous Wavelet Transform (CWT) Analysis estimator.\n\nThis estimator uses continuous wavelet transforms to analyze the scaling behavior\nof time series data and estimate the Hurst parameter for fractional processes.\n\nAttributes:\n    wavelet (str): Wavelet type to use for continuous transform\n    scales (np.ndarray): Array of scales for wavelet analysis\n    confidence (float): Confidence level for confidence intervals\n"
      },
      "WaveletLogVarianceEstimator": {
        "class_name": "WaveletLogVarianceEstimator",
        "module_name": "analysis.wavelet.log_variance.wavelet_log_variance_estimator",
        "file_path": "analysis\\wavelet\\log_variance\\wavelet_log_variance_estimator.py",
        "constructor_params": {
          "wavelet": {
            "type": "any",
            "default": "db4",
            "required": false
          },
          "scales": {
            "type": "any",
            "default": null,
            "required": false
          },
          "confidence": {
            "type": "any",
            "default": 0.95,
            "required": false
          }
        },
        "category": "wavelet",
        "description": "\nWavelet Log Variance Analysis estimator.\n\nThis estimator uses wavelet decomposition to analyze the log-transformed variance\nof wavelet coefficients at different scales, which can be used to estimate the \nHurst parameter for fractional processes with improved statistical properties.\n\nAttributes:\n    wavelet (str): Wavelet type to use for decomposition\n    scales (List[int]): List of scales for wavelet analysis\n    confidence (float): Confidence level for confidence intervals\n"
      },
      "WaveletVarianceEstimator": {
        "class_name": "WaveletVarianceEstimator",
        "module_name": "analysis.wavelet.variance.wavelet_variance_estimator",
        "file_path": "analysis\\wavelet\\variance\\wavelet_variance_estimator.py",
        "constructor_params": {
          "wavelet": {
            "type": "any",
            "default": "db4",
            "required": false
          },
          "scales": {
            "type": "any",
            "default": null,
            "required": false
          },
          "confidence": {
            "type": "any",
            "default": 0.95,
            "required": false
          }
        },
        "category": "wavelet",
        "description": "\nWavelet Variance Analysis estimator.\n\nThis estimator uses wavelet decomposition to analyze the variance of wavelet\ncoefficients at different scales, which can be used to estimate the Hurst\nparameter for fractional processes.\n\nAttributes:\n    wavelet (str): Wavelet type to use for decomposition\n    scales (List[int]): List of scales for wavelet analysis\n    confidence (float): Confidence level for confidence intervals\n"
      },
      "WaveletWhittleEstimator": {
        "class_name": "WaveletWhittleEstimator",
        "module_name": "analysis.wavelet.whittle.wavelet_whittle_estimator",
        "file_path": "analysis\\wavelet\\whittle\\wavelet_whittle_estimator.py",
        "constructor_params": {
          "wavelet": {
            "type": "any",
            "default": "db4",
            "required": false
          },
          "scales": {
            "type": "any",
            "default": null,
            "required": false
          },
          "confidence": {
            "type": "any",
            "default": 0.95,
            "required": false
          }
        },
        "category": "wavelet",
        "description": "\nWavelet Whittle Analysis estimator.\n\nThis estimator combines wavelet decomposition with Whittle likelihood estimation\nto provide robust estimation of the Hurst parameter for fractional processes.\n\nAttributes:\n    wavelet (str): Wavelet type to use for decomposition\n    scales (List[int]): List of scales for wavelet analysis\n    confidence (float): Confidence level for confidence intervals\n"
      },
      "DFAEstimator": {
        "class_name": "DFAEstimator",
        "module_name": "analysis.temporal.dfa.dfa_estimator",
        "file_path": "analysis\\temporal\\dfa\\dfa_estimator.py",
        "constructor_params": {
          "min_box_size": {
            "type": "any",
            "default": 4,
            "required": false
          },
          "max_box_size": {
            "type": "any",
            "default": null,
            "required": false
          },
          "box_sizes": {
            "type": "any",
            "default": null,
            "required": false
          },
          "polynomial_order": {
            "type": "any",
            "default": 1,
            "required": false
          }
        },
        "category": "temporal",
        "description": "\nDetrended Fluctuation Analysis (DFA) estimator.\n\nDFA is a method for quantifying long-range correlations in time series\nthat is robust to non-stationarities. It estimates the Hurst parameter\nby analyzing the scaling behavior of detrended fluctuations.\n\nParameters\n----------\nmin_box_size : int, optional\n    Minimum box size for analysis (default: 4)\nmax_box_size : int, optional\n    Maximum box size for analysis (default: None, will use n/4)\nbox_sizes : array-like, optional\n    Specific box sizes to use (default: None)\npolynomial_order : int, optional\n    Order of polynomial for detrending (default: 1)\n"
      },
      "DMAEstimator": {
        "class_name": "DMAEstimator",
        "module_name": "analysis.temporal.dma.dma_estimator",
        "file_path": "analysis\\temporal\\dma\\dma_estimator.py",
        "constructor_params": {
          "min_window_size": {
            "type": "any",
            "default": 4,
            "required": false
          },
          "max_window_size": {
            "type": "any",
            "default": null,
            "required": false
          },
          "window_sizes": {
            "type": "any",
            "default": null,
            "required": false
          },
          "overlap": {
            "type": "any",
            "default": true,
            "required": false
          }
        },
        "category": "temporal",
        "description": "\nDetrended Moving Average (DMA) estimator for Hurst parameter.\n\nThe DMA method is a variant of DFA that uses a moving average instead\nof polynomial fitting for detrending. It is computationally efficient\nand robust to various types of non-stationarity.\n\nThe method works by:\n1. Computing the cumulative sum of the time series\n2. For each window size, calculating the moving average\n3. Detrending by subtracting the moving average\n4. Computing the fluctuation function\n5. Fitting a power law relationship: F(n) ~ n^H\n\nParameters\n----------\nmin_window_size : int, default=4\n    Minimum window size for DMA calculation.\nmax_window_size : int, optional\n    Maximum window size. If None, uses n/4 where n is data length.\nwindow_sizes : List[int], optional\n    Specific window sizes to use. If provided, overrides min/max.\noverlap : bool, default=True\n    Whether to use overlapping windows for moving average.\n"
      },
      "HiguchiEstimator": {
        "class_name": "HiguchiEstimator",
        "module_name": "analysis.temporal.higuchi.higuchi_estimator",
        "file_path": "analysis\\temporal\\higuchi\\higuchi_estimator.py",
        "constructor_params": {
          "min_k": {
            "type": "any",
            "default": 2,
            "required": false
          },
          "max_k": {
            "type": "any",
            "default": null,
            "required": false
          },
          "k_values": {
            "type": "any",
            "default": null,
            "required": false
          }
        },
        "category": "temporal",
        "description": "\nHiguchi Method estimator for fractal dimension and Hurst parameter.\n\nThe Higuchi method is an efficient algorithm for estimating the fractal\ndimension of a time series. It is based on the relationship between the\nlength of the curve and the time interval used to measure it.\n\nThe method works by:\n1. Computing the curve length for different time intervals k\n2. Fitting a power law relationship: L(k) ~ k^(-D)\n3. The fractal dimension D is related to the Hurst parameter H by: H = 2 - D\n\nParameters\n----------\nmin_k : int, default=2\n    Minimum time interval for curve length calculation.\nmax_k : int, optional\n    Maximum time interval. If None, uses n/4 where n is data length.\nk_values : List[int], optional\n    Specific k values to use. If provided, overrides min/max.\n"
      },
      "RSEstimator": {
        "class_name": "RSEstimator",
        "module_name": "analysis.temporal.rs.rs_estimator",
        "file_path": "analysis\\temporal\\rs\\rs_estimator.py",
        "constructor_params": {
          "min_window_size": {
            "type": "any",
            "default": 10,
            "required": false
          },
          "max_window_size": {
            "type": "any",
            "default": null,
            "required": false
          },
          "window_sizes": {
            "type": "any",
            "default": null,
            "required": false
          },
          "overlap": {
            "type": "any",
            "default": false,
            "required": false
          }
        },
        "category": "temporal",
        "description": "\nRescaled Range (R/S) Analysis estimator.\n\nThe R/S method estimates the Hurst parameter by analyzing the scaling\nbehavior of the rescaled range statistic across different time scales.\n\nParameters\n----------\nmin_scale : int, optional\n    Minimum scale (window size) to use (default: 10)\nmax_scale : int, optional\n    Maximum scale (window size) to use (default: None, uses n/4)\nnum_scales : int, optional\n    Number of scales to use (default: 20)\n"
      },
      "GPHEstimator": {
        "class_name": "GPHEstimator",
        "module_name": "analysis.spectral.gph.gph_estimator",
        "file_path": "analysis\\spectral\\gph\\gph_estimator.py",
        "constructor_params": {
          "min_freq_ratio": {
            "type": "any",
            "default": 0.01,
            "required": false
          },
          "max_freq_ratio": {
            "type": "any",
            "default": 0.1,
            "required": false
          },
          "use_welch": {
            "type": "any",
            "default": true,
            "required": false
          },
          "window": {
            "type": "any",
            "default": "hann",
            "required": false
          },
          "nperseg": {
            "type": "any",
            "default": null,
            "required": false
          },
          "apply_bias_correction": {
            "type": "any",
            "default": true,
            "required": false
          }
        },
        "category": "spectral",
        "description": "\nGeweke-Porter-Hudak (GPH) Hurst parameter estimator.\n\nThis estimator uses log-periodogram regression with the regressor\nlog(4*sin^2(\u03c9/2)) to estimate the fractional differencing parameter d,\nthen converts to Hurst parameter as H = d + 0.5.\n\nParameters\n----------\nmin_freq_ratio : float, optional (default=0.01)\n    Minimum frequency ratio (relative to Nyquist) for fitting.\nmax_freq_ratio : float, optional (default=0.1)\n    Maximum frequency ratio (relative to Nyquist) for fitting.\nuse_welch : bool, optional (default=True)\n    Whether to use Welch's method for PSD estimation.\nwindow : str, optional (default='hann')\n    Window function for Welch's method.\nnperseg : int, optional (default=None)\n    Length of each segment for Welch's method. If None, uses n/8.\napply_bias_correction : bool, optional (default=True)\n    Whether to apply bias correction for finite sample effects.\n"
      },
      "PeriodogramEstimator": {
        "class_name": "PeriodogramEstimator",
        "module_name": "analysis.spectral.periodogram.periodogram_estimator",
        "file_path": "analysis\\spectral\\periodogram\\periodogram_estimator.py",
        "constructor_params": {
          "min_freq_ratio": {
            "type": "any",
            "default": 0.01,
            "required": false
          },
          "max_freq_ratio": {
            "type": "any",
            "default": 0.1,
            "required": false
          },
          "use_welch": {
            "type": "any",
            "default": true,
            "required": false
          },
          "window": {
            "type": "any",
            "default": "hann",
            "required": false
          },
          "nperseg": {
            "type": "any",
            "default": null,
            "required": false
          },
          "use_multitaper": {
            "type": "any",
            "default": false,
            "required": false
          },
          "n_tapers": {
            "type": "any",
            "default": 3,
            "required": false
          }
        },
        "category": "spectral",
        "description": "\nPeriodogram-based Hurst parameter estimator.\n\nThis estimator computes the power spectral density (PSD) of the time series\nand fits a power law to the low-frequency portion to estimate the Hurst\nparameter. The relationship is: PSD(f) ~ f^(-beta) where beta = 2H - 1.\n\nParameters\n----------\nmin_freq_ratio : float, optional (default=0.01)\n    Minimum frequency ratio (relative to Nyquist) for fitting.\nmax_freq_ratio : float, optional (default=0.1)\n    Maximum frequency ratio (relative to Nyquist) for fitting.\nuse_welch : bool, optional (default=True)\n    Whether to use Welch's method for PSD estimation.\nwindow : str, optional (default='hann')\n    Window function for Welch's method.\nnperseg : int, optional (default=None)\n    Length of each segment for Welch's method. If None, uses n/8.\nuse_multitaper : bool, optional (default=False)\n    Whether to use multi-taper method for PSD estimation.\nn_tapers : int, optional (default=3)\n    Number of tapers for multi-taper method.\n"
      },
      "WhittleEstimator": {
        "class_name": "WhittleEstimator",
        "module_name": "analysis.spectral.whittle.whittle_estimator",
        "file_path": "analysis\\spectral\\whittle\\whittle_estimator.py",
        "constructor_params": {
          "min_freq_ratio": {
            "type": "any",
            "default": 0.01,
            "required": false
          },
          "max_freq_ratio": {
            "type": "any",
            "default": 0.1,
            "required": false
          },
          "use_local_whittle": {
            "type": "any",
            "default": true,
            "required": false
          },
          "use_welch": {
            "type": "any",
            "default": true,
            "required": false
          },
          "window": {
            "type": "any",
            "default": "hann",
            "required": false
          },
          "nperseg": {
            "type": "any",
            "default": null,
            "required": false
          }
        },
        "category": "spectral",
        "description": "\nWhittle-based Hurst parameter estimator.\n\nThis estimator uses maximum likelihood estimation in the frequency domain\nto estimate the Hurst parameter. It can use either the standard Whittle\nlikelihood or the local Whittle variant.\n\nParameters\n----------\nmin_freq_ratio : float, optional (default=0.01)\n    Minimum frequency ratio (relative to Nyquist) for fitting.\nmax_freq_ratio : float, optional (default=0.1)\n    Maximum frequency ratio (relative to Nyquist) for fitting.\nuse_local_whittle : bool, optional (default=True)\n    Whether to use local Whittle estimation (more robust).\nuse_welch : bool, optional (default=True)\n    Whether to use Welch's method for PSD estimation.\nwindow : str, optional (default='hann')\n    Window function for Welch's method.\nnperseg : int, optional (default=None)\n    Length of each segment for Welch's method. If None, uses n/8.\n"
      },
      "MFDFAEstimator": {
        "class_name": "MFDFAEstimator",
        "module_name": "analysis.multifractal.mfdfa.mfdfa_estimator",
        "file_path": "analysis\\multifractal\\mfdfa\\mfdfa_estimator.py",
        "constructor_params": {
          "q_values": {
            "type": "any",
            "default": null,
            "required": false
          },
          "scales": {
            "type": "any",
            "default": null,
            "required": false
          },
          "min_scale": {
            "type": "any",
            "default": 8,
            "required": false
          },
          "max_scale": {
            "type": "any",
            "default": 50,
            "required": false
          },
          "num_scales": {
            "type": "any",
            "default": 15,
            "required": false
          },
          "order": {
            "type": "any",
            "default": 1,
            "required": false
          }
        },
        "category": "multifractal",
        "description": "\nMultifractal Detrended Fluctuation Analysis (MFDFA) estimator.\n\nMFDFA extends DFA to analyze multifractal properties by computing\nfluctuation functions for different moments q.\n"
      },
      "MultifractalWaveletLeadersEstimator": {
        "class_name": "MultifractalWaveletLeadersEstimator",
        "module_name": "analysis.multifractal.wavelet_leaders.multifractal_wavelet_leaders_estimator",
        "file_path": "analysis\\multifractal\\wavelet_leaders\\multifractal_wavelet_leaders_estimator.py",
        "constructor_params": {
          "wavelet": {
            "type": "any",
            "default": "db4",
            "required": false
          },
          "scales": {
            "type": "any",
            "default": null,
            "required": false
          },
          "min_scale": {
            "type": "any",
            "default": 2,
            "required": false
          },
          "max_scale": {
            "type": "any",
            "default": 32,
            "required": false
          },
          "num_scales": {
            "type": "any",
            "default": 10,
            "required": false
          },
          "q_values": {
            "type": "any",
            "default": null,
            "required": false
          }
        },
        "category": "wavelet",
        "description": "\nMultifractal Wavelet Leaders estimator.\n\nThis estimator uses wavelet leaders to analyze multifractal properties\nof time series data, providing robust estimates of the multifractal spectrum.\n"
      }
    },
    "neural_components": {
      "BaseModel": {
        "class_name": "BaseModel",
        "module_name": "models.data_models.neural_fsde.base_neural_fsde",
        "file_path": "models\\data_models\\neural_fsde\\base_neural_fsde.py",
        "constructor_params": {},
        "type": "neural",
        "description": "\nAbstract base class for all stochastic models.\n\nThis class defines the interface that all stochastic models must implement,\nincluding methods for parameter validation, data generation, and model\ninformation retrieval.\n"
      },
      "BaseNeuralFSDE": {
        "class_name": "BaseNeuralFSDE",
        "module_name": "models.data_models.neural_fsde.torch_fsde_net",
        "file_path": "models\\data_models\\neural_fsde\\torch_fsde_net.py",
        "constructor_params": {
          "state_dim": {
            "type": "any",
            "default": null,
            "required": true
          },
          "hidden_dim": {
            "type": "any",
            "default": null,
            "required": true
          },
          "hurst_parameter": {
            "type": "any",
            "default": 0.7,
            "required": false
          },
          "framework": {
            "type": "any",
            "default": "auto",
            "required": false
          }
        },
        "type": "neural",
        "description": "\nBase class for neural fractional stochastic differential equations.\n\nThis class provides a unified interface for neural fSDEs implemented\nin either JAX (for high performance) or PyTorch (for compatibility).\n"
      },
      "JAXLatentFractionalNet": {
        "class_name": "JAXLatentFractionalNet",
        "module_name": "models.data_models.neural_fsde.jax_fsde_net",
        "file_path": "models\\data_models\\neural_fsde\\jax_fsde_net.py",
        "constructor_params": {
          "obs_dim": {
            "type": "any",
            "default": null,
            "required": true
          },
          "latent_dim": {
            "type": "any",
            "default": null,
            "required": true
          },
          "hidden_dim": {
            "type": "any",
            "default": null,
            "required": true
          },
          "num_layers": {
            "type": "any",
            "default": 3,
            "required": false
          },
          "hurst_parameter": {
            "type": "any",
            "default": 0.7,
            "required": false
          },
          "activation": {
            "type": "any",
            "default": "relu",
            "required": false
          },
          "key": {
            "type": "any",
            "default": null,
            "required": false
          }
        },
        "type": "neural",
        "description": "\nJAX-based Latent Fractional Net (Lf-Net) implementation.\n\nThis extends the basic fSDE-Net with latent space processing for\ncomplex temporal dependencies.\n"
      },
      "JAXfSDENet": {
        "class_name": "JAXfSDENet",
        "module_name": "models.data_models.neural_fsde.jax_fsde_net",
        "file_path": "models\\data_models\\neural_fsde\\jax_fsde_net.py",
        "constructor_params": {
          "state_dim": {
            "type": "any",
            "default": null,
            "required": true
          },
          "hidden_dim": {
            "type": "any",
            "default": null,
            "required": true
          },
          "num_layers": {
            "type": "any",
            "default": 3,
            "required": false
          },
          "hurst_parameter": {
            "type": "any",
            "default": 0.7,
            "required": false
          },
          "activation": {
            "type": "any",
            "default": "relu",
            "required": false
          },
          "key": {
            "type": "any",
            "default": null,
            "required": false
          }
        },
        "type": "neural",
        "description": "\nJAX-based neural fractional stochastic differential equation network.\n\nThis implementation leverages JAX's JIT compilation and GPU acceleration\nfor high-performance neural fSDE computation.\n"
      },
      "NeuralFSDEFactory": {
        "class_name": "NeuralFSDEFactory",
        "module_name": "models.data_models.neural_fsde.hybrid_factory",
        "file_path": "models\\data_models\\neural_fsde\\hybrid_factory.py",
        "constructor_params": {
          "preferred_framework": {
            "type": "any",
            "default": "auto",
            "required": false
          }
        },
        "type": "neural",
        "description": "\nFactory for creating neural fSDE models with automatic framework selection.\n\nThis factory automatically chooses the best available framework:\n- JAX: High performance, GPU acceleration\n- PyTorch: Compatibility, debugging, CPU/GPU support\n- Fallback: Error if neither is available\n"
      },
      "TorchLatentFractionalNet": {
        "class_name": "TorchLatentFractionalNet",
        "module_name": "models.data_models.neural_fsde.torch_fsde_net",
        "file_path": "models\\data_models\\neural_fsde\\torch_fsde_net.py",
        "constructor_params": {
          "obs_dim": {
            "type": "any",
            "default": null,
            "required": true
          },
          "latent_dim": {
            "type": "any",
            "default": null,
            "required": true
          },
          "hidden_dim": {
            "type": "any",
            "default": null,
            "required": true
          },
          "num_layers": {
            "type": "any",
            "default": 3,
            "required": false
          },
          "hurst_parameter": {
            "type": "any",
            "default": 0.7,
            "required": false
          },
          "activation": {
            "type": "any",
            "default": "relu",
            "required": false
          },
          "dropout": {
            "type": "any",
            "default": 0.0,
            "required": false
          }
        },
        "type": "neural",
        "description": "\nPyTorch-based Latent Fractional Net (Lf-Net) implementation.\n\nThis extends the basic fSDE-Net with latent space processing for\ncomplex temporal dependencies.\n"
      },
      "TorchfSDENet": {
        "class_name": "TorchfSDENet",
        "module_name": "models.data_models.neural_fsde.torch_fsde_net",
        "file_path": "models\\data_models\\neural_fsde\\torch_fsde_net.py",
        "constructor_params": {
          "state_dim": {
            "type": "any",
            "default": null,
            "required": true
          },
          "hidden_dim": {
            "type": "any",
            "default": null,
            "required": true
          },
          "num_layers": {
            "type": "any",
            "default": 3,
            "required": false
          },
          "hurst_parameter": {
            "type": "any",
            "default": 0.7,
            "required": false
          },
          "activation": {
            "type": "any",
            "default": "relu",
            "required": false
          },
          "dropout": {
            "type": "any",
            "default": 0.0,
            "required": false
          }
        },
        "type": "neural",
        "description": "\nPyTorch-based neural fractional stochastic differential equation network.\n\nThis implementation provides compatibility and debugging capabilities\nwhile maintaining the same interface as the JAX version.\n"
      }
    }
  },
  "summary": {
    "data_generators": 5,
    "estimators": 23,
    "neural_components": 7
  }
}