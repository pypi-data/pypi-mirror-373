# Copyright (C) 2020 - 2025 ANSYS, Inc. and/or its affiliates.
# SPDX-License-Identifier: MIT
#
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

"""Generation of the contexts for SCADE suite root operators."""

from pathlib import Path

from scade.code.suite.mapping.c import MappingFile
import scade.code.suite.sctoc as sctoc  # type: ignore  # CPython module defined dynamically
from scade.code.suite.wrapgen.c import InterfacePrinter
from scade.code.suite.wrapgen.model import MappingHelpers
from scade.model.project.stdproject import Configuration, Project

from ansys.scade.wux import __version__
import ansys.scade.wux.wux as wux
from ansys.scade.wux.wux import writeln


class _WuxInterfacePrinter(InterfacePrinter):
    """
    Fixes and enhancements to InterfacePrinter.

    * Simulation: Consider the simulator's contexts.
    * New services:

          * get_in_context_var
          * get_out_context_var
    """

    def __init__(self, mh, root, sep_ctx=False, indent='  ', simulation=False):
        super().__init__(mh, root, sep_ctx=sep_ctx, indent=indent)
        self.simulation = simulation

    def get_generated_path(self, var_path, subst=None):
        path = super().get_generated_path(var_path, subst=subst)
        if self.simulation:
            # TODO: code valid for standard generation only
            # (no separate_io, no global_root_context, etc.)
            elems = path.split('.')
            if len(elems) > 1:
                ctx = 'outputs_ctx' if elems[1] == 'outC' else 'inputs_ctx'
                return ctx + '.' + '.'.join(elems[2:])
            else:
                # considering no global_root_context, must be a sensor
                # and thus, strange name decorations
                return '_ctx_%s_buffer' % path
        else:
            return path

    def get_in_context_var(self):
        if self.simulation:
            ctx_acc = 'inputs_ctx'
        else:
            if self._global_root_context:
                ctx_acc = ''
            else:
                ctx_acc = (
                    '%s.%s' % (self._subst['wu_struct_var'], self._subst['inc_var'])
                    if not self._sep_ctx and self._subst['wu_struct_var']
                    else self._subst['inc_var']
                )
        return ctx_acc

    def get_out_context_var(self):
        if self.simulation:
            ctx_acc = 'outputs_ctx'
        else:
            if self._global_root_context:
                ctx_acc = ''
            else:
                ctx_acc = (
                    '%s.%s' % (self._subst['wu_struct_var'], self._subst['ctx_var'])
                    if not self._sep_ctx and self._subst['wu_struct_var']
                    else self._subst['ctx_var']
                )
        return ctx_acc


class WuxContext:
    """
    Generator service for the integration (``WUX2_CTX``).

    * Context management
    * Sensors definition
    * Periodicity
    * Call to the init, reset and cycle functions
    """

    ID = 'WUX2_CTX'
    tool = 'Context allocation for Scade root operators'
    banner = '%s (WUX %s)' % (tool, __version__)
    # prefix of genetared files
    # wuxctx instead of kcgctx: the files are not generated by KCG
    PREFIX = 'wuxctx'

    script_path = Path(__file__)
    script_dir = script_path.parent

    def __init__(self):
        # settings
        self.user_sensors = False

        # options, may be overridden by clients
        self.simulation = False

        # files
        self.sources = []

    @classmethod
    def get_service(cls):
        """Declare the generation service Context."""
        cls.instance = WuxContext()
        wux_ctx = (
            cls.ID,
            ('-OnInit', cls.instance.init),
            ('-OnGenerate', cls.instance.generate),
        )
        return wux_ctx

    def init(self, target_dir: str, project: Project, configuration: Configuration):
        """Initialize the generation service."""
        # KCG needed
        cg = ('Code Generator', ('-Order', 'Before'))
        return [cg]

    def generate(self, target_dir: str, project: Project, configuration: Configuration):
        """Generate the files."""
        print(self.banner)

        # check simulation mode
        self.set_simulation(project, configuration)

        # other settings
        self.user_sensors = project.get_bool_tool_prop_def(
            'GENERATOR', 'USER_SENSORS_DECL', False, configuration
        )

        # initialize mf, mh and ips
        self.set_globals(target_dir, project, configuration)

        basename = '%s%s' % (self.PREFIX, Path(project.pathname).name)
        pathname = Path(target_dir) / basename
        pathheader = pathname.with_suffix('.h')
        sctoc.add_generated_files(self.tool, [pathheader.name])
        with open(str(pathheader), 'w') as f:
            wux.gen_header(f, self.banner)
            wux.gen_start_protect(f, pathheader.name)
            self.gen_kcg_includes(f)
            self.gen_contexts_declaration(f, project)
            wux.gen_end_protect(f, pathheader.name)
            wux.gen_footer(f)

        pathsource = pathname.with_suffix('.c')
        sctoc.add_generated_files(self.tool, [pathsource.name])
        self.sources.append(pathsource)
        with open(str(pathsource), 'w') as f:
            wux.gen_header(f, self.banner)
            wux.gen_includes(f, [pathheader.name])
            self.gen_contexts_definition(f)
            self.gen_sensors(f)
            self.gen_init(f)
            self.gen_cycles(f)
            self.gen_period(f)
            wux.gen_footer(f)

        # build
        self.declare_target(target_dir, project, configuration)

        return True

    def set_simulation(self, project: Project, configuration: Configuration):
        """Check whether the current configuration targets the SCADE Simulator."""
        enable_extensions = project.get_bool_tool_prop_def(
            'GENERATOR', 'ENABLE_EXTENSIONS', True, configuration
        )
        target = project.get_scalar_tool_prop_def(
            'GENERATOR', 'TARGET_ADAPTOR', 'Simulator', configuration
        )
        self.simulation = enable_extensions and target == 'Simulator'

    def set_globals(self, target_dir: str, project: Project, configuration: Configuration):
        """Create the global ``wux.mf``, ``wux.mh`` and ``wux.ips`` global instances."""
        wux.mf = MappingFile((Path(target_dir) / 'mapping.xml').as_posix())
        wux.mh = MappingHelpers(wux.mf)
        roots = wux.mf.get_root_operators()
        wux.ips = []
        for index, root in enumerate(roots):
            ip = _WuxInterfacePrinter(wux.mh, root.get_scade_path(), simulation=self.simulation)
            wux.ips.append(ip)

    def gen_kcg_includes(self, f):
        """Generate the include directives."""
        writeln(f, 0, '/* KCG generated files */')
        include_sensors = True
        for ip in wux.ips:
            f.write(ip.print_includes(include_sensors))
            # do not include sensors again when there are several roots
            include_sensors = False
        writeln(f)

    def gen_contexts_declaration(self, f, project):
        """Generate the contexts declarations."""
        if self.simulation:
            # cf. <project>_interface.h
            writeln(f, 0, '/* Simulator generated files */')
            writeln(f, 0, '#include "%s_interface.h"' % Path(project.pathname).stem)
            writeln(f, 0, '')
        else:
            writeln(f, 0, '/* contexts */')
            for ip in wux.ips:
                if ip._subst['wu_struct_var']:
                    writeln(f, 0, ip.print_context_def().replace('  ', '    '))
                    writeln(
                        f,
                        0,
                        'extern {wu_struct_type} {wu_struct_var};'.format_map(
                            ip.get_substitutions()
                        ),
                    )
            writeln(f)

    def gen_contexts_definition(self, f):
        """Generate the contexts definitions."""
        writeln(f, 0, '/* contexts */')
        if not self.simulation:
            for ip in wux.ips:
                if ip._subst['wu_struct_var']:
                    writeln(
                        f, 0, '{wu_struct_type} {wu_struct_var};'.format_map(ip.get_substitutions())
                    )
        writeln(f)

    def gen_sensors(self, f):
        """Generate the sensors definitions."""
        assert wux.mf is not None  # nosec B101  # addresses linter
        sensors = wux.mf.get_all_sensors()
        if not self.simulation and not self.user_sensors and sensors:
            writeln(f, 0, '/* sensors */')
            for sensor in sensors:
                writeln(
                    f,
                    0,
                    '{0} {1};'.format(
                        sensor.get_type().get_generated().get_name(),
                        sensor.get_generated().get_name(),
                    ),
                )
        writeln(f)

    def gen_init(self, f):
        """Generate the initialization calls."""
        writeln(f, 0, '/* initializations */')
        writeln(f, 0, 'void WuxReset()')
        writeln(f, 0, '{')
        writeln(f, 0, '}')
        writeln(f)
        writeln(f, 0, 'void WuxInit()')
        writeln(f, 0, '{')
        if not self.simulation:
            sep = ''
            for ip in wux.ips:
                f.write(sep)
                init = ip.print_context_init()
                if init != '':
                    f.write(init)
                    f.write('\n')
                call = ip.print_init_call(False)
                if call != '':
                    call = (
                        '\n'.join(['    ' + line for line in call.strip('\n').split('\n')]) + '\n'
                    )
                    f.write(call.replace('    #', '#   '))
                    # f.write(call)
                sep = '\n'
        writeln(f, 0, '}')
        writeln(f)

    def gen_cycles(self, f):
        """Generate the calls to the cyclic functions."""
        writeln(f, 0, 'void WuxCycle()')
        writeln(f, 0, '{')
        if not self.simulation:
            for ip in wux.ips:
                wux.write_indent(f, '    ', ip.print_cycle_call())
        writeln(f, 0, '}')
        writeln(f)

    def gen_period(self, f):
        """Generate the access top the period."""
        writeln(f, 0, 'double WuxGetPeriod()')
        writeln(f, 0, '{')
        writeln(f, 0, '    return {0};'.format(sctoc.get_operator_sample_time()[0]))
        writeln(f, 0, '}')
        writeln(f)

    # ----------------------------------------------------------------------------
    # build
    # ----------------------------------------------------------------------------

    def declare_target(self, target_dir, project, configuration):
        """Update the makefile: sources and include search paths."""
        wux.add_sources(self.sources)
        # runtime files
        include = Path(self.script_dir).parent / 'include'
        wux.add_includes([include])


# ----------------------------------------------------------------------------
# list of services
# ----------------------------------------------------------------------------


def get_services():
    """Return the list of Generation services implemented by this module."""
    return [WuxContext.get_service()]
