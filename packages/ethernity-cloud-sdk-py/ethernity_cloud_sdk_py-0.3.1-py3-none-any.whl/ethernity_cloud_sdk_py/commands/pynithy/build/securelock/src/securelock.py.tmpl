#!/usr/bin/python

import binascii
import hashlib
import os
import io
import time
import datetime
from datetime import timedelta
import logging
import struct
import ctypes
import re
import string
import random
from cryptography import x509
from cryptography.x509.oid import NameOID
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.backends import default_backend
from cryptography.x509.extensions import UnrecognizedExtension
from etny_crypto import etny_crypto as crypto
from web3 import Web3
from eth_account import Account
from web3.middleware import geth_poa_middleware
from etny_exec import execute_task_v3, TaskStatus
from models import *
from swift_stream_service import SwiftStreamService
from eth_account.messages import defunct_hash_message
# Suppress pkg_resources warning if using web3
import warnings
warnings.filterwarnings("ignore", category=UserWarning, module="web3")
# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
class EtnySecureLock:
    def __init__(self, cert_pem: str, private_key_pem: str, swiftStreamClient: SwiftStreamService):
        self.swift_stream_service = swiftStreamClient
        self.version = 'v3'
        logging.info(f'ETNY Pynithy [{self.version}]')
        self.__set_initializers()
        self.private_key_pem = private_key_pem
        self.cert_pem = cert_pem
        self.save_pub_cert()
        self.__load_env()
        self.read_contract_abi()
        self.init_web3()
        self.print_env()
    def __set_initializers(self):
        self.is_valid_client_data = False
        self.payload = 'payload.securelock'
        self.input = 'input.securelock'
        self.result = 'result.trustedzone'
        self.result_code = 'result_code.trustedzone'
        self.result_file = '/app/result.txt'
        self.transaction_file = '/app/transaction.txt'
        self.smart_contract_address = '0x02882F03097fE8cD31afbdFbB5D72a498B41112c'
        self.image_registry_address = '0x15D73a742529C3fb11f3FA32EF7f0CC3870ACA31'
        self.chain_id = 8995
        self.web3_provider = 'https://bloxberg.ethernity.cloud'
        self.etny_bucket = "__BUCKET_NAME__"
        self.trustedzone_public_key = ''
        self.trustedzone_public_key_pem = ''
        self.trustedzone_image_hash = ''
        self.trustedzone_composer_hash = ''
    @staticmethod
    def generate_cert_from_mrenclave():
        logging.info("Generating self-signed certificate based on MR_ENCLAVE (no CAS available)")
        # Load the SGX library using ctypes
        sgx_lib_path = '/etny-securelock/get_sgx_report.so'
        if not os.path.exists(sgx_lib_path):
            raise FileNotFoundError(f"SGX library not found at {sgx_lib_path}")
        sgx_lib = ctypes.CDLL(sgx_lib_path)
        sgx_lib.get_mr_enclave.restype = ctypes.c_char_p
        sgx_lib.get_mr_signer.restype = ctypes.c_char_p

        # Get MR_ENCLAVE and MR_SIGNER from SGX
        mr_enclave_ptr = sgx_lib.get_mr_enclave()
        mr_signer_ptr = sgx_lib.get_mr_signer()

        if not mr_enclave_ptr or not mr_signer_ptr:
            raise ValueError("Failed to retrieve MR_ENCLAVE or MR_SIGNER from SGX")

        mr_enclave_hex = mr_enclave_ptr.decode('utf-8')
        mr_signer_hex = mr_signer_ptr.decode('utf-8')

        logging.info(f"MR_ENCLAVE: {mr_enclave_hex}")
        # Concatenate mr_signer and mr_enclave twice to form the seed (each is 32 bytes, so 128 bytes total)
        mr_enclave = bytes.fromhex(mr_enclave_hex)
        mr_signer = bytes.fromhex(mr_signer_hex)
        seed = mr_signer + mr_enclave + mr_signer + mr_enclave

        def generate_scalar(seed: bytes, label: bytes, order: int, bit_size: int) -> int:
            byte_size = (bit_size + 7) // 8
            counter = 0
            while True:
                base_hash = hashlib.sha256(seed + label + struct.pack('>I', counter)).digest()
                rand_bytes = b''
                hash_counter = 0
                while len(rand_bytes) < byte_size:
                    h = hashlib.sha256(base_hash + struct.pack('>I', hash_counter)).digest()
                    rand_bytes += h
                    hash_counter += 1
                rand_bytes = rand_bytes[:byte_size]
                candidate = int.from_bytes(rand_bytes, 'big')
                if 1 <= candidate < order:
                    return candidate
                counter += 1

        # Define the order for secp384r1
        order = 39402006196394479212279040100143613805079739270465446667946905279627659399113263569398956308152294913554433653942643

        # Generate deterministic EC private key
        curve = ec.SECP384R1()
        bit_size = 384
        private_value = generate_scalar(seed, b'd', order, bit_size)
        private_key = ec.derive_private_key(private_value, curve, default_backend())
        public_key = private_key.public_key()

        # Custom extension for MR_ENCLAVE
        custom_oid = x509.ObjectIdentifier("1.3.6.1.4.1.99999.1")  # Arbitrary custom OID
        mr_enclave_value = mr_enclave_hex.encode('utf-8')

        # Build certificate
        one_day = timedelta(days=1)
        builder = x509.CertificateBuilder()
        builder = builder.subject_name(x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, u"SecureLock Enclave")]))
        builder = builder.issuer_name(x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, u"SecureLock Enclave")]))
        builder = builder.not_valid_before(datetime.datetime.today() - one_day)
        builder = builder.not_valid_after(datetime.datetime.today() + (one_day * 365))
        builder = builder.serial_number(x509.random_serial_number())
        builder = builder.public_key(public_key)
        builder = builder.add_extension(
            UnrecognizedExtension(custom_oid, mr_enclave_value),
            critical=False
        )
        certificate = builder.sign(
            private_key=private_key,
            algorithm=hashes.SHA256(),
            backend=default_backend()
        )
        # Store in memory instead of writing to disk
        private_key_pem = private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        )
        cert_pem = certificate.public_bytes(encoding=serialization.Encoding.PEM)
        logging.info("Generated key and cert in memory based on MR_ENCLAVE")
        return private_key_pem, cert_pem

    @staticmethod
    def read_env_str(env_str: str):
        with io.StringIO(env_str) as f:
            for line in f:
                if '=' not in line:
                    continue
                key, value = line.split('=', 1)
                os.environ[key.strip()] = re.sub(r'\n', '', value.strip())
    def _extract_signer(self, checksum: str, signature: str) -> str:
        signer = self.w3.eth.account.recoverHash(defunct_hash_message(text=checksum), signature=signature)
        return signer.lower()
    def validate_client_payload(self):
        payload_data = self.__get_file_content_and_decrypt(self.payload)
        input_data = self.__get_file_content_and_decrypt(self.input)
        max_retries = 5
        for attempt in range(max_retries):
            try:
                self.get_do_request_metadata()
                break
            except Exception as e:
                if attempt == max_retries - 1:
                    self.task_code = TaskStatus.METADATA_FETCH_ERROR
                    self.task_result = f'Failed to fetch metadata after {max_retries} attempts: {str(e)}'
                    self.is_valid_client_data = False
                    return
        # Assume is_valid_client_data is False by default; we'll set to True only if all checks pass
        payload_valid = False
        input_valid = False

        if len(payload_data) > 0 or self._metadata.payload_metadata_obj.checksum is not None:
            try:
                payload_checksum = self.compute_sha256_checksum(payload_data)
                payload_signer = self._extract_signer(payload_checksum, self._metadata.payload_metadata_obj.checksum)
                if payload_signer == self.order_metadata.do_owner.lower():
                    payload_valid = True
                else:
                    self.task_code = TaskStatus.PAYLOAD_CHECKSUM_ERROR
                    self.task_result = 'PAYLOAD CHECKSUM DOESN\'T MATCH'
            except Exception:
                self.task_code = TaskStatus.PAYLOAD_CHECKSUM_ERROR
                self.task_result = 'PAYLOAD CHECKSUM CHECK ERROR'
        else:
                self.task_code = TaskStatus.PAYLOAD_CHECKSUM_ERROR
                self.task_result = 'PAYLOAD CHECKSUM DOESN\'T EXIST'

        if len(input_data) > 0 or self._metadata.input_metadata_obj.checksum is not None:
            try:
                input_checksum = self.compute_sha256_checksum(input_data)
                input_signer = self._extract_signer(input_checksum, self._metadata.input_metadata_obj.checksum)
                if input_signer == self.order_metadata.do_owner.lower():
                    input_valid = True
                else:
                    self.task_code = TaskStatus.INPUT_CHECKSUM_ERROR
                    self.task_result = 'INPUT CHECKSUM DOESN\'T MATCH'
            except Exception:
                self.task_code = TaskStatus.INPUT_CHECKSUM_ERROR
                self.task_result = 'INPUT CHECKSUM CHECK ERROR'
        else:
            input_valid = True

        if payload_valid and input_valid:
            self.is_valid_client_data = True
    def wait_for_payload_and_input(self):
        logging.info('Waiting for payload and input')
        self.wait_for_trustedzone(self.etny_bucket, self.payload)
        self.wait_for_trustedzone(self.etny_bucket, self.input)

    def wait_for_trustedzone(self, bucket_name: str, object_name: str, timeout: int = 3600):
        i = 0
        logging.info(f'Checking if object {object_name} exists in bucket {bucket_name}')
        while i < timeout:
            time.sleep(1)
            i += 1
            status, _ = self.swift_stream_service.is_object_in_bucket(bucket_name, object_name)
            if status:
                break
        logging.info('trusted zone finished the upload')
    def get_do_request_metadata(self):
        order = Order(self.etny.caller()._getOrder(self.order_id), self.order_id)
        self._metadata = DOReqMetadata(self.etny.caller()._getDORequestMetadata(order.do_req), order.do_req)
        self.order_metadata = order
    def compute_sha256_checksum(self, file_data: str) -> str:
        if isinstance(file_data, str):
            file_data = file_data.encode('utf-8')
        return hashlib.sha256(file_data).hexdigest()

    def print_env(self):
        logging.info(f'chain id: {self.chain_id}')
        logging.info(f'smart contract address: {self.smart_contract_address}')
        logging.info(f'web3 provider: {self.web3_provider}')
        logging.info(f'order id: {self.order_id}')
    def init_web3(self):
        self.w3 = Web3(Web3.HTTPProvider(self.web3_provider))
        self.w3.middleware_onion.inject(geth_poa_middleware, layer=0)
        self.etny = self.w3.eth.contract(address=self.smart_contract_address,
                                         abi=self.contract_abi)
        self.image_registry = self.w3.eth.contract(address=self.image_registry_address,
                                                   abi=self.image_registry_abi)
    def read_contract_abi(self):
        self.contract_abi = self.__read_contract_abi('abi/etnyImplementationV2.abi')
        self.image_registry_abi = self.__read_contract_abi('abi/imageRegistry.abi')
    def __read_contract_abi(self, contract_name: str) -> str:
        path = os.path.join(os.path.dirname(os.path.realpath(__file__)), contract_name)
        with open(path, 'r') as f:
            return f.read()
    def __load_env(self):
        if os.getenv('ETNY_CHAIN_ID'):
            self.chain_id = int(os.getenv('ETNY_CHAIN_ID'))
        if os.getenv('ETNY_SMART_CONTRACT_ADDRESS'):
            self.smart_contract_address = os.getenv('ETNY_SMART_CONTRACT_ADDRESS').rstrip()
        if os.getenv('ETNY_WEB3_PROVIDER'):
            self.web3_provider = os.getenv('ETNY_WEB3_PROVIDER').rstrip()
        self.order_id = int(os.getenv('ETNY_ORDER_ID'))

    def save_result(self):
        self.encrypt_file_and_push_to_swifstream(str(self.task_result), self.result)
        self.encrypt_file_and_push_to_swifstream(str(self.task_code), self.result_code)
    def save_pub_cert(self):
        self.swift_stream_service.create_bucket(self.etny_bucket)
        if self.cert_pem:
            data = io.BytesIO(self.cert_pem)
            self.swift_stream_service.put_file_content(self.etny_bucket,
                                                       "cert.pem",
                                                       "",
                                                       data)
    def save_transaction(self):
        self.swift_stream_service.create_bucket(self.etny_bucket)
        transaction = io.BytesIO(self.signed_tx_as_bytes)
        self.swift_stream_service.put_file_content(self.etny_bucket,
                                                   "transaction.txt",
                                                   self.transaction_file,
                                                   transaction)
    def execute(self):
        self.payload_data = self.__get_file_content_and_decrypt(self.payload)
        self.input_data = self.__get_file_content_and_decrypt(self.input)
        self.payload_signature = self.__get_file_content_and_decrypt(self.payload + ".sig")
        self.input_signature = self.__get_file_content_and_decrypt(self.input + ".sig")

        self.validate_trustedzone_data()
        task_result = execute_task_v3(self.payload_data, self.input_data)

        self.task_code = str(task_result[0])
        self.task_result = task_result[1]

    def validate_trustedzone_data(self):
        """
        Validates signatures of payload and input from trustedzone using the trustedzone public key.
        """
        # Validate payload signature

        self.__get_trustedzone_public_key()

        logging.debug(f"Trustedzone Public Key (hex): {self.trustedzone_public_key}")

        sig_der_payload = bytes.fromhex(self.payload_signature)
        logging.debug(f"Signature DER (hex): {sig_der_payload.hex()}")
        if not crypto.verify_signature(self.trustedzone_public_key, self.payload_data.encode('utf-8'), sig_der_payload):
            logging.error("Payload signature validation failed")
            raise ValueError('INVALID PAYLOAD SIGNATURE')  # Or set error state as needed

        # Validate input signature
        sig_der_input = bytes.fromhex(self.input_signature)
        if not crypto.verify_signature(self.trustedzone_public_key, self.input_data.encode('utf-8'), sig_der_input):
            logging.error("Input signature validation failed")
            raise ValueError('INVALID INPUT SIGNATURE')  # Or set error state as needed

        logging.info("Trustedzone signatures validated successfully")

    def __get_file_content_and_decrypt(self, object_name: str) -> str:
        encrypted_base64 = self.__get_file_content(object_name)

        encrypted_tuple = crypto.encrypted_data_from_base64_json(encrypted_base64.encode('utf-8'))
        decrypted_result = crypto.decrypt(self.private_key_pem, encrypted_tuple)
        return decrypted_result.decode('utf-8')

    def __get_file_content(self, object_name: str) -> str:
        status, content = self.swift_stream_service.get_file_content(self.etny_bucket, object_name)
        if not status:
            raise ValueError(f'Failed to get {object_name} file')
        return content
    def encrypt_file_and_push_to_swifstream(self, file_data: str, file_name: str):
        """
        Encrypts data with trustedzone pubkey, signs the original data with our private key,
        encrypts the signature, and uploads both to storage in separate files.
        """
        # Encrypt the data
        encrypted_input = crypto.encrypt_with_pub_key(self.trustedzone_public_key_pem, file_data.encode('utf-8'))
        encrypted_input_base64 = crypto.encrypted_data_to_base64_json(encrypted_input)
        data_file_name = file_name

        # Sign the original data
        sig_der = crypto.sign_data(self.private_key_pem, file_data.encode('utf-8'))
        sig_hex = sig_der.hex()

        # Encrypt the signature
        encrypted_sig = crypto.encrypt_with_pub_key(self.trustedzone_public_key_pem, sig_hex.encode('utf-8'))
        encrypted_sig_base64 = crypto.encrypted_data_to_base64_json(encrypted_sig)
        sig_file_name = file_name + '.sig'

        # Upload encrypted data
        self.swift_stream_service.create_bucket(self.etny_bucket)
        data_io = io.BytesIO(encrypted_input_base64)
        status, _ = self.swift_stream_service.put_file_content(self.etny_bucket, data_file_name, "", data_io)
        if status:
            logging.info(f'File {data_file_name} encrypted and saved to swift stream successfully')

        # Upload encrypted signature
        sig_io = io.BytesIO(encrypted_sig_base64)
        status_sig, _ = self.swift_stream_service.put_file_content(self.etny_bucket, sig_file_name, "", sig_io)
        if status_sig:
            logging.info(f'Signature file {sig_file_name} encrypted and saved to swift stream successfully')

    def __get_trustedzone_public_key(self):
        logging.info('Getting the public key of the trusted zone enclave')
        image_name = self._metadata.trustedzone_image_name
        self.trustedzone_image_hash, self.trustedzone_public_key_pem, self.trustedzone_composer_hash = self.image_registry.caller().getLatestTrustedZoneImageCertPublicKey(image_name, 'v3')

        # Parse PEM to extract raw public key hex (x + y coordinates, no '04' prefix)
        from cryptography.x509 import load_pem_x509_certificate
        cert = load_pem_x509_certificate(self.trustedzone_public_key_pem.encode('utf-8'), default_backend())
        pub_key = cert.public_key()
        pub_bytes = pub_key.public_bytes(
            encoding=serialization.Encoding.X962,
            format=serialization.PublicFormat.UncompressedPoint
        )[1:]  # Slice off the '04' uncompressed prefix for raw format
        self.trustedzone_public_key = pub_bytes.hex()

        logging.debug(f'Extracted trustedzone public key hex: {self.trustedzone_public_key[:20]}...')  # Log snippet for confirmation
        
if __name__ == '__main__':
    network_type = '__NETWORK_TYPE__'
    logging.info(f'[SecureLock] Initializing enclave for {network_type}')

    # Determine paths based on debug mode
    key_file = "/private/__SECURELOCK_SESSION__/key.pem"
    cert_file = "/app/__SECURELOCK_SESSION__/cert.pem"
    pub_cert_file = "/app/__SECURELOCK_SESSION__/enclave_pub_cert.pem"
    # Load if files exist, otherwise generate
    if network_type == 'mainnet' and os.path.exists(key_file) and os.path.exists(cert_file):
        logging.info("Loading key and cert from session")
        with open(key_file, 'r+b') as f:
            private_key_pem = f.read()
            f.truncate(0)
        with open(cert_file, 'rb') as f:
            cert_pem = f.read()
    elif network_type == 'testnet':
        logging.info("No existing key/cert files found")
        private_key_pem, cert_pem = EtnySecureLock.generate_cert_from_mrenclave()
    else:
        logging.error(f"Invalid encalve session or network type")
        exit(1)

    try:
        swiftStreamClient = SwiftStreamService("etny-swift-stream:9000", "swiftstreamadmin", "swiftstreamadmin")
        status, env_content = swiftStreamClient.get_file_content("__BUCKET_NAME__", ".env")
        if not status:
            logging.error("Failed to get .env file")
            raise Exception("Failed to get .env file")
        EtnySecureLock.read_env_str(env_content)

        app = EtnySecureLock(cert_pem, private_key_pem, swiftStreamClient)

        logging.info('Waiting for payload and input')
        app.wait_for_payload_and_input()

        logging.info('Validate client payload and input')
        app.validate_client_payload()
        if app.is_valid_client_data:
            logging.info('Client payload and input are valid')
        else:
            logging.error('Client payload and input are NOT valid')
            raise ValueError(app.task_result)

        app.execute()

        app.save_result()

        logging.info('Finished the execution')
    except Exception as e:
        logging.error(f"Error: {e}")
        logging.info(f"PUBLIC_CERT: {cert_pem.decode('utf-8')}")
        exit(1)