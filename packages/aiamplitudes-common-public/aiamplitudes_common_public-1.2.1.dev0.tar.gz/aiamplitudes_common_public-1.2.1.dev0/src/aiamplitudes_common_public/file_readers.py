import re,os
from aiamplitudes_common_public.download_data import _cache_path
from aiamplitudes_common_public.download_data import download_all
from fractions import Fraction

def convert(filename, loop=None, reptype=None):
    #reptype: quad, oct, ae, aef, None
    if reptype in {"oct","quad"}:
        if reptype== "oct":
            base = readSymb(filename, 'Esymboct', loop)[:-2]
            prefix = [f'BR_8_{i}' for i in range(93)]
        elif reptype == "quad":
            base = readSymb(filename, 'Esymbquad', loop)[:-2]
            prefix = [f'BR_4_{i}' for i in range(8)]
        base = re.sub(' ', '', base)
        t = re.split(":=\[|\),|\)\]", base)[1:]
        if len(t[-1]) == 0: t = t[:-1]
        s = [re.split(":=|SB\(|\)", re.sub('[, *]', '', tt)) for tt in t]
        dev = []
        for i, ss in enumerate(s):
            for j, tt in enumerate(ss[1::2]):
                s[i][1 + 2 * j] = tt+'@'+prefix[i]
            dev += s[i]
        if len(dev[-1]) == 0: dev = dev[:-1]
    else:
        dev = re.split(":=|SB\(|\)", re.sub('[,*]', '',
                                            readSymb(filename, 'Esymb', loop)))[1:-1]
    keys = dev[1::2]
    values = [int(re.sub('[+-]$', t[0] + '1', t)) for t in dev[0::2]]
    out_dict = {k:v for k, v in zip(keys, values)}

    return out_dict

def readSymb(filename, prefix, loop=None):
    #read a symbol, given a filename and prefix
    assert os.path.isfile(filename)
    assert ('indep' in prefix) or (prefix in {'Esymb', 'Eaef', 'Eae', 'Esymbquad', 'Esymboct',
                      'frontspace', 'backspace','all7_new_common_factor', 'all7_sub_set', 'all6abc_list'})
    if not (('indep' in prefix) or (prefix in {'all7_new_common_factor', 'all7_sub_set', 'all6abc_list'})):
        mypref=prefix + '[' + str(loop) + ']'
    else: mypref=prefix

    with open(filename, 'rt') as f:
        return readFile(f,mypref)

def readFile(f, prefix):
    #read from an open file
    res = ''
    reading_form = False
    for line in f:
        if not reading_form:
            if not line.startswith(prefix): continue
            res = ''
            reading_form = True
        if line.isspace(): break
        res += line[:-2] if line[-2] == '\\' else line[:-1]
        if line[-2] in [":", ";"]:
            break
    return res

def SB_to_dict(mystring):
    def to_coef(mystr):
        if mystr == '-':
            return -1
        elif mystr == '':
            return 1
        else:
            return int(mystr)

    m = mystring.replace('-', '+-').replace(",", "").split('+')
    m2 = [el.replace("(", "").replace(")", "").replace("*", "").split("SB") for el in m]
    sbdict = {elem[1]: to_coef(elem[0]) for elem in m2 if len(elem) > 1}
    return sbdict

def FBconvert(w, name):
    mystr=''.join(str.split(readSymb(filename=name, name=name, loop=w)))
    newstr=re.split(":=|\[|\]",mystr)[4]
    dev = [elem+")" if elem[-1]!=")" else elem for elem in newstr.split("),") if elem]
    return [SB_to_dict(el) for el in dev]

def read_rels_perm(mydir, weight, seam="front", reltype="oneletter"):
    # get the permissive rels pre-generated from seam_sewing_rels.py.
    # These are the checks generated by Lance & Garrett (lettbackrels and lettfrontrels).

    if not reltype in ["oneletter", "twoletter"]: return
    r = reltype

    if seam == "back":
        file = f"Bspace_rels_{r}"
        prefix = "sewrelsb"
    elif seam == "front":
        file = f"Fspace_rels_{r}"
        prefix = "sewrelsf"
    else:
        print("bad seam type!")
        raise ValueError

    assert os.path.isfile(f'{mydir}/{file}')
    with open(f'{mydir}/{file}', 'rt') as f:
        checks = readFile(f, f'{prefix}[{weight}]')
    c = [i for i in checks.split("\'")[:-1] if i != ', ' and 'sewrels' not in i]
    return c

def readcrel(crel, w=2, seam="back"):
    def cterm_to_Fp(cterm):
        if not ',' in cterm:
            print("bad term!")
            raise ValueError
        numlet = re.split(",", cterm)
        o = []
        for i in numlet:
            if i.isnumeric():
                if seam == "front":
                    o.append(f'FP_{w}_{i}@')
                elif seam == "back":
                    o.append(f'@BP_{w}_{i}')
                else:
                    raise ValueError
            else:
                o.append(i)
        return ''.join(o)

    def numstr_to_num(numstr):
        if numstr == '+':
            return 1
        elif numstr == '-':
            return -1
        elif '*' in numstr:
            numstr = numstr.replace('âˆ’', '-')
            return Fraction(numstr[:-1])
            # else:return int(numstr[:-1])

    def fractoint(frac):
        if type(frac) is int:
            return frac
        elif type(frac) is Fraction:
            return int(frac) if frac.denominator == 1 else frac

    myrel = re.split("c\[|\]", crel)[:-1]
    coefs = [elem for i, elem in enumerate(myrel) if i % 2 == 0]
    terms = [elem for i, elem in enumerate(myrel) if i % 2 == 1]
    return {cterm_to_Fp(let): fractoint(numstr_to_num(num)) for num, let in zip(coefs, terms)}

def get_relpermdict(mydir, w, seam, reltype):
    return [readcrel(i, w, seam) for i in read_rels_perm(mydir, w, seam, reltype)]
