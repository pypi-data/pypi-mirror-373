# generated by datamodel-codegen:
#   filename:  openapi.json
#   timestamp: 2025-08-22T15:32:17+00:00

from __future__ import annotations

from datetime import datetime, timedelta
from typing import Dict, List, Literal, Optional, Union
from uuid import UUID

from pydantic import BaseModel, Field, RootModel, constr


class BaseIntervention(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ...,
        description="The unique name of the object.",
        examples=["my_resource"],
        title="Name",
    )
    version: Optional[int] = Field(
        default=1, description="The version of the object.", title="Version"
    )
    description: Optional[str] = Field(
        default=None, description="A human-readable description.", title="Description"
    )
    tags: Optional[Dict[str, str]] = Field(
        default=None,
        description="A dictionary of key-value pairs to store arbitrary metadata.",
        title="Tags",
    )
    owner: Optional[str] = Field(
        default=None,
        description="The owner of the intervention, typically the email of the primary maintainer.",
        title="Owner",
    )
    is_published: Optional[bool] = Field(
        default=False,
        description="Whether this intervention has been published to the compute engines.",
        title="Is Published",
    )


class BatchSource(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ...,
        description="The unique name of the batch source.",
        examples=["warehouse_source"],
        title="Name",
    )
    timestamp_field: Optional[str] = Field(
        default=None,
        description="Event timestamp field used for point-in-time joins of attribute values.",
        title="Timestamp Field",
    )
    created_timestamp_column: Optional[str] = Field(
        default=None,
        description="Timestamp column indicating when the row was created, used for deduplicating rows.",
        title="Created Timestamp Column",
    )
    description: Optional[str] = Field(
        default=None, description="A human-readable description.", title="Description"
    )
    tags: Optional[Dict[str, str]] = Field(
        default=None,
        description="A dictionary of key-value pairs to store arbitrary metadata.",
        title="Tags",
    )
    owner: Optional[str] = Field(
        default=None,
        description="The owner of the data source, typically the email of the primary maintainer.",
        title="Owner",
    )
    date_partition_column: Optional[str] = Field(
        default=None,
        description="Timestamp column used for partitioning.",
        title="Date Partition Column",
    )
    database: str = Field(
        ..., description="Database where the attributes are stored.", title="Database"
    )
    schema_: str = Field(
        ...,
        alias="schema",
        description="Schema in which the table is located.",
        title="Schema",
    )
    table: str = Field(
        ..., description="Table where the attributes are stored.", title="Table"
    )


class DeliveryStatus(BaseModel):
    status: Literal["failure", "success", "undelivered"] = Field(..., title="Status")


class Entity(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ...,
        description="The unique name of the object.",
        examples=["my_resource"],
        title="Name",
    )
    description: Optional[str] = Field(
        default=None, description="A human-readable description.", title="Description"
    )
    key: Optional[constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128)] = (
        Field(
            default=None,
            description="The key used to join this entity to an attribute table. If not specified, the name is used.",
            examples=["domain_sessionid"],
            title="Key",
        )
    )
    tags: Optional[Dict[str, str]] = Field(
        default=None,
        description="A dictionary of key-value pairs to store arbitrary metadata.",
        title="Tags",
    )
    owner: Optional[str] = Field(
        default=None,
        description="The owner of the entity, typically the email of the primary maintainer.",
        title="Owner",
    )
    ttl: Optional[timedelta] = Field(
        default=None,
        description="The amount of time that attributes for the entity will live in the online store. If not specified both here and in the View, the ttl is not limited.",
        title="Ttl",
    )
    is_published: Optional[bool] = Field(
        default=False,
        description="Whether this entity has been published to the compute engines.",
        title="Is Published",
    )


class EntityIdentifiers(RootModel[Optional[Dict[str, List[str]]]]):
    root: Optional[Dict[str, List[str]]] = None


class EntityReference(BaseModel):
    name: str = Field(..., description="Entity name", title="Name")


class Event(BaseModel):
    name: Optional[
        constr(pattern=r"^[a-zA-Z0-9-_]+$", min_length=1, max_length=128)
    ] = Field(
        default=None,
        description="Name of the event (`event_name` column in atomic.events table).",
        examples=["page_view"],
        title="Name",
    )
    vendor: Optional[
        constr(pattern=r"^[a-zA-Z0-9-_.]+$", min_length=1, max_length=128)
    ] = Field(
        default=None,
        description="Vendor of the event (`event_vendor` column in atomic.events table).",
        examples=["com.snowplowanalytics"],
        title="Vendor",
    )
    version: Optional[constr(pattern=r"^[0-9]+-[0-9]+-[0-9]+$")] = Field(
        default=None,
        description="Version of the event (`event_version` column in atomic.events table).",
        examples=["1-0-0"],
        title="Version",
    )


class FieldModel(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ...,
        description="The name of the field.",
        examples=["purchase_amount"],
        title="Name",
    )
    description: Optional[str] = Field(
        default=None, description="A human-readable description.", title="Description"
    )
    type: Literal[
        "bytes",
        "string",
        "int32",
        "int64",
        "double",
        "float",
        "bool",
        "unix_timestamp",
        "bytes_list",
        "string_list",
        "int32_list",
        "int64_list",
        "double_list",
        "float_list",
        "bool_list",
        "unix_timestamp_list",
    ] = Field(
        ..., description="The type of the field, such as string or float.", title="Type"
    )
    tags: Optional[Dict[str, str]] = Field(
        default=None,
        description="A dictionary of key-value pairs to store arbitrary metadata.",
        title="Tags",
    )


class GetServiceAttributesRequest(BaseModel):
    entities: EntityIdentifiers
    full_attribute_names: Optional[bool] = Field(
        default=False, title="Full Attribute Names"
    )
    service: str = Field(..., title="Service")


class GetViewAttributesRequest(BaseModel):
    entities: EntityIdentifiers
    full_attribute_names: Optional[bool] = Field(
        default=False, title="Full Attribute Names"
    )
    attributes: List[str] = Field(..., title="Attributes")


class InterventionReference(BaseModel):
    name: str = Field(..., description="Intervention name", title="Name")
    version: int = Field(..., description="Intervention version", title="Version")


class LinkEntity(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ...,
        description="The unique name of the object.",
        examples=["link_name"],
        title="Name",
    )


class PublishResponse(BaseModel):
    status: Literal["published", "nothing to publish"] = Field(..., title="Status")


class PushAttributesRequest(BaseModel):
    push_source_name: str = Field(..., title="Push Source Name")
    df: Dict[str, List] = Field(..., title="Df")
    allow_registry_cache: Optional[bool] = Field(
        default=True, title="Allow Registry Cache"
    )
    to: Optional[Literal["online", "online_and_offline"]] = Field(
        default="online", title="To"
    )


class ServiceReference(BaseModel):
    name: str = Field(..., description="Service name", title="Name")


class TargetEntity(BaseModel):
    name: str = Field(
        ..., description="The name of the entity being targeted.", title="Name"
    )
    id: str = Field(
        ..., description="The identifier for this entity instance.", title="Id"
    )


class UnpublishResponse(BaseModel):
    status: Literal["unpublished", "nothing to unpublish"] = Field(..., title="Status")


class ValidationError(BaseModel):
    loc: List[Union[str, int]] = Field(..., title="Location")
    msg: str = Field(..., title="Message")
    type: str = Field(..., title="Error Type")


class VersionedLinkView(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ...,
        description="The unique name of the object.",
        examples=["link_name"],
        title="Name",
    )
    version: Optional[int] = Field(
        default=1, description="The version of the object.", title="Version"
    )


class ViewReference(BaseModel):
    name: str = Field(..., description="View name", title="Name")
    version: int = Field(..., description="View version", title="Version")


class SignalsApiModelsInterventionCriterionCriterion(BaseModel):
    attribute: constr(
        pattern=r"^[A-Za-z0-9_]{1,128}:[A-Za-z0-9_]{1,128}$",
        min_length=3,
        max_length=257,
    ) = Field(
        ...,
        description="The name of the attribute to evaluate for this criterion using operator and value. The attribute name should be qualified, including the name of the view that contains it",
        examples=["my_view:my_attribute"],
        title="Attribute",
    )
    operator: Literal[
        "=",
        "!=",
        "<",
        ">",
        "<=",
        ">=",
        "like",
        "not like",
        "rlike",
        "not rlike",
        "in",
        "not in",
        "is null",
        "is not null",
    ] = Field(
        ...,
        description="The operator used to compare the attribute to the value.",
        title="Operator",
    )
    value: Optional[
        Union[str, int, float, bool, List[str], List[int], List[float], List[bool]]
    ] = Field(
        default=None,
        description="The value to be compared using operator against the attribute value for this criterion.",
        title="Value",
    )


class SignalsApiModelsViewCriterionCriterion(BaseModel):
    property_syntax: Optional[
        Literal["blobl", "snowflake", "bigquery", "databricks"]
    ] = Field(
        default="snowflake",
        description="The syntax used to reference the property.",
        title="Property Syntax",
    )
    property: str = Field(
        ...,
        description="The path to the property on the event or entity you wish to filter.",
        title="Property",
    )
    operator: Literal["=", "!=", "<", ">", "<=", ">=", "like", "in"] = Field(
        ...,
        description="The operator used to compare the property to the value.",
        title="Operator",
    )
    value: Union[
        str, int, float, bool, List[str], List[int], List[float], List[bool]
    ] = Field(..., description="The value to compare the property to.", title="Value")


class Criteria(BaseModel):
    all: Optional[List[SignalsApiModelsViewCriterionCriterion]] = Field(
        default=None,
        description="An array of conditions used to filter the events. All conditions must be met.",
        title="All",
    )
    any: Optional[List[SignalsApiModelsViewCriterionCriterion]] = Field(
        default=None,
        description="An array of conditions used to filter the events. At least one condition must be met.",
        title="Any",
    )


class HTTPValidationError(BaseModel):
    detail: Optional[List[ValidationError]] = Field(default=None, title="Detail")


class InterventionInstance(BaseModel):
    intervention_id: Optional[UUID] = Field(default=None, title="Intervention Id")
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ...,
        description="The unique name of the intervention.",
        examples=["my_intervention"],
        title="Name",
    )
    version: int = Field(..., description="The version of the object.", title="Version")
    target_entity: Optional[TargetEntity] = Field(
        default=None,
        description="The entity instance that triggered this intervention.",
    )
    attributes: Optional[Dict[str, str]] = Field(
        default=None,
        description="Current attributes for the target_entity at the time of this intervention.",
        title="Attributes",
    )


class SelectivePublishRequest(BaseModel):
    entities: Optional[List[EntityReference]] = Field(
        default=None,
        description="List of entity references to publish",
        title="Entities",
    )
    views: Optional[List[ViewReference]] = Field(
        default=None,
        description="List of view references with explicit versions to publish",
        title="Views",
    )
    services: Optional[List[ServiceReference]] = Field(
        default=None,
        description="List of service references to publish",
        title="Services",
    )
    interventions: Optional[List[InterventionReference]] = Field(
        default=None,
        description="List of intervention references with explicit versions to publish",
        title="Interventions",
    )


class Service(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ...,
        description="The unique name of the object.",
        examples=["my_resource"],
        title="Name",
    )
    description: Optional[str] = Field(
        default=None, description="A human-readable description.", title="Description"
    )
    views: Optional[List[VersionedLinkView]] = Field(
        default=None,
        description="A list containing views, representing the features in the service.",
        max_length=100,
        min_length=1,
        title="Views",
    )
    tags: Optional[Dict[str, str]] = Field(
        default=None,
        description="A dictionary of key-value pairs to store arbitrary metadata.",
        title="Tags",
    )
    owner: Optional[str] = Field(
        default=None,
        description="The owner of the service, typically the email of the primary maintainer.",
        title="Owner",
    )
    is_published: Optional[bool] = Field(
        default=False,
        description="Whether this service has been published to the compute engines.",
        title="Is Published",
    )


class UnpublishRequest(BaseModel):
    entities: Optional[List[EntityReference]] = Field(
        default=None,
        description="List of entity references to remove from Feast",
        title="Entities",
    )
    views: Optional[List[ViewReference]] = Field(
        default=None,
        description="List of view references with explicit versions to remove from Feast",
        title="Views",
    )
    services: Optional[List[ServiceReference]] = Field(
        default=None,
        description="List of service references to remove from Feast",
        title="Services",
    )
    interventions: Optional[List[InterventionReference]] = Field(
        default=None,
        description="List of intervention references with explicit versions to remove from Feast",
        title="Interventions",
    )


class AttributeInput(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ...,
        description="The name of the field.",
        examples=["purchase_amount"],
        title="Name",
    )
    description: Optional[str] = Field(
        default=None, description="A human-readable description.", title="Description"
    )
    type: Literal[
        "bytes",
        "string",
        "int32",
        "int64",
        "double",
        "float",
        "bool",
        "unix_timestamp",
        "bytes_list",
        "string_list",
        "int32_list",
        "int64_list",
        "double_list",
        "float_list",
        "bool_list",
        "unix_timestamp_list",
    ] = Field(
        ..., description="The type of the field, such as string or float.", title="Type"
    )
    tags: Optional[Dict[str, str]] = Field(
        default=None,
        description="A dictionary of key-value pairs to store arbitrary metadata.",
        title="Tags",
    )
    events: List[Event] = Field(
        ...,
        description="An array of event schemas that the attribute should be calculated for.",
        min_length=1,
        title="Events",
    )
    aggregation: Literal[
        "counter", "sum", "min", "max", "mean", "first", "last", "unique_list"
    ] = Field(
        ..., description="The aggregation type of the attribute.", title="Aggregation"
    )
    property_syntax: Optional[
        Literal["blobl", "snowflake", "bigquery", "databricks"]
    ] = Field(
        default="snowflake",
        description="The syntax used to reference the property.",
        title="Property Syntax",
    )
    property: Optional[str] = Field(
        default=None,
        description="The path to the property on the event or entity you wish to use in the aggregation.",
        title="Property",
    )
    criteria: Optional[Criteria] = Field(
        default=None, description="An array of conditions used to filter the events."
    )
    period: Optional[timedelta] = Field(
        default=None,
        description="The time period over which the aggregation should be calculated.",
        title="Period",
    )
    default_value: Optional[
        Union[str, int, float, bool, List[Union[str, int, float, bool]]]
    ] = Field(
        default=None,
        description="The default value to use if the aggregation returns no results. If not set, the default value is automatically assigned based on the `type`.",
        title="Default Value",
    )


class AttributeOutput(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ...,
        description="The name of the field.",
        examples=["purchase_amount"],
        title="Name",
    )
    description: Optional[str] = Field(
        default=None, description="A human-readable description.", title="Description"
    )
    type: Literal[
        "bytes",
        "string",
        "int32",
        "int64",
        "double",
        "float",
        "bool",
        "unix_timestamp",
        "bytes_list",
        "string_list",
        "int32_list",
        "int64_list",
        "double_list",
        "float_list",
        "bool_list",
        "unix_timestamp_list",
    ] = Field(
        ..., description="The type of the field, such as string or float.", title="Type"
    )
    tags: Optional[Dict[str, str]] = Field(
        default=None,
        description="A dictionary of key-value pairs to store arbitrary metadata.",
        title="Tags",
    )
    events: List[Event] = Field(
        ...,
        description="An array of event schemas that the attribute should be calculated for.",
        min_length=1,
        title="Events",
    )
    aggregation: Literal[
        "counter", "sum", "min", "max", "mean", "first", "last", "unique_list"
    ] = Field(
        ..., description="The aggregation type of the attribute.", title="Aggregation"
    )
    property_syntax: Optional[
        Literal["blobl", "snowflake", "bigquery", "databricks"]
    ] = Field(
        default="snowflake",
        description="The syntax used to reference the property.",
        title="Property Syntax",
    )
    property: Optional[str] = Field(
        default=None,
        description="The path to the property on the event or entity you wish to use in the aggregation.",
        title="Property",
    )
    criteria: Optional[Criteria] = Field(
        default=None, description="An array of conditions used to filter the events."
    )
    period: Optional[timedelta] = Field(
        default=None,
        description="The time period over which the aggregation should be calculated.",
        title="Period",
    )
    default_value: Optional[
        Union[str, int, float, bool, List[Union[str, int, float, bool]]]
    ] = Field(
        default=None,
        description="The default value to use if the aggregation returns no results. If not set, the default value is automatically assigned based on the `type`.",
        title="Default Value",
    )


class ViewInput(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ...,
        description="The unique name of the object.",
        examples=["my_resource"],
        title="Name",
    )
    version: Optional[int] = Field(
        default=1, description="The version of the object.", title="Version"
    )
    entity: LinkEntity = Field(
        ..., description="The entity that this view is associated with."
    )
    ttl: Optional[timedelta] = Field(
        default=None,
        description="The amount of time this group of attributes lives. If not specified, the entity's ttl is used or the ttl is not limited.",
        title="Ttl",
    )
    batch_source: Optional[BatchSource] = Field(
        default=None,
        description="The batch source for materializing this view from the warehouse.",
    )
    online: Optional[bool] = Field(
        default=True,
        description="A boolean indicating whether online retrieval is enabled for this view.",
        title="Online",
    )
    offline: Optional[bool] = Field(
        default=None,
        description="A boolean indicating whether the attributes are pre-computed in the warehouse.",
        title="Offline",
    )
    description: Optional[str] = Field(
        default=None, description="A human-readable description.", title="Description"
    )
    tags: Optional[Dict[str, str]] = Field(
        default=None,
        description="A dictionary of key-value pairs to store arbitrary metadata.",
        title="Tags",
    )
    owner: Optional[str] = Field(
        default=None,
        description="The owner of the view, typically the email of the primary maintainer.",
        title="Owner",
    )
    fields: Optional[List[FieldModel]] = Field(
        default=None,
        description="The list of table columns that are part of this view during materialization.",
        title="Fields",
    )
    attributes: Optional[List[AttributeInput]] = Field(
        default=None,
        description="The list of attributes that will be calculated from events as part of this view.",
        title="Attributes",
    )
    is_published: Optional[bool] = Field(
        default=False,
        description="Whether this view has been published to the compute engines.",
        title="Is Published",
    )


class ViewOutput(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ...,
        description="The unique name of the object.",
        examples=["my_resource"],
        title="Name",
    )
    version: Optional[int] = Field(
        default=1, description="The version of the object.", title="Version"
    )
    entity: LinkEntity = Field(
        ..., description="The entity that this view is associated with."
    )
    ttl: Optional[timedelta] = Field(
        default=None,
        description="The amount of time this group of attributes lives. If not specified, the entity's ttl is used or the ttl is not limited.",
        title="Ttl",
    )
    batch_source: Optional[BatchSource] = Field(
        default=None,
        description="The batch source for materializing this view from the warehouse.",
    )
    online: Optional[bool] = Field(
        default=True,
        description="A boolean indicating whether online retrieval is enabled for this view.",
        title="Online",
    )
    offline: Optional[bool] = Field(
        default=None,
        description="A boolean indicating whether the attributes are pre-computed in the warehouse.",
        title="Offline",
    )
    description: Optional[str] = Field(
        default=None, description="A human-readable description.", title="Description"
    )
    tags: Optional[Dict[str, str]] = Field(
        default=None,
        description="A dictionary of key-value pairs to store arbitrary metadata.",
        title="Tags",
    )
    owner: Optional[str] = Field(
        default=None,
        description="The owner of the view, typically the email of the primary maintainer.",
        title="Owner",
    )
    fields: Optional[List[FieldModel]] = Field(
        default=None,
        description="The list of table columns that are part of this view during materialization.",
        title="Fields",
    )
    attributes: Optional[List[AttributeOutput]] = Field(
        default=None,
        description="The list of attributes that will be calculated from events as part of this view.",
        title="Attributes",
    )
    is_published: Optional[bool] = Field(
        default=False,
        description="Whether this view has been published to the compute engines.",
        title="Is Published",
    )
    feast_name: str = Field(..., title="Feast Name")
    stream_source_name: Optional[str] = Field(..., title="Stream Source Name")


class ViewResponse(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ...,
        description="The unique name of the object.",
        examples=["my_resource"],
        title="Name",
    )
    version: Optional[int] = Field(
        default=1, description="The version of the object.", title="Version"
    )
    entity: LinkEntity = Field(
        ..., description="The entity that this view is associated with."
    )
    ttl: Optional[timedelta] = Field(
        default=None,
        description="The amount of time this group of attributes lives. If not specified, the entity's ttl is used or the ttl is not limited.",
        title="Ttl",
    )
    batch_source: Optional[BatchSource] = Field(
        default=None,
        description="The batch source for materializing this view from the warehouse.",
    )
    online: Optional[bool] = Field(
        default=True,
        description="A boolean indicating whether online retrieval is enabled for this view.",
        title="Online",
    )
    offline: Optional[bool] = Field(
        default=None,
        description="A boolean indicating whether the attributes are pre-computed in the warehouse.",
        title="Offline",
    )
    description: Optional[str] = Field(
        default=None, description="A human-readable description.", title="Description"
    )
    tags: Optional[Dict[str, str]] = Field(
        default=None,
        description="A dictionary of key-value pairs to store arbitrary metadata.",
        title="Tags",
    )
    owner: Optional[str] = Field(
        default=None,
        description="The owner of the view, typically the email of the primary maintainer.",
        title="Owner",
    )
    fields: Optional[List[FieldModel]] = Field(
        default=None,
        description="The list of table columns that are part of this view during materialization.",
        title="Fields",
    )
    attributes: Optional[List[AttributeOutput]] = Field(
        default=None,
        description="The list of attributes that will be calculated from events as part of this view.",
        title="Attributes",
    )
    is_published: Optional[bool] = Field(
        default=False,
        description="Whether this view has been published to the compute engines.",
        title="Is Published",
    )
    entity_key: str = Field(
        ..., description="The key of the associated entity.", title="Entity Key"
    )
    view_or_entity_ttl: Optional[timedelta] = Field(
        default=None,
        description="The TTL of the view or entity.",
        title="View Or Entity Ttl",
    )
    feast_name: str = Field(..., title="Feast Name")
    stream_source_name: Optional[str] = Field(..., title="Stream Source Name")


class PublishedAttributesForStream(BaseModel):
    views: List[ViewResponse] = Field(..., title="Views")
    published_at: Optional[datetime] = Field(default=None, title="Published At")


class TestViewRequest(BaseModel):
    view: ViewInput = Field(..., description="View to test")
    app_ids: Optional[List[str]] = Field(
        default=None,
        description="List of app_ids to test. If empty, all app_ids will be tested",
        title="App Ids",
    )
    window: Optional[timedelta] = Field(
        default="PT1H",
        description="The time window to consider when querying the atomic events table",
        title="Window",
    )
    entity_ids: Optional[List[str]] = Field(
        default=None,
        description="List of entity IDs to test (e.g., list of domain_userid). If empty, a sample of 10 random IDs will be used",
        title="Entity Ids",
    )


class CriteriaAllInput(BaseModel):
    all: List[
        Union[
            CriteriaAllInput,
            CriteriaAnyInput,
            CriteriaNoneInput,
            SignalsApiModelsInterventionCriterionCriterion,
        ]
    ] = Field(
        ...,
        description="An array of conditions used to determine if the intervention should trigger. All conditions must be met.",
        title="All",
    )


class CriteriaAllOutput(BaseModel):
    all: List[
        Union[
            CriteriaAllOutput,
            CriteriaAnyOutput,
            CriteriaNoneOutput,
            SignalsApiModelsInterventionCriterionCriterion,
        ]
    ] = Field(
        ...,
        description="An array of conditions used to determine if the intervention should trigger. All conditions must be met.",
        title="All",
    )


class CriteriaAnyInput(BaseModel):
    any: List[
        Union[
            CriteriaAllInput,
            CriteriaAnyInput,
            CriteriaNoneInput,
            SignalsApiModelsInterventionCriterionCriterion,
        ]
    ] = Field(
        ...,
        description="An array of conditions used to determine if the intervention should trigger. At least one condition must be met.",
        title="Any",
    )


class CriteriaAnyOutput(BaseModel):
    any: List[
        Union[
            CriteriaAllOutput,
            CriteriaAnyOutput,
            CriteriaNoneOutput,
            SignalsApiModelsInterventionCriterionCriterion,
        ]
    ] = Field(
        ...,
        description="An array of conditions used to determine if the intervention should trigger. At least one condition must be met.",
        title="Any",
    )


class CriteriaNoneInput(BaseModel):
    none: List[
        Union[
            CriteriaAllInput,
            CriteriaAnyInput,
            CriteriaNoneInput,
            SignalsApiModelsInterventionCriterionCriterion,
        ]
    ] = Field(
        ...,
        description="An array of conditions used to determine if the intervention should trigger. None of the conditions may be met.",
        title="None",
    )


class CriteriaNoneOutput(BaseModel):
    none: List[
        Union[
            CriteriaAllOutput,
            CriteriaAnyOutput,
            CriteriaNoneOutput,
            SignalsApiModelsInterventionCriterionCriterion,
        ]
    ] = Field(
        ...,
        description="An array of conditions used to determine if the intervention should trigger. None of the conditions may be met.",
        title="None",
    )


class PublishedInterventionsForStream(BaseModel):
    interventions: List[Union[RuleInterventionOutput, BaseIntervention]] = Field(
        ..., title="Interventions"
    )
    published_at: Optional[datetime] = Field(default=None, title="Published At")


class RuleInterventionInput(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ...,
        description="The unique name of the object.",
        examples=["my_resource"],
        title="Name",
    )
    version: Optional[int] = Field(
        default=1, description="The version of the object.", title="Version"
    )
    description: Optional[str] = Field(
        default=None, description="A human-readable description.", title="Description"
    )
    tags: Optional[Dict[str, str]] = Field(
        default=None,
        description="A dictionary of key-value pairs to store arbitrary metadata.",
        title="Tags",
    )
    owner: Optional[str] = Field(
        default=None,
        description="The owner of the intervention, typically the email of the primary maintainer.",
        title="Owner",
    )
    is_published: Optional[bool] = Field(
        default=False,
        description="Whether this intervention has been published to the compute engines.",
        title="Is Published",
    )
    criteria: Union[
        CriteriaAllInput,
        CriteriaAnyInput,
        CriteriaNoneInput,
        SignalsApiModelsInterventionCriterionCriterion,
    ] = Field(
        ...,
        description="Rule or group of rules defining features that should be evaluated to determine if the intervention should be triggered",
        title="Criteria",
    )
    target_entities: List[LinkEntity] = Field(
        ...,
        description="The entities that should be targeted with this intervention by having their IDs extracted from the event that triggered this intervention",
        title="Target Entities",
    )


class RuleInterventionOutput(BaseModel):
    name: constr(pattern=r"^[A-Za-z0-9_]+$", min_length=1, max_length=128) = Field(
        ...,
        description="The unique name of the object.",
        examples=["my_resource"],
        title="Name",
    )
    version: Optional[int] = Field(
        default=1, description="The version of the object.", title="Version"
    )
    description: Optional[str] = Field(
        default=None, description="A human-readable description.", title="Description"
    )
    tags: Optional[Dict[str, str]] = Field(
        default=None,
        description="A dictionary of key-value pairs to store arbitrary metadata.",
        title="Tags",
    )
    owner: Optional[str] = Field(
        default=None,
        description="The owner of the intervention, typically the email of the primary maintainer.",
        title="Owner",
    )
    is_published: Optional[bool] = Field(
        default=False,
        description="Whether this intervention has been published to the compute engines.",
        title="Is Published",
    )
    criteria: Union[
        CriteriaAllOutput,
        CriteriaAnyOutput,
        CriteriaNoneOutput,
        SignalsApiModelsInterventionCriterionCriterion,
    ] = Field(
        ...,
        description="Rule or group of rules defining features that should be evaluated to determine if the intervention should be triggered",
        title="Criteria",
    )
    target_entities: List[LinkEntity] = Field(
        ...,
        description="The entities that should be targeted with this intervention by having their IDs extracted from the event that triggered this intervention",
        title="Target Entities",
    )


CriteriaAllInput.model_rebuild()
CriteriaAllOutput.model_rebuild()
CriteriaAnyInput.model_rebuild()
CriteriaAnyOutput.model_rebuild()
PublishedInterventionsForStream.model_rebuild()
