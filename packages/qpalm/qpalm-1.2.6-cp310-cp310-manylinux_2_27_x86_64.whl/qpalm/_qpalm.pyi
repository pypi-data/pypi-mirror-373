"""
C and C++ implementation of QPALM
"""
from __future__ import annotations
import numpy
import numpy.typing
import scipy.sparse
import typing
__all__: list[str] = ['Data', 'Info', 'Settings', 'Solution', 'Solver', 'build_time', 'debug']
class Data:
    A: scipy.sparse.csc_matrix
    Q: scipy.sparse.csc_matrix
    def __init__(self, n: typing.SupportsInt, m: typing.SupportsInt) -> None:
        ...
    def _get_c_data_ptr(self) -> _QPALMData:
        """
        Return a pointer to the C data struct (of type ::QPALMData).
        """
    @property
    def bmax(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, 1]"]:
        ...
    @bmax.setter
    def bmax(self, arg1: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"]) -> None:
        ...
    @property
    def bmin(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, 1]"]:
        ...
    @bmin.setter
    def bmin(self, arg1: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"]) -> None:
        ...
    @property
    def c(self) -> float:
        ...
    @c.setter
    def c(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def q(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, 1]"]:
        ...
    @q.setter
    def q(self, arg1: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"]) -> None:
        ...
class Info:
    DUAL_INFEASIBLE: typing.ClassVar[int] = -4
    DUAL_TERMINATED: typing.ClassVar[int] = 2
    ERROR: typing.ClassVar[int] = 0
    MAX_ITER_REACHED: typing.ClassVar[int] = -2
    PRIMAL_INFEASIBLE: typing.ClassVar[int] = -3
    SOLVED: typing.ClassVar[int] = 1
    TIME_LIMIT_REACHED: typing.ClassVar[int] = -5
    UNSOLVED: typing.ClassVar[int] = -10
    USER_CANCELLATION: typing.ClassVar[int] = -6
    status: str
    @property
    def dua2_res_norm(self) -> float:
        ...
    @dua2_res_norm.setter
    def dua2_res_norm(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def dua_res_norm(self) -> float:
        ...
    @dua_res_norm.setter
    def dua_res_norm(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def dual_objective(self) -> float:
        ...
    @dual_objective.setter
    def dual_objective(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def iter(self) -> int:
        ...
    @iter.setter
    def iter(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def iter_out(self) -> int:
        ...
    @iter_out.setter
    def iter_out(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def objective(self) -> float:
        ...
    @objective.setter
    def objective(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def pri_res_norm(self) -> float:
        ...
    @pri_res_norm.setter
    def pri_res_norm(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def run_time(self) -> float:
        ...
    @run_time.setter
    def run_time(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def setup_time(self) -> float:
        ...
    @setup_time.setter
    def setup_time(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def solve_time(self) -> float:
        ...
    @solve_time.setter
    def solve_time(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def status_val(self) -> int:
        ...
    @status_val.setter
    def status_val(self, arg0: typing.SupportsInt) -> None:
        ...
class Settings:
    def __init__(self) -> None:
        ...
    @property
    def delta(self) -> float:
        ...
    @delta.setter
    def delta(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def dual_objective_limit(self) -> float:
        ...
    @dual_objective_limit.setter
    def dual_objective_limit(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def enable_dual_termination(self) -> int:
        ...
    @enable_dual_termination.setter
    def enable_dual_termination(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def eps_abs(self) -> float:
        ...
    @eps_abs.setter
    def eps_abs(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def eps_abs_in(self) -> float:
        ...
    @eps_abs_in.setter
    def eps_abs_in(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def eps_dual_inf(self) -> float:
        ...
    @eps_dual_inf.setter
    def eps_dual_inf(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def eps_prim_inf(self) -> float:
        ...
    @eps_prim_inf.setter
    def eps_prim_inf(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def eps_rel(self) -> float:
        ...
    @eps_rel.setter
    def eps_rel(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def eps_rel_in(self) -> float:
        ...
    @eps_rel_in.setter
    def eps_rel_in(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def factorization_method(self) -> int:
        ...
    @factorization_method.setter
    def factorization_method(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def gamma_init(self) -> float:
        ...
    @gamma_init.setter
    def gamma_init(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def gamma_max(self) -> float:
        ...
    @gamma_max.setter
    def gamma_max(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def gamma_upd(self) -> float:
        ...
    @gamma_upd.setter
    def gamma_upd(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def inner_max_iter(self) -> int:
        ...
    @inner_max_iter.setter
    def inner_max_iter(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def max_iter(self) -> int:
        ...
    @max_iter.setter
    def max_iter(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def max_rank_update(self) -> int:
        ...
    @max_rank_update.setter
    def max_rank_update(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def max_rank_update_fraction(self) -> float:
        ...
    @max_rank_update_fraction.setter
    def max_rank_update_fraction(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def nonconvex(self) -> int:
        ...
    @nonconvex.setter
    def nonconvex(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def ordering(self) -> int:
        ...
    @ordering.setter
    def ordering(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def print_iter(self) -> int:
        ...
    @print_iter.setter
    def print_iter(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def proximal(self) -> int:
        ...
    @proximal.setter
    def proximal(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def reset_newton_iter(self) -> int:
        ...
    @reset_newton_iter.setter
    def reset_newton_iter(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def rho(self) -> float:
        ...
    @rho.setter
    def rho(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def scaling(self) -> int:
        ...
    @scaling.setter
    def scaling(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def sigma_init(self) -> float:
        ...
    @sigma_init.setter
    def sigma_init(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def sigma_max(self) -> float:
        ...
    @sigma_max.setter
    def sigma_max(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def theta(self) -> float:
        ...
    @theta.setter
    def theta(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def time_limit(self) -> float:
        ...
    @time_limit.setter
    def time_limit(self, arg0: typing.SupportsFloat) -> None:
        ...
    @property
    def verbose(self) -> int:
        ...
    @verbose.setter
    def verbose(self, arg0: typing.SupportsInt) -> None:
        ...
    @property
    def warm_start(self) -> int:
        ...
    @warm_start.setter
    def warm_start(self, arg0: typing.SupportsInt) -> None:
        ...
class Solution:
    @property
    def x(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, 1]"]:
        ...
    @property
    def y(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, 1]"]:
        ...
class Solver:
    def __init__(self, data: Data, settings: Settings) -> None:
        ...
    def _get_c_work_ptr(self) -> _QPALMWorkspace:
        """
        Return a pointer to the C workspace struct (of type ::QPALMWorkspace).
        """
    def cancel(self) -> None:
        ...
    def solve(self, asynchronous: bool = True, suppress_interrupt: bool = False) -> None:
        ...
    def update_Q_A(self, Q_vals: typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, 1]"], A_vals: typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, 1]"]) -> None:
        ...
    def update_bounds(self, bmin: typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, 1]"] | None = None, bmax: typing.Annotated[numpy.typing.ArrayLike, numpy.float64, "[m, 1]"] | None = None) -> None:
        ...
    def update_q(self, q: typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, 1]"]) -> None:
        ...
    def update_settings(self, settings: Settings) -> None:
        ...
    def warm_start(self, x: typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, 1]"] | None = None, y: typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, 1]"] | None = None) -> None:
        ...
    @property
    def dual_inf_certificate(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, 1]"]:
        ...
    @property
    def info(self) -> Info:
        ...
    @property
    def prim_inf_certificate(self) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], "[m, 1]"]:
        ...
    @property
    def solution(self) -> Solution:
        ...
class _QPALMData:
    pass
class _QPALMWorkspace:
    pass
__version__: str = '1.2.6'
build_time: str = 'Aug 30 2025 - 19:44:47'
debug: bool = False
