"""
A module to register Avro schemas to Confluent Schema Registry.
"""

import json
from collections import OrderedDict
from typing import Any, Optional

import requests
from requests import Response

from avro_preprocessor.avro_naming import AvroNaming
from avro_preprocessor.preprocessor_module import PreprocessorModule

__author__ = "Nicola Bova"
__copyright__ = "Copyright 2018, Jaumo GmbH"
__email__ = "nicola.bova@jaumo.com"


class SchemaRegistrar(PreprocessorModule):
    """
    Register schemas to Confluent Schema Registry.
    """
    schema_registry_url: str = ''
    url: str = ''
    payload: str = ''
    update_summary: Optional[OrderedDict] = None

    def process(self) -> None:
        """Process all schemas."""

        if self.schemas.paths.update_summary_path is not None:
            self.update_summary = OrderedDict()

        # If a key_schema is defined, it means we have a default common key.
        default_common_key = self.schemas.paths.key_schema

        # In that case, we process it with the schema registry.
        if default_common_key and \
                self.schemas.paths.key_subject_name_strategy == "RecordNameStrategy":
            common_key_schema = self.schemas.processed[self.schemas.paths.key_schema]
            self.perform_request_to_schema_registry(default_common_key, common_key_schema)

        current_topic = ""

        for name, schema in self.processed_schemas_iter():
            # RPC protocols cannot be registered to the schema registry
            if self.schemas.paths.is_rpc_resource(name):
                continue

            # non-base schemas are registered under their FQN
            if not name.startswith(self.schemas.paths.base_namespace):
                self.process_schema(name, schema)
                continue

            topic = AvroNaming.get_topic(self.schemas.paths.base_namespace, name, self.schemas.paths.topic_prefix)
            value_subject_name = AvroNaming.get_subject_name_for_value(
                self.schemas.paths.base_namespace, name, self.schemas.paths.topic_prefix)
            self.process_schema(value_subject_name, schema)

            if self.schemas.paths.is_event_resource(name) and topic != current_topic:
                key_subject_name = AvroNaming.get_subject_name_for_key(
                    self.schemas.paths.base_namespace,
                    AvroNaming.get_key_fully_qualified_name(name),
                    self.schemas.paths.topic_prefix)

                if default_common_key:
                    if self.schemas.paths.key_subject_name_strategy == "TopicRecordNameStrategy":
                        key_schema = self.schemas.processed[default_common_key]
                        self.process_schema(key_subject_name, key_schema)
                else:
                    key_name = AvroNaming.get_key_fully_qualified_name(name)
                    if key_name in self.schemas.autogenerated_keys:
                        key_schema = self.schemas.autogenerated_keys[key_name]
                        self.process_schema(key_subject_name, key_schema)

            current_topic = topic

        if self.schemas.paths.update_summary_path is not None:
            self.schemas.paths.update_summary_path.parent.mkdir(parents=True, exist_ok=True)
            self.schemas.paths.update_summary_path.write_text(json.dumps(self.update_summary))

    def process_schema(self, subject_name: str, schema: OrderedDict) -> None:
        if self.update_summary is None:
            self.perform_request_to_schema_registry(subject_name, schema)
            return

        current_schema_id = self.get_latest_version_schema_id(subject_name)
        new_schema_id = int(self.perform_request_to_schema_registry(subject_name, schema)['id'])
        if current_schema_id is None or current_schema_id != new_schema_id:
            self.update_summary[subject_name] = OrderedDict((
                ("previousSchemaId", current_schema_id),
                ("newSchemaId", new_schema_id)
            ))

    def perform_request_to_schema_registry(
            self, subject_name: str, schema: OrderedDict) -> Any:
        """
        Register a schema in the schema registry.
        :param subject_name: The subject name for this schema
        :param schema: The schema
        """
        self.payload = json.dumps({"schema": json.dumps(schema)})
        # print("Payload: " + self.payload)

        self.url = self.get_request_url(subject_name)

        headers = {"Content-Type": "application/vnd.schemaregistry.v1+json"}

        if self.schemas.verbose:
            print("Schema Registry URL: " + self.schema_registry_url)
            print("Subject name: " + subject_name)
            print("URL: " + self.url)
            print("Headers :", headers)

        res = requests.post(self.url, headers=headers, data=self.payload)
        return self.process_response(res)

    def get_latest_version_schema_id(self, subject_name: str) -> Optional[int]:
        url = self.get_request_url(subject_name) + "/latest"
        response = requests.get(url)
        if response.status_code == 404:
            return None
        elif response.status_code == requests.codes.ok:
            return int(json.loads(response.content)['id'])
        else:
            response.raise_for_status()
            return None

    def get_request_url(self, subject: str) -> str:
        """
        Returns the URL for this request
        :param subject: The Avro subject name
        :return: The full URL
        """
        return self.schema_registry_url + "/subjects/" + subject + "/versions"

    def process_response(self, response: Response) -> Any:
        """
        Process the response.
        :param response: The response
        """
        if response.status_code == requests.codes.ok:  # pylint: disable=E1101
            data = json.loads(response.content)
            if self.schemas.verbose:
                print('Response: Success!', data, '\n')
            return data
        else:
            print('\n\nFailure, request payload:\n', self.payload)
            print('Response: ', json.loads(response.content), '\n')
            response.raise_for_status()
