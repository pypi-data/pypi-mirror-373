"""This module provides methods for configuring the prometheus client's multiprocessing mod."""
import logging
import os

import filelock
from prometheus_client import multiprocess as prometheus_client_multiprocess
from prometheus_client import values as prometheus_client_values

from celery_control.conf import settings

logger = logging.getLogger('celery')

LOG_ERROR_PATH_IS_NOT_A_DIR = 'celery_control: %s is not a directory'
LOG_ERROR_LOCK = "celery_control: can't lock %s"


def get_worker_id(concurrency: int, name: str) -> tuple[int, filelock.AcquireReturnProxy | None]:   # noqa: WPS210
    """
    Try to acquire lock file and return corresponding worker id.

    Args:
        concurrency: The number of workers. It will be the max number of lock-files. One lock-file for each worker.
        name: Worker name.

    Returns:
        The worker id and corresponding lock acquire.
        If unsuccessful lock, the process ID will be returned instead of worker id.
    """
    worker_id: int = os.getpid()
    worker_id_lock: filelock.AcquireReturnProxy | None = None

    if not filelock.has_fcntl:                                                      # type: ignore[attr-defined]
        return worker_id, worker_id_lock

    path = settings.multiprocess_dir_locks

    if path and not os.path.isdir(path):
        logger.error(LOG_ERROR_PATH_IS_NOT_A_DIR, path)
        return worker_id, worker_id_lock

    for idx in range(0, concurrency):
        worker_id_potential = idx + 1
        worker_id_lock_file = _make_worker_id_lock_file(name, worker_id_potential, path)
        try:
            worker_id_lock = filelock.FileLock(lock_file=worker_id_lock_file).acquire(blocking=False)
        except filelock.Timeout:
            continue
        except Exception:
            logger.exception(LOG_ERROR_LOCK, worker_id_lock_file)
            break

        return worker_id_potential, worker_id_lock

    return worker_id, worker_id_lock


def make_process_identifier(worker_name: str, worker_id: int, has_lock: bool) -> str:
    """
    Make process identifier based on worker name and worker id.

    Args:
        worker_name: Worker hostname.
        worker_id: generated by get_worker_id.
        has_lock: Lock acquisition flag.

    Returns:
        If `has_lock` is true returns '{worker_name}-lock-{worker_id}'.
        Else {worker_name}-{worker_id}'
    """
    if not has_lock:
        return '{worker_name}-{worker_id}'.format(
            worker_id=worker_id,
            worker_name=worker_name,
        )
    return '{worker_name}-lock-{worker_id}'.format(
        worker_id=worker_id,
        worker_name=worker_name,
    )


def set_process_identifier(process_identifier_value: str) -> None:
    """Set process_identifier to prometheus_client_values.MultiProcessValue."""
    value_class = prometheus_client_values.MultiProcessValue(                       # type: ignore[no-untyped-call]
        process_identifier=lambda: process_identifier_value,
    )
    prometheus_client_values.ValueClass = value_class


def mark_process_identifier_as_dead(process_identifier_value: str) -> None:
    """Mark the process as dead."""
    prometheus_client_multiprocess.mark_process_dead(process_identifier_value)      # type: ignore[no-untyped-call]


def _make_worker_id_lock_file(worker_name: str, worker_id: int, path: str | None) -> str:
    worker_id_lock_file = '{worker_name}-lock-{worker_id}.lock'.format(
        worker_name=worker_name,
        worker_id=worker_id,
    )
    if path:
        worker_id_lock_file = os.path.join(path, worker_id_lock_file)

    return worker_id_lock_file
