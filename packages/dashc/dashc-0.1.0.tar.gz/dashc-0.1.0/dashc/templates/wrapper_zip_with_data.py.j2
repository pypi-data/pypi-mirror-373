import base64, io, importlib, importlib.abc, importlib.machinery, runpy, sys, zipfile, zlib


def _inflate() -> bytes:
    b64 = """{{ payload_b64 }}"""
    return zlib.decompress(base64.b64decode(b64))


def _build_map(zbytes: bytes):
    zf = zipfile.ZipFile(io.BytesIO(zbytes))
    # Map of archive path -> file bytes
    return {info.filename: zf.read(info) for info in zf.infolist() if not info.is_dir()}


class _InMemZipLoader(importlib.abc.InspectLoader, importlib.abc.ResourceReader):
    """Loader that serves modules and resources out of an in-memory ZIP map.

    Implements InspectLoader for get_source/get_code.
    Implements ResourceReader for get_data to support importlib.resources.
    """

    def __init__(self, zmap, fullname, is_pkg, arc_path):
        self._zmap = zmap
        self._fullname = fullname
        self._is_pkg = is_pkg
        self._arc_path = arc_path  # virtual filename for tracebacks

    # ---- helpers ----
    def _source_bytes(self, fullname: str) -> bytes:
        mod_path = fullname.replace(".", "/")
        if fullname == self._fullname:
            arc_path = self._arc_path
        elif self._is_pkg and fullname.startswith(self._fullname + "."):
            # submodules imported during package exec
            # delegate discovery back through meta_path, not here
            raise ImportError("Delegated to finder for submodule")
        else:
            # Not our module instance
            raise ImportError(f"Loader does not handle {fullname}")
        data = self._zmap.get(arc_path)
        if data is None:
            raise ImportError(f"No source for {fullname}")
        return data

    def _get_package_root(self) -> str:
        """Determines the directory path for the package inside the archive."""
        if self._is_pkg:
            # For a package, the path is the directory containing its __init__.py
            # e.g., for arc_path "my_pkg/__init__.py", this returns "my_pkg"
            return self._arc_path.rpartition("/")[0]
        else:
            # For a module, it is the package it belongs to
            # e.g., for fullname "my_pkg.utils", this returns "my_pkg"
            return self._fullname.rpartition(".")[0].replace(".", "/")

    # ---- importlib.abc.InspectLoader API ----
    def get_source(self, fullname: str):  # type: ignore[override]
        return self._source_bytes(fullname).decode("utf-8")

    def get_code(self, fullname: str):  # type: ignore[override]
        src = self.get_source(fullname)
        return compile(src, self._arc_path, "exec")

    # ---- importlib.abc.Loader API ----
    def create_module(self, spec):  # default module creation
        return None

    def exec_module(self, module):
        code = self.get_code(self._fullname)
        module.__file__ = self._arc_path
        module.__package__ = self._fullname if self._is_pkg else self._fullname.rpartition(".")[0]
        if self._is_pkg:
            module.__path__ = [self._fullname]
        exec(code, module.__dict__)

    # ---- NEW: importlib.abc.ResourceReader API ----
    def open_resource(self, resource: str):
        """Return a file-like object for binary reading of the resource."""
        pkg_root = self._get_package_root()
        resource_path = f"{pkg_root}/{resource}" if pkg_root else resource
        if resource_path not in self._zmap:
            raise FileNotFoundError(f"Resource \"{resource}\" not found in package \"{self._fullname}\"")
        return io.BytesIO(self._zmap[resource_path])

    def resource_path(self, resource: str):
        """Return the path to the resource. Not possible for in-memory zips."""
        raise FileNotFoundError("In-memory zip resources have no file system path")

    def is_resource(self, name: str) -> bool:
        """Return True if the named file is a resource in the package."""
        pkg_root = self._get_package_root()
        resource_path = f"{pkg_root}/{name}" if pkg_root else name
        return resource_path in self._zmap

    def get_data(self, path: str) -> bytes:
        """Return the bytes for the resource specified by path."""
        # For zip archives, "path" is the full, archive-relative path.
        # importlib.resources handles constructing this path correctly for us.
        try:
            return self._zmap[path]
        except KeyError:
            raise OSError(f"Resource not found in in-memory zip: {path}")

class _InMemZipFinder(importlib.abc.MetaPathFinder):
    def __init__(self, zmap):
        self._zmap = zmap
        pkgs = set()
        mods = set()
        for path in zmap:
            if path.endswith("/__init__.py"):
                pkgs.add(path[:-12])
            elif path.endswith(".py"):
                mods.add(path[:-3])
        self._packages = {p.replace("/", ".") for p in pkgs}
        self._modules = {m.replace("/", ".") for m in mods}

    def find_spec(self, fullname, path, target=None):
        is_pkg = fullname in self._packages
        is_mod = fullname in self._modules
        if not (is_pkg or is_mod):
            return None
        if is_pkg:
            arc_path = fullname.replace(".", "/") + "/__init__.py"
        else:
            arc_path = fullname.replace(".", "/") + ".py"
        loader = _InMemZipLoader(self._zmap, fullname, is_pkg, arc_path)
        spec = importlib.machinery.ModuleSpec(fullname, loader, is_package=is_pkg)
        spec.origin = arc_path
        if is_pkg:
            spec.submodule_search_locations = [fullname]
        return spec

def _main():
    zbytes = _inflate()
    zmap = _build_map(zbytes)
    finder = _InMemZipFinder(zmap)
    sys.meta_path.insert(0, finder)

    {% if run_module %}
    # Entrypoint Type 1: Run a module (like python -m {{ run_module }})
    # The __main__.py inside the package will be executed.
    runpy.run_module("{{ run_module }}", run_name="__main__", alter_sys=True)

    {% elif import_module and call_function %}
    # Entrypoint Type 2: Import a module and call a function
    try:
        module = importlib.import_module("{{ import_module }}")
        func = getattr(module, "{{ call_function }}")
    except (ImportError, AttributeError) as e:
        print(f"Error: Could not find entrypoint \"{{ call_function }}\" in \"{{ import_module }}\".", file=sys.stderr)
        print(f"Underlying error: {e}", file=sys.stderr)
        sys.exit(1)

    # Call the function and exit with its return code (if any)
    # This correctly handles functions that return an exit code or None.
    sys.exit(func())

    {% else %}
    # This block should not be reached if the generator logic is correct.
    print("Error: Invalid entrypoint configuration in generated script.", file=sys.stderr)
    sys.exit(1)
    {% endif %}


if __name__ == "__main__":
    _main()