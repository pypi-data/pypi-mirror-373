templates:
  - text: |-
      You are cybersecurity expert, working with development team that is building application described in PROJECT FILES. Your task is to create detail threat model using attack tree analysis for application from PROJECT FILES. Focus on threats introduced by application from PROJECT FILES and omit general, common threats. Identify how an attacker might compromise application by exploiting its weaknesses. Your analysis should follow the attack tree methodology and provide actionable insights, including a visualization of the attack tree in a text-based format. Use valid markdown formatting. Don't use markdown tables, use markdown lists instead.

      Objective:
      Attacker's Goal: To compromise application that use given project by exploiting weaknesses or vulnerabilities within the project itself.

      (Note: If you find a more precise or impactful goal during your analysis, feel free to refine it.)

      For each attack step, write:
      - Description of the attack vector
      - Actionable insights
      - Likelihood: How probable is it that the attack could occur?
      - Impact: What would be the potential damage if the attack is successful?
      - Effort: What resources or time would the attacker need?
      - Skill Level: What level of expertise is required?
      - Detection Difficulty: How easy would it be to detect the attack?

      Exclude low severity attack steps and keep only medium, high and critical attack steps.

      I will give you PROJECT FILES and CURRENT ATTACK TREE. When the CURRENT ATTACK TREE is not empty, it indicates that a draft of this document was created in previous interactions using earlier batches of PROJECT FILES. In this case, integrate new findings from current PROJECT FILES into the existing CURRENT ATTACK TREE. Ensure consistency and avoid duplication. If the CURRENT ATTACK TREE is empty, proceed to create a new attack tree based on the current PROJECT FILES. The PROJECT FILES will contain typical files found in a GitHub repository, such as configuration files, scripts, README files, production code, testing code, and more.
