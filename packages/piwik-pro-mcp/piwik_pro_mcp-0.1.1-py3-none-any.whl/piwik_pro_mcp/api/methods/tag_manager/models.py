"""
Pydantic models for Piwik PRO Tag Manager API data structures.
"""

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, ConfigDict, Field

from ..common import Meta


class TagManagerSortOrder(str, Enum):
    """Tag Manager sort order enumeration."""

    CREATED_AT = "created_at"
    CREATED_AT_DESC = "-created_at"
    UPDATED_AT = "updated_at"
    UPDATED_AT_DESC = "-updated_at"
    NAME = "name"
    NAME_DESC = "-name"


class VersionType(str, Enum):
    """Version type enumeration."""

    PUBLISHED = "published"
    DRAFT = "draft"
    HISTORIC = "historic"


class ResourceType(str, Enum):
    """Tag Manager resource type enumeration."""

    TAG = "tag"
    TRIGGER = "trigger"
    VARIABLE = "variable"
    VERSION = "version"
    DEBUG_LINK = "debug-link"
    OPERATION = "operation"
    CHANGELOG = "changelog"


class TagManagerResource(BaseModel):
    """Base Tag Manager resource model."""

    id: str = Field(..., description="Resource UUID")
    type: str = Field(..., description="Resource type")
    attributes: Dict[str, Any] = Field(..., description="Resource attributes")


class TagManagerListResponse(BaseModel):
    """Response for Tag Manager list endpoints."""

    meta: Meta
    data: List[TagManagerResource]


class TagManagerSingleResponse(BaseModel):
    """Response for single Tag Manager resource endpoints."""

    data: TagManagerResource


class TagAttributes(BaseModel):
    """
    Tag attributes for API operations.

    Note: This model includes both editable and read-only fields.
    For updates, only the editable fields will be sent to the API.
    """

    model_config = ConfigDict(populate_by_name=True, extra="allow")

    # === EDITABLE FIELDS (can be updated after creation) ===
    name: Optional[str] = Field(None, description="Tag name")
    is_active: Optional[bool] = Field(None, description="Whether tag is active")
    code: Optional[str] = Field(None, description="Tag code (HTML, script, or CSS)")
    consent_type: Optional[str] = Field(None, description="Consent type for privacy compliance")
    disable_in_debug_mode: Optional[bool] = Field(None, description="Whether tag should be disabled in debug mode")
    document_write: Optional[bool] = Field(None, description="Whether tag uses document.write method")
    priority: Optional[int] = Field(None, description="Order of firing tags (bigger number means earlier)")
    respect_visitors_privacy: Optional[bool] = Field(None, description="Whether tag respects visitor privacy settings")
    scheduler: Optional[Dict[str, Any]] = Field(None, description="Tag flight date and time definition")

    # === READ-ONLY FIELDS (auto-generated by API, included in responses only) ===
    created_at: Optional[datetime] = Field(None, alias="createdAt", description="Creation timestamp (read-only)")
    updated_at: Optional[datetime] = Field(None, alias="updatedAt", description="Last update timestamp (read-only)")
    is_published: Optional[bool] = Field(None, description="Whether tag is published (read-only)")

    # === CREATE-ONLY FIELDS (can only be set during creation, immutable after) ===
    template: Optional[str] = Field(None, description="Tag template (create-only)")
    tag_type: Optional[str] = Field(None, description="Tag execution type sync/async (create-only)")


class TriggerCondition(BaseModel):
    """Trigger condition model."""

    model_config = ConfigDict(populate_by_name=True)

    condition_id: str = Field(..., description="Condition UUID")
    variable_id: str = Field(..., description="Variable UUID")
    condition_type: str = Field(..., description="Condition type (equals, contains, etc.)")
    value: Optional[str] = Field(None, description="Condition value")
    options: Dict[str, Any] = Field(default_factory=dict, description="Condition options")


class TriggerAttributes(BaseModel):
    """Trigger attributes."""

    model_config = ConfigDict(populate_by_name=True, extra="allow")

    name: Optional[str] = Field(None, description="Trigger name")
    trigger_type: Optional[str] = Field(None, description="Trigger type (page_view, click, etc.)")
    conditions: Optional[List[TriggerCondition]] = Field(None, description="Trigger conditions")
    is_published: Optional[bool] = Field(None, description="Whether trigger is published")
    created_at: Optional[datetime] = Field(None, alias="createdAt")
    updated_at: Optional[datetime] = Field(None, alias="updatedAt")


class VariableAttributes(BaseModel):
    """Variable attributes."""

    model_config = ConfigDict(populate_by_name=True, extra="allow")

    name: Optional[str] = Field(None, description="Variable name")
    variable_type: Optional[str] = Field(None, description="Variable type (using template field for API compatibility)")
    is_active: Optional[bool] = Field(None, description="Whether variable is active")
    created_at: Optional[datetime] = Field(None, alias="createdAt")
    updated_at: Optional[datetime] = Field(None, alias="updatedAt")


class VersionAttributes(BaseModel):
    """Version attributes."""

    model_config = ConfigDict(populate_by_name=True)

    name: Optional[str] = Field(None, description="Version name")
    version_type: VersionType = Field(..., alias="versionType", description="Version type")
    created_at: Optional[datetime] = Field(None, alias="createdAt")
    updated_at: Optional[datetime] = Field(None, alias="updatedAt")
    published_at: Optional[datetime] = Field(None, alias="publishedAt")


class DebugLinkAttributes(BaseModel):
    """Debug link attributes."""

    model_config = ConfigDict(populate_by_name=True)

    name: str = Field(..., description="Debug link name")
    url: str = Field(..., description="Debug link URL")
    created_at: Optional[datetime] = Field(None, alias="createdAt")
    expires_at: Optional[datetime] = Field(None, alias="expiresAt")


class OperationAttributes(BaseModel):
    """Operation attributes."""

    model_config = ConfigDict(populate_by_name=True)

    operation_type: Optional[str] = Field(None, alias="operationType", description="Operation type")
    status: Optional[str] = Field(None, description="Operation status")
    created_at: Optional[datetime] = Field(None, alias="createdAt")
    completed_at: Optional[datetime] = Field(None, alias="completedAt")


class ConsentType(str, Enum):
    """Consent type enumeration."""

    NOT_REQUIRE_CONSENT = "not_require_consent"
    ANALYTICS = "analytics"
    AB_TESTING_AND_PERSONALIZATION = "ab_testing_and_personalization"
    CONVERSION_TRACKING = "conversion_tracking"
    MARKETING_AUTOMATION = "marketing_automation"
    REMARKETING = "remarketing"
    USER_FEEDBACK = "user_feedback"
    CUSTOM_CONSENT = "custom_consent"


class TagTemplate(str, Enum):
    """Available tag templates"""

    AB_TASTY = "ab_tasty"
    ABANDONED = "abandoned"
    ADROLL = "adroll"
    BING_ADS = "bing_ads"
    COOKIE_INFORMATION_CMP_INTEGRATION = "cookie_information_cmp_integration"
    CRAZY_EGG = "crazy_egg"
    CUSTOM_CONTENT = "custom_content"
    CUSTOM_POPUP = "custom_popup"
    CUSTOM_TAG = "custom_tag"
    DOUBLECLICK_FLOODLIGHT = "doubleclick_floodlight"
    ECOMMERCE_ADD_TO_CART = "ecommerce_add_to_cart"
    ECOMMERCE_CART_UPDATE = "ecommerce_cart_update"
    ECOMMERCE_ORDER = "ecommerce_order"
    ECOMMERCE_PRODUCT_DETAIL_VIEW = "ecommerce_product_detail_view"
    ECOMMERCE_REMOVE_FROM_CART = "ecommerce_remove_from_cart"
    FACEBOOK_RETARGETING_PIXEL = "facebook_retargeting_pixel"
    GOOGLE_ADWORDS = "google_adwords"
    GOOGLE_ANALYTICS = "google_analytics"
    HEATMAPS = "heatmaps"
    HOT_JAR = "hot_jar"
    HUB_SPOT = "hub_spot"
    LINKEDIN = "linkedin"
    MARKETO = "marketo"
    MAUTIC = "mautic"
    OPTIMIZELY = "optimizely"
    PIWIK = "piwik"
    PIWIK_CUSTOM_DIMENSION = "piwik_custom_dimension"
    PIWIK_EVENT = "piwik_event"
    PIWIK_GOAL_CONVERSION = "piwik_goal_conversion"
    PIWIK_VIRTUAL_PAGE_VIEW = "piwik_virtual_page_view"
    QUALAROO = "qualaroo"
    SALES_MANAGO = "sales_manago"
    SALESFORCE_PARDOT = "salesforce_pardot"
    VIDEO_HTML5 = "video_html5"
    VIDEO_YOUTUBE = "video_youtube"
    VISUAL_WEBSITE_OPTIMIZER = "visual_website_optimizer"


class TagFilters(BaseModel):
    """
    Tag filter model.

    Only the fields defined here are allowed. Unknown filter keys will raise a validation error.
    """

    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    name: Optional[str] = Field(None, description="Tag name")
    is_active: Optional[bool] = Field(None, description="Whether tag is active")
    template: Optional[TagTemplate] = Field(None, description="Tag template")
    consent_type: Optional[ConsentType] = Field(None, description="Consent type for privacy compliance")
    is_prioritized: Optional[bool] = Field(None, description="Whether tag is prioritized")
    has_any_triggers: Optional[bool] = Field(None, description="Whether tag has any triggers related")


class TriggerType(str, Enum):
    """Trigger type enumeration."""

    ABANDONED = "abandoned"
    CAPTURING_CLICK = "capturing_click"
    CDP_AUDIENCE_DETECTION = "cdp_audience_detection"
    CLICK = "click"
    DEBOUNCED_HISTORY = "debounced_history"
    DOM_READY = "dom_ready"
    ELEMENT_PRESENCE = "element_presence"
    EVENT = "event"
    FORM_SUBMISSION = "form_submission"
    HISTORY = "history"
    LEAVE_CONTENT = "leave_content"
    PAGE_LOAD = "page_load"
    PAGE_SCROLL = "page_scroll"
    PAGE_VIEW = "page_view"
    TIME_ON_WEBSITE = "time_on_website"


class TriggerFilters(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    name: Optional[str] = Field(None, description="Trigger name")
    trigger_type: Optional[TriggerType] = Field(None, description="Trigger type")
    has_any_condition_with_audience: Optional[bool] = Field(
        None, description="Filter triggers by having any condition with audience or not"
    )
    condition_with_audience_id: Optional[List[str]] = Field(
        None, description="Filter triggers with audience id, multi value field"
    )
    has_any_tags: Optional[bool] = Field(None, description="Whether trigger has any tags related")


class VariableType(str, Enum):
    """Variable type enumeration."""

    ABANDONED = "abandoned"
    CDP_AUDIENCE = "cdp_audience"
    CONSTANT = "constant"
    COOKIE = "cookie"
    CUSTOM_JAVASCRIPT = "custom_javascript"
    DATA_LAYER = "data_layer"
    DOCUMENT = "document"
    DOM_ELEMENT = "dom_element"
    LOOKUP_TABLE = "lookup_table"
    PIWIK_ANONYMIZATION = "piwik_anonymization"
    RANDOM = "random"
    URL = "url"


class VariableFilters(BaseModel):
    model_config = ConfigDict(populate_by_name=True, extra="forbid")

    name: Optional[str] = Field(None, description="Variable name")
    variable_type: Optional[VariableType] = Field(None, description="Variable type")
    builtin: Optional[bool] = Field(None, description="Whether variable is builtin")
