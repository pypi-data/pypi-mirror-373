#!/usr/bin/env python3
"""
SAGE Queue与Ray Actor集成测试
Test for integrating SAGE Queue with Ray Actors for high-performance inter-actor communication
"""

import os
import sys
import time
import ray
from typing import List, Dict, Any, Optional

# 添加上级目录到Python路径
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

try:
    from sage.extensions.sage_queue.python.sage_queue import SageQueue, SageQueueRef, destroy_queue
    print("✓ 成功导入 SageQueue")
except ImportError as e:
    print(f"✗ 导入失败: {e}")
    print("请先运行 ../build.sh 编译C库")
    sys.exit(1)


@ray.remote
class DataProducerActor:
    """数据生产者Actor"""
    
    def __init__(self, actor_id: str):
        self.actor_id = actor_id
        self.total_produced = 0
        print(f"DataProducerActor {actor_id} 初始化完成")
    
    def produce_data(self, queue_ref: SageQueueRef, batch_size: int, batch_count: int) -> Dict[str, Any]:
        """生产数据到队列"""
        print(f"Producer {self.actor_id}: 开始生产 {batch_count} 批数据，每批 {batch_size} 条")
        
        # 从引用获取队列实例
        queue = queue_ref.get_queue()
        
        start_time = time.time()
        total_messages = 0
        
        try:
            for batch_idx in range(batch_count):
                batch_data = []
                
                # 生成一批数据
                for i in range(batch_size):
                    message = {
                        'producer_id': self.actor_id,
                        'batch_id': batch_idx,
                        'message_id': i,
                        'timestamp': time.time(),
                        'data': {
                            'values': list(range(i, i + 10)),
                            'metadata': f"Generated by {self.actor_id}",
                            'batch_info': f"batch_{batch_idx}_msg_{i}"
                        }
                    }
                    batch_data.append(message)
                
                # 批量发送到队列
                for message in batch_data:
                    queue.put(message, timeout=5.0)
                    total_messages += 1
                
                # 进度报告
                if (batch_idx + 1) % 10 == 0 or batch_idx == batch_count - 1:
                    progress = (batch_idx + 1) / batch_count * 100
                    print(f"Producer {self.actor_id}: 进度 {progress:.1f}% ({batch_idx + 1}/{batch_count} 批次)")
                
                # 模拟处理延迟
                time.sleep(0.001)
            
            end_time = time.time()
            duration = end_time - start_time
            rate = total_messages / duration if duration > 0 else 0
            
            self.total_produced += total_messages
            
            result = {
                'actor_id': self.actor_id,
                'total_messages': total_messages,
                'duration': duration,
                'rate': rate,
                'total_produced': self.total_produced
            }
            
            print(f"✓ Producer {self.actor_id}: 完成，发送 {total_messages} 条消息，耗时 {duration:.3f}s，速率 {rate:.0f} msg/s")
            queue.close()
            return result
            
        except Exception as e:
            print(f"✗ Producer {self.actor_id} 出错: {e}")
            queue.close()
            raise


@ray.remote
class DataConsumerActor:
    """数据消费者Actor"""
    
    def __init__(self, actor_id: str):
        self.actor_id = actor_id
        self.total_consumed = 0
        print(f"DataConsumerActor {actor_id} 初始化完成")
    
    def consume_data(self, queue_ref: SageQueueRef, expected_messages: int, timeout: float = 30.0) -> Dict[str, Any]:
        """从队列消费数据"""
        print(f"Consumer {self.actor_id}: 开始消费，预期 {expected_messages} 条消息，超时 {timeout}s")
        
        # 从引用获取队列实例
        queue = queue_ref.get_queue()
        
        start_time = time.time()
        consumed_messages = []
        producer_stats = {}
        
        try:
            while len(consumed_messages) < expected_messages:
                # 检查超时
                elapsed = time.time() - start_time
                if elapsed > timeout:
                    print(f"Consumer {self.actor_id}: 超时，只消费了 {len(consumed_messages)}/{expected_messages} 条消息")
                    break
                
                try:
                    # 从队列获取消息
                    message = queue.get(timeout=1.0)
                    consumed_messages.append(message)
                    
                    # 统计生产者信息
                    producer_id = message.get('producer_id', 'unknown')
                    producer_stats[producer_id] = producer_stats.get(producer_id, 0) + 1
                    
                    # 进度报告
                    if len(consumed_messages) % 100 == 0:
                        progress = len(consumed_messages) / expected_messages * 100
                        print(f"Consumer {self.actor_id}: 进度 {progress:.1f}% ({len(consumed_messages)}/{expected_messages})")
                    
                    # 模拟数据处理
                    if len(consumed_messages) % 50 == 0:
                        time.sleep(0.001)
                
                except Exception as e:
                    if "timed out" in str(e) or "empty" in str(e).lower():
                        continue  # 继续等待
                    else:
                        raise
            
            end_time = time.time()
            duration = end_time - start_time
            rate = len(consumed_messages) / duration if duration > 0 else 0
            
            self.total_consumed += len(consumed_messages)
            
            result = {
                'actor_id': self.actor_id,
                'consumed_messages': len(consumed_messages),
                'expected_messages': expected_messages,
                'duration': duration,
                'rate': rate,
                'producer_stats': producer_stats,
                'total_consumed': self.total_consumed,
                'success_rate': len(consumed_messages) / expected_messages if expected_messages > 0 else 0
            }
            
            print(f"✓ Consumer {self.actor_id}: 完成，消费 {len(consumed_messages)} 条消息，耗时 {duration:.3f}s，速率 {rate:.0f} msg/s")
            print(f"  生产者统计: {producer_stats}")
            
            queue.close()
            return result
            
        except Exception as e:
            print(f"✗ Consumer {self.actor_id} 出错: {e}")
            queue.close()
            raise


@ray.remote
class DataProcessorActor:
    """数据处理器Actor - 既消费又生产"""
    
    def __init__(self, actor_id: str):
        self.actor_id = actor_id
        self.processed_count = 0
        print(f"DataProcessorActor {actor_id} 初始化完成")
    
    def process_data(self, input_queue_ref: SageQueueRef, output_queue_ref: SageQueueRef, 
                    expected_messages: int, timeout: float = 30.0) -> Dict[str, Any]:
        """处理数据：从输入队列读取，处理后写入输出队列"""
        print(f"Processor {self.actor_id}: 开始处理，预期 {expected_messages} 条消息")
        
        input_queue = input_queue_ref.get_queue()
        output_queue = output_queue_ref.get_queue()
        
        start_time = time.time()
        processed_messages = 0
        
        try:
            while processed_messages < expected_messages:
                # 检查超时
                elapsed = time.time() - start_time
                if elapsed > timeout:
                    print(f"Processor {self.actor_id}: 超时，只处理了 {processed_messages}/{expected_messages} 条消息")
                    break
                
                try:
                    # 从输入队列读取
                    message = input_queue.get(timeout=1.0)
                    
                    # 模拟数据处理
                    processed_message = {
                        'original': message,
                        'processor_id': self.actor_id,
                        'processed_timestamp': time.time(),
                        'processing_result': {
                            'sum': sum(message['data']['values']),
                            'avg': sum(message['data']['values']) / len(message['data']['values']),
                            'processed_by': self.actor_id
                        }
                    }
                    
                    # 写入输出队列
                    output_queue.put(processed_message, timeout=5.0)
                    processed_messages += 1
                    
                    # 进度报告
                    if processed_messages % 50 == 0:
                        progress = processed_messages / expected_messages * 100
                        print(f"Processor {self.actor_id}: 进度 {progress:.1f}% ({processed_messages}/{expected_messages})")
                    
                    # 模拟处理延迟
                    time.sleep(0.001)
                
                except Exception as e:
                    if "timed out" in str(e) or "empty" in str(e).lower():
                        continue
                    else:
                        raise
            
            end_time = time.time()
            duration = end_time - start_time
            rate = processed_messages / duration if duration > 0 else 0
            
            self.processed_count += processed_messages
            
            result = {
                'actor_id': self.actor_id,
                'processed_messages': processed_messages,
                'expected_messages': expected_messages,
                'duration': duration,
                'rate': rate,
                'total_processed': self.processed_count,
                'success_rate': processed_messages / expected_messages if expected_messages > 0 else 0
            }
            
            print(f"✓ Processor {self.actor_id}: 完成，处理 {processed_messages} 条消息，耗时 {duration:.3f}s，速率 {rate:.0f} msg/s")
            
            input_queue.close()
            output_queue.close()
            return result
            
        except Exception as e:
            print(f"✗ Processor {self.actor_id} 出错: {e}")
            input_queue.close()
            output_queue.close()
            raise


def test_simple_producer_consumer():
    """测试简单的生产者-消费者模式"""
    print("\n=== 测试Ray Actor简单生产者-消费者模式 ===")
    
    queue_name = "ray_test_simple"
    destroy_queue(queue_name)
    
    try:
        # 创建队列
        main_queue = SageQueue(queue_name)
        queue_ref = main_queue.get_reference()
        print(f"✓ 创建队列: {queue_name}")
        
        # 创建Actor
        producer = DataProducerActor.remote("producer_1")
        consumer = DataConsumerActor.remote("consumer_1")
        
        # 配置参数
        batch_size = 20
        batch_count = 10
        total_messages = batch_size * batch_count
        
        print(f"配置: {batch_count} 批次 × {batch_size} 消息 = {total_messages} 条总消息")
        
        # 启动任务
        producer_task = producer.produce_data.remote(queue_ref, batch_size, batch_count)
        consumer_task = consumer.consume_data.remote(queue_ref, total_messages, 30.0)
        
        # 等待完成
        producer_result = ray.get(producer_task)
        consumer_result = ray.get(consumer_task)
        
        # 显示结果
        print(f"\n✓ 简单模式测试完成:")
        print(f"  生产者: {producer_result}")
        print(f"  消费者: {consumer_result}")
        
        main_queue.close()
        
    except Exception as e:
        print(f"✗ 简单模式测试失败: {e}")
        import traceback
        traceback.print_exc()


def test_multiple_producers_consumers():
    """测试多生产者-多消费者模式"""
    print("\n=== 测试Ray Actor多生产者-多消费者模式 ===")
    
    queue_name = "ray_test_multiple"
    destroy_queue(queue_name)
    
    try:
        # 创建队列
        main_queue = SageQueue(queue_name, maxsize=256*1024)  # 更大的缓冲区
        queue_ref = main_queue.get_reference()
        print(f"✓ 创建队列: {queue_name}")
        
        # 配置参数
        producer_count = 3
        consumer_count = 2
        batch_size = 30
        batch_count = 15
        messages_per_producer = batch_size * batch_count
        total_messages = producer_count * messages_per_producer
        messages_per_consumer = total_messages // consumer_count
        
        print(f"配置: {producer_count} 个生产者 × {messages_per_producer} 消息 = {total_messages} 条总消息")
        print(f"      {consumer_count} 个消费者，每个预期消费 ~{messages_per_consumer} 条消息")
        
        # 创建Actor
        producers = [DataProducerActor.remote(f"producer_{i}") for i in range(producer_count)]
        consumers = [DataConsumerActor.remote(f"consumer_{i}") for i in range(consumer_count)]
        
        # 启动生产者任务
        producer_tasks = [
            producer.produce_data.remote(queue_ref, batch_size, batch_count)
            for producer in producers
        ]
        
        # 启动消费者任务
        consumer_tasks = [
            consumer.consume_data.remote(queue_ref, messages_per_consumer, 60.0)
            for consumer in consumers
        ]
        
        # 等待所有任务完成
        print("等待所有生产者完成...")
        producer_results = ray.get(producer_tasks)
        
        print("等待所有消费者完成...")
        consumer_results = ray.get(consumer_tasks)
        
        # 统计结果
        total_produced = sum(r['total_messages'] for r in producer_results)
        total_consumed = sum(r['consumed_messages'] for r in consumer_results)
        
        print(f"\n✓ 多Actor模式测试完成:")
        print(f"  总生产消息: {total_produced}")
        print(f"  总消费消息: {total_consumed}")
        print(f"  消息丢失率: {(total_produced - total_consumed) / total_produced * 100:.2f}%")
        
        for i, result in enumerate(producer_results):
            print(f"  生产者{i}: {result['rate']:.0f} msg/s")
        
        for i, result in enumerate(consumer_results):
            print(f"  消费者{i}: {result['rate']:.0f} msg/s, 成功率: {result['success_rate']:.1%}")
        
        main_queue.close()
        
    except Exception as e:
        print(f"✗ 多Actor模式测试失败: {e}")
        import traceback
        traceback.print_exc()


def test_pipeline_processing():
    """测试流水线处理模式"""
    print("\n=== 测试Ray Actor流水线处理模式 ===")
    
    input_queue_name = "ray_pipeline_input"
    output_queue_name = "ray_pipeline_output"
    destroy_queue(input_queue_name)
    destroy_queue(output_queue_name)
    
    try:
        # 创建输入和输出队列
        input_queue = SageQueue(input_queue_name, maxsize=128*1024)
        output_queue = SageQueue(output_queue_name, maxsize=128*1024)
        
        input_queue_ref = input_queue.get_reference()
        output_queue_ref = output_queue.get_reference()
        
        print(f"✓ 创建流水线队列: {input_queue_name} -> {output_queue_name}")
        
        # 配置参数
        batch_size = 25
        batch_count = 8
        total_messages = batch_size * batch_count
        processor_count = 2
        messages_per_processor = total_messages // processor_count
        
        print(f"配置: 生产 {total_messages} 条消息 -> {processor_count} 个处理器 -> 1 个最终消费者")
        
        # 创建Actor
        producer = DataProducerActor.remote("pipeline_producer")
        processors = [DataProcessorActor.remote(f"processor_{i}") for i in range(processor_count)]
        final_consumer = DataConsumerActor.remote("final_consumer")
        
        # 启动流水线
        # 阶段1: 生产数据到输入队列
        print("阶段1: 启动生产者")
        producer_task = producer.produce_data.remote(input_queue_ref, batch_size, batch_count)
        
        # 阶段2: 处理器从输入队列读取，处理后写入输出队列
        print("阶段2: 启动处理器")
        processor_tasks = [
            processor.process_data.remote(input_queue_ref, output_queue_ref, messages_per_processor, 45.0)
            for processor in processors
        ]
        
        # 阶段3: 最终消费者从输出队列读取
        print("阶段3: 启动最终消费者")
        consumer_task = final_consumer.consume_data.remote(output_queue_ref, total_messages, 60.0)
        
        # 等待所有阶段完成
        print("等待生产者完成...")
        producer_result = ray.get(producer_task)
        
        print("等待处理器完成...")
        processor_results = ray.get(processor_tasks)
        
        print("等待最终消费者完成...")
        consumer_result = ray.get(consumer_task)
        
        # 统计结果
        total_processed = sum(r['processed_messages'] for r in processor_results)
        
        print(f"\n✓ 流水线处理测试完成:")
        print(f"  生产消息: {producer_result['total_messages']}")
        print(f"  处理消息: {total_processed}")
        print(f"  最终消费: {consumer_result['consumed_messages']}")
        print(f"  端到端成功率: {consumer_result['consumed_messages'] / producer_result['total_messages']:.1%}")
        
        for i, result in enumerate(processor_results):
            print(f"  处理器{i}: {result['rate']:.0f} msg/s, 成功率: {result['success_rate']:.1%}")
        
        input_queue.close()
        output_queue.close()
        
    except Exception as e:
        print(f"✗ 流水线处理测试失败: {e}")
        import traceback
        traceback.print_exc()


def main():
    """主函数"""
    print("SAGE Queue × Ray Actor 集成测试")
    print("=" * 60)
    
    try:
        # 初始化Ray
        if not ray.is_initialized():
            ray.init()
            print("✓ Ray 初始化完成")
        
        # 运行测试
        test_simple_producer_consumer()
        test_multiple_producers_consumers()
        test_pipeline_processing()
        
        print("\n" + "=" * 60)
        print("✓ 所有Ray Actor集成测试完成!")
        
    except Exception as e:
        print(f"✗ 测试过程中出错: {e}")
        import traceback
        traceback.print_exc()
    
    finally:
        # 清理
        if ray.is_initialized():
            ray.shutdown()
            print("Ray 已关闭")
        
        # 清理测试队列
        test_queues = [
            "ray_test_simple",
            "ray_test_multiple", 
            "ray_pipeline_input",
            "ray_pipeline_output"
        ]
        
        for queue_name in test_queues:
            try:
                destroy_queue(queue_name)
            except:
                pass


if __name__ == "__main__":
    main()
