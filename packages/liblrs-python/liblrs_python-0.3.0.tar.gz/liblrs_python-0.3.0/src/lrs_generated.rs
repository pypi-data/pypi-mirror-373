// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GEOMETRY_TYPE: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GEOMETRY_TYPE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GEOMETRY_TYPE: [GeometryType; 2] = [
  GeometryType::Geographic,
  GeometryType::Schematic,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GeometryType(pub i8);
#[allow(non_upper_case_globals)]
impl GeometryType {
  pub const Geographic: Self = Self(1);
  pub const Schematic: Self = Self(2);

  pub const ENUM_MIN: i8 = 1;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Geographic,
    Self::Schematic,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Geographic => Some("Geographic"),
      Self::Schematic => Some("Schematic"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GeometryType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GeometryType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GeometryType {
    type Output = GeometryType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GeometryType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GeometryType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GeometryType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DIRECTION: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DIRECTION: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DIRECTION: [Direction; 2] = [
  Direction::Increasing,
  Direction::Decreasing,
];

/// A traversal is a path in a network.
/// Traversals may be used to model roads, railway tracks, railway lines or trips.
/// Traversals are defined as a sequence of segment and direction pairs.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Direction(pub i8);
#[allow(non_upper_case_globals)]
impl Direction {
  pub const Increasing: Self = Self(0);
  pub const Decreasing: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Increasing,
    Self::Decreasing,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Increasing => Some("Increasing"),
      Self::Decreasing => Some("Decreasing"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Direction {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Direction {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Direction {
    type Output = Direction;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Direction {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Direction {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Direction {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DISTANCE_UNIT: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DISTANCE_UNIT: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DISTANCE_UNIT: [DistanceUnit; 2] = [
  DistanceUnit::Meters,
  DistanceUnit::MilliMeters,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DistanceUnit(pub i8);
#[allow(non_upper_case_globals)]
impl DistanceUnit {
  pub const Meters: Self = Self(0);
  pub const MilliMeters: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Meters,
    Self::MilliMeters,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Meters => Some("Meters"),
      Self::MilliMeters => Some("MilliMeters"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DistanceUnit {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DistanceUnit {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DistanceUnit {
    type Output = DistanceUnit;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DistanceUnit {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DistanceUnit {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DistanceUnit {}
// struct SegmentOfTraversal, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct SegmentOfTraversal(pub [u8; 16]);
impl Default for SegmentOfTraversal { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl core::fmt::Debug for SegmentOfTraversal {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("SegmentOfTraversal")
      .field("segment_index", &self.segment_index())
      .field("direction", &self.direction())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SegmentOfTraversal {}
impl<'a> flatbuffers::Follow<'a> for SegmentOfTraversal {
  type Inner = &'a SegmentOfTraversal;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a SegmentOfTraversal>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a SegmentOfTraversal {
  type Inner = &'a SegmentOfTraversal;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<SegmentOfTraversal>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for SegmentOfTraversal {
    type Output = SegmentOfTraversal;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const SegmentOfTraversal as *const u8, <Self as flatbuffers::Push>::size());
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(8)
    }
}

impl<'a> flatbuffers::Verifiable for SegmentOfTraversal {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> SegmentOfTraversal {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    segment_index: u64,
    direction: Direction,
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_segment_index(segment_index);
    s.set_direction(direction);
    s
  }

  pub fn segment_index(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_segment_index(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn direction(&self) -> Direction {
    let mut mem = core::mem::MaybeUninit::<<Direction as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<Direction as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_direction(&mut self, x: Direction) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<Direction as EndianScalar>::Scalar>(),
      );
    }
  }

}

// struct Point, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Point(pub [u8; 16]);
impl Default for Point { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl core::fmt::Debug for Point {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Point")
      .field("x", &self.x())
      .field("y", &self.y())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Point {}
impl<'a> flatbuffers::Follow<'a> for Point {
  type Inner = &'a Point;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Point>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Point {
  type Inner = &'a Point;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Point>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Point {
    type Output = Point;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Point as *const u8, <Self as flatbuffers::Push>::size());
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(8)
    }
}

impl<'a> flatbuffers::Verifiable for Point {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Point {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    x: f64,
    y: f64,
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_x(x);
    s.set_y(y);
    s
  }

  pub fn x(&self) -> f64 {
    let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_x(&mut self, x: f64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn y(&self) -> f64 {
    let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_y(&mut self, x: f64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
    }
  }

}

pub enum PropertyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Property<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Property<'a> {
  type Inner = Property<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Property<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Property { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PropertyArgs<'args>
  ) -> flatbuffers::WIPOffset<Property<'bldr>> {
    let mut builder = PropertyBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Property::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Property) -> bool {
    self.key() < o.key()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.key();
    key.cmp(val)
  }
  #[inline]
  pub fn value(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Property::VT_VALUE, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Property<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, true)?
     .finish();
    Ok(())
  }
}
pub struct PropertyArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PropertyArgs<'a> {
  #[inline]
  fn default() -> Self {
    PropertyArgs {
      key: None, // required field
      value: None, // required field
    }
  }
}

pub struct PropertyBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PropertyBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Property::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Property::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PropertyBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PropertyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Property<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Property::VT_KEY,"key");
    self.fbb_.required(o, Property::VT_VALUE,"value");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Property<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Property");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum LrsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Lrs<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Lrs<'a> {
  type Inner = Lrs<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Lrs<'a> {
  pub const VT_PROPERTIES: flatbuffers::VOffsetT = 4;
  pub const VT_SEGMENTS: flatbuffers::VOffsetT = 6;
  pub const VT_NODES: flatbuffers::VOffsetT = 8;
  pub const VT_TRAVERSALS: flatbuffers::VOffsetT = 10;
  pub const VT_ANCHORS: flatbuffers::VOffsetT = 12;
  pub const VT_LINEAR_REFERENCING_METHODS: flatbuffers::VOffsetT = 14;
  pub const VT_GEOMETRY_TYPE: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Lrs { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LrsArgs<'args>
  ) -> flatbuffers::WIPOffset<Lrs<'bldr>> {
    let mut builder = LrsBuilder::new(_fbb);
    if let Some(x) = args.linear_referencing_methods { builder.add_linear_referencing_methods(x); }
    if let Some(x) = args.anchors { builder.add_anchors(x); }
    if let Some(x) = args.traversals { builder.add_traversals(x); }
    if let Some(x) = args.nodes { builder.add_nodes(x); }
    if let Some(x) = args.segments { builder.add_segments(x); }
    if let Some(x) = args.properties { builder.add_properties(x); }
    builder.add_geometry_type(args.geometry_type);
    builder.finish()
  }


  #[inline]
  pub fn properties(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property>>>>(Lrs::VT_PROPERTIES, None)}
  }
  /// In the network topology, segments are connected by nodes.
  #[inline]
  pub fn segments(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Segment<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Segment>>>>(Lrs::VT_SEGMENTS, None)}
  }
  /// In the network topology, a node is the end of a segment and usually the intersection of multiple segments.
  #[inline]
  pub fn nodes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node>>>>(Lrs::VT_NODES, None)}
  }
  /// Each network has traversals, which can be thought of as roads, railway lines, tracks, paths or trips.
  #[inline]
  pub fn traversals(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Traversal<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Traversal>>>>(Lrs::VT_TRAVERSALS, None)}
  }
  #[inline]
  pub fn anchors(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Anchor<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Anchor>>>>(Lrs::VT_ANCHORS, None)}
  }
  #[inline]
  pub fn linear_referencing_methods(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LinearReferencingMethod<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LinearReferencingMethod>>>>(Lrs::VT_LINEAR_REFERENCING_METHODS, None)}
  }
  /// Whether the geometry is geographic or projected.
  /// Computation of distances and length will be influenced accordingly.
  #[inline]
  pub fn geometry_type(&self) -> GeometryType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GeometryType>(Lrs::VT_GEOMETRY_TYPE, Some(GeometryType::Geographic)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Lrs<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Property>>>>("properties", Self::VT_PROPERTIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Segment>>>>("segments", Self::VT_SEGMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Node>>>>("nodes", Self::VT_NODES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Traversal>>>>("traversals", Self::VT_TRAVERSALS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Anchor>>>>("anchors", Self::VT_ANCHORS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<LinearReferencingMethod>>>>("linear_referencing_methods", Self::VT_LINEAR_REFERENCING_METHODS, false)?
     .visit_field::<GeometryType>("geometry_type", Self::VT_GEOMETRY_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct LrsArgs<'a> {
    pub properties: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>>>,
    pub segments: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Segment<'a>>>>>,
    pub nodes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Node<'a>>>>>,
    pub traversals: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Traversal<'a>>>>>,
    pub anchors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Anchor<'a>>>>>,
    pub linear_referencing_methods: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LinearReferencingMethod<'a>>>>>,
    pub geometry_type: GeometryType,
}
impl<'a> Default for LrsArgs<'a> {
  #[inline]
  fn default() -> Self {
    LrsArgs {
      properties: None,
      segments: None,
      nodes: None,
      traversals: None,
      anchors: None,
      linear_referencing_methods: None,
      geometry_type: GeometryType::Geographic,
    }
  }
}

pub struct LrsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LrsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_properties(&mut self, properties: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Property<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Lrs::VT_PROPERTIES, properties);
  }
  #[inline]
  pub fn add_segments(&mut self, segments: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Segment<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Lrs::VT_SEGMENTS, segments);
  }
  #[inline]
  pub fn add_nodes(&mut self, nodes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Node<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Lrs::VT_NODES, nodes);
  }
  #[inline]
  pub fn add_traversals(&mut self, traversals: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Traversal<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Lrs::VT_TRAVERSALS, traversals);
  }
  #[inline]
  pub fn add_anchors(&mut self, anchors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Anchor<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Lrs::VT_ANCHORS, anchors);
  }
  #[inline]
  pub fn add_linear_referencing_methods(&mut self, linear_referencing_methods: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<LinearReferencingMethod<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Lrs::VT_LINEAR_REFERENCING_METHODS, linear_referencing_methods);
  }
  #[inline]
  pub fn add_geometry_type(&mut self, geometry_type: GeometryType) {
    self.fbb_.push_slot::<GeometryType>(Lrs::VT_GEOMETRY_TYPE, geometry_type, GeometryType::Geographic);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LrsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LrsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Lrs<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Lrs<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Lrs");
      ds.field("properties", &self.properties());
      ds.field("segments", &self.segments());
      ds.field("nodes", &self.nodes());
      ds.field("traversals", &self.traversals());
      ds.field("anchors", &self.anchors());
      ds.field("linear_referencing_methods", &self.linear_referencing_methods());
      ds.field("geometry_type", &self.geometry_type());
      ds.finish()
  }
}
pub enum SegmentOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A continuous link between two network nodes. Segments can be located in space.
/// It could be a section of roads between intersections, a piece of railway tracks without switches, a continuous piece of sewer pipe.
/// Segments are directed: one of its ends is its begining, and the other one its end.
pub struct Segment<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Segment<'a> {
  type Inner = Segment<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Segment<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_PROPERTIES: flatbuffers::VOffsetT = 6;
  pub const VT_GEOMETRY: flatbuffers::VOffsetT = 8;
  pub const VT_START_NODE_INDEX: flatbuffers::VOffsetT = 10;
  pub const VT_END_NODE_INDEX: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Segment { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SegmentArgs<'args>
  ) -> flatbuffers::WIPOffset<Segment<'bldr>> {
    let mut builder = SegmentBuilder::new(_fbb);
    builder.add_end_node_index(args.end_node_index);
    builder.add_start_node_index(args.start_node_index);
    if let Some(x) = args.geometry { builder.add_geometry(x); }
    if let Some(x) = args.properties { builder.add_properties(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Segment::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn properties(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property>>>>(Segment::VT_PROPERTIES, None)}
  }
  #[inline]
  pub fn geometry(&self) -> flatbuffers::Vector<'a, Point> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Point>>>(Segment::VT_GEOMETRY, None).unwrap()}
  }
  #[inline]
  pub fn start_node_index(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Segment::VT_START_NODE_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn end_node_index(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Segment::VT_END_NODE_INDEX, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Segment<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Property>>>>("properties", Self::VT_PROPERTIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Point>>>("geometry", Self::VT_GEOMETRY, true)?
     .visit_field::<u64>("start_node_index", Self::VT_START_NODE_INDEX, false)?
     .visit_field::<u64>("end_node_index", Self::VT_END_NODE_INDEX, false)?
     .finish();
    Ok(())
  }
}
pub struct SegmentArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub properties: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>>>,
    pub geometry: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Point>>>,
    pub start_node_index: u64,
    pub end_node_index: u64,
}
impl<'a> Default for SegmentArgs<'a> {
  #[inline]
  fn default() -> Self {
    SegmentArgs {
      id: None, // required field
      properties: None,
      geometry: None, // required field
      start_node_index: 0,
      end_node_index: 0,
    }
  }
}

pub struct SegmentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SegmentBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Segment::VT_ID, id);
  }
  #[inline]
  pub fn add_properties(&mut self, properties: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Property<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Segment::VT_PROPERTIES, properties);
  }
  #[inline]
  pub fn add_geometry(&mut self, geometry: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Point>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Segment::VT_GEOMETRY, geometry);
  }
  #[inline]
  pub fn add_start_node_index(&mut self, start_node_index: u64) {
    self.fbb_.push_slot::<u64>(Segment::VT_START_NODE_INDEX, start_node_index, 0);
  }
  #[inline]
  pub fn add_end_node_index(&mut self, end_node_index: u64) {
    self.fbb_.push_slot::<u64>(Segment::VT_END_NODE_INDEX, end_node_index, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SegmentBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SegmentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Segment<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Segment::VT_ID,"id");
    self.fbb_.required(o, Segment::VT_GEOMETRY,"geometry");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Segment<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Segment");
      ds.field("id", &self.id());
      ds.field("properties", &self.properties());
      ds.field("geometry", &self.geometry());
      ds.field("start_node_index", &self.start_node_index());
      ds.field("end_node_index", &self.end_node_index());
      ds.finish()
  }
}
pub enum NodeOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Nodes are connections between segment endpoints.
/// A node can have a single connection (at the end of a dead end), or multiple segment connections (at an intersection).
/// Nodes can be used to model point of interest in a network, such as road intersections, railway switches, the end of a dead ends.
pub struct Node<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Node<'a> {
  type Inner = Node<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Node<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_PROPERTIES: flatbuffers::VOffsetT = 6;
  pub const VT_GEOMETRY: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Node { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args NodeArgs<'args>
  ) -> flatbuffers::WIPOffset<Node<'bldr>> {
    let mut builder = NodeBuilder::new(_fbb);
    if let Some(x) = args.geometry { builder.add_geometry(x); }
    if let Some(x) = args.properties { builder.add_properties(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Node::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn properties(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property>>>>(Node::VT_PROPERTIES, None)}
  }
  #[inline]
  pub fn geometry(&self) -> Option<&'a Point> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Point>(Node::VT_GEOMETRY, None)}
  }
}

impl flatbuffers::Verifiable for Node<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Property>>>>("properties", Self::VT_PROPERTIES, false)?
     .visit_field::<Point>("geometry", Self::VT_GEOMETRY, false)?
     .finish();
    Ok(())
  }
}
pub struct NodeArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub properties: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>>>,
    pub geometry: Option<&'a Point>,
}
impl<'a> Default for NodeArgs<'a> {
  #[inline]
  fn default() -> Self {
    NodeArgs {
      id: None, // required field
      properties: None,
      geometry: None,
    }
  }
}

pub struct NodeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NodeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Node::VT_ID, id);
  }
  #[inline]
  pub fn add_properties(&mut self, properties: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Property<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Node::VT_PROPERTIES, properties);
  }
  #[inline]
  pub fn add_geometry(&mut self, geometry: &Point) {
    self.fbb_.push_slot_always::<&Point>(Node::VT_GEOMETRY, geometry);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> NodeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    NodeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Node<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Node::VT_ID,"id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Node<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Node");
      ds.field("id", &self.id());
      ds.field("properties", &self.properties());
      ds.field("geometry", &self.geometry());
      ds.finish()
  }
}
pub enum TraversalOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Traversal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Traversal<'a> {
  type Inner = Traversal<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Traversal<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_PROPERTIES: flatbuffers::VOffsetT = 6;
  pub const VT_SEGMENTS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Traversal { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TraversalArgs<'args>
  ) -> flatbuffers::WIPOffset<Traversal<'bldr>> {
    let mut builder = TraversalBuilder::new(_fbb);
    if let Some(x) = args.segments { builder.add_segments(x); }
    if let Some(x) = args.properties { builder.add_properties(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Traversal::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn properties(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property>>>>(Traversal::VT_PROPERTIES, None)}
  }
  #[inline]
  pub fn segments(&self) -> flatbuffers::Vector<'a, SegmentOfTraversal> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, SegmentOfTraversal>>>(Traversal::VT_SEGMENTS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Traversal<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Property>>>>("properties", Self::VT_PROPERTIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, SegmentOfTraversal>>>("segments", Self::VT_SEGMENTS, true)?
     .finish();
    Ok(())
  }
}
pub struct TraversalArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub properties: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>>>,
    pub segments: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, SegmentOfTraversal>>>,
}
impl<'a> Default for TraversalArgs<'a> {
  #[inline]
  fn default() -> Self {
    TraversalArgs {
      id: None, // required field
      properties: None,
      segments: None, // required field
    }
  }
}

pub struct TraversalBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TraversalBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Traversal::VT_ID, id);
  }
  #[inline]
  pub fn add_properties(&mut self, properties: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Property<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Traversal::VT_PROPERTIES, properties);
  }
  #[inline]
  pub fn add_segments(&mut self, segments: flatbuffers::WIPOffset<flatbuffers::Vector<'b , SegmentOfTraversal>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Traversal::VT_SEGMENTS, segments);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TraversalBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TraversalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Traversal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Traversal::VT_ID,"id");
    self.fbb_.required(o, Traversal::VT_SEGMENTS,"segments");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Traversal<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Traversal");
      ds.field("id", &self.id());
      ds.field("properties", &self.properties());
      ds.field("segments", &self.segments());
      ds.finish()
  }
}
pub enum AnchorOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Anchors are reference locations, used for positioning within a Linear Referencing Method.
/// There are two types of anchors:
///   * most anchors are standalone reference locations, such as milestones or kilometer markers
///   * some anchors are associated with a network node. The location of the anchor is deduced from the location of the node.
pub struct Anchor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Anchor<'a> {
  type Inner = Anchor<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Anchor<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_PROPERTIES: flatbuffers::VOffsetT = 6;
  pub const VT_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_NODE: flatbuffers::VOffsetT = 10;
  pub const VT_GEOMETRY: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Anchor { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AnchorArgs<'args>
  ) -> flatbuffers::WIPOffset<Anchor<'bldr>> {
    let mut builder = AnchorBuilder::new(_fbb);
    if let Some(x) = args.geometry { builder.add_geometry(x); }
    builder.add_node(args.node);
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.properties { builder.add_properties(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Anchor::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn properties(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property>>>>(Anchor::VT_PROPERTIES, None)}
  }
  /// Most anchors have a name, which is used to reference the location.
  /// It can often be a kilometer or mile number, but it can also be a letter or word.
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Anchor::VT_NAME, None)}
  }
  /// Anchors can be bound to a node, or defined independently.
  /// If the anchor is bound to a node, its location is deduced from location of the node.
  #[inline]
  pub fn node(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Anchor::VT_NODE, Some(0)).unwrap()}
  }
  /// The anchor can also be defined by a geographical position.
  #[inline]
  pub fn geometry(&self) -> Option<&'a Point> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Point>(Anchor::VT_GEOMETRY, None)}
  }
}

impl flatbuffers::Verifiable for Anchor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Property>>>>("properties", Self::VT_PROPERTIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<u32>("node", Self::VT_NODE, false)?
     .visit_field::<Point>("geometry", Self::VT_GEOMETRY, false)?
     .finish();
    Ok(())
  }
}
pub struct AnchorArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub properties: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub node: u32,
    pub geometry: Option<&'a Point>,
}
impl<'a> Default for AnchorArgs<'a> {
  #[inline]
  fn default() -> Self {
    AnchorArgs {
      id: None, // required field
      properties: None,
      name: None,
      node: 0,
      geometry: None,
    }
  }
}

pub struct AnchorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AnchorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Anchor::VT_ID, id);
  }
  #[inline]
  pub fn add_properties(&mut self, properties: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Property<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Anchor::VT_PROPERTIES, properties);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Anchor::VT_NAME, name);
  }
  #[inline]
  pub fn add_node(&mut self, node: u32) {
    self.fbb_.push_slot::<u32>(Anchor::VT_NODE, node, 0);
  }
  #[inline]
  pub fn add_geometry(&mut self, geometry: &Point) {
    self.fbb_.push_slot_always::<&Point>(Anchor::VT_GEOMETRY, geometry);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AnchorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AnchorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Anchor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Anchor::VT_ID,"id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Anchor<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Anchor");
      ds.field("id", &self.id());
      ds.field("properties", &self.properties());
      ds.field("name", &self.name());
      ds.field("node", &self.node());
      ds.field("geometry", &self.geometry());
      ds.finish()
  }
}
pub enum ProjectedAnchorOffset {}
#[derive(Copy, Clone, PartialEq)]

/// The anchors can be placed outside of the curve (a visible landmark outside, bound to an other parallel track…)
/// We can store the projected anchors to avoid the recomputation when loading the data
pub struct ProjectedAnchor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ProjectedAnchor<'a> {
  type Inner = ProjectedAnchor<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ProjectedAnchor<'a> {
  pub const VT_GEOMETRY: flatbuffers::VOffsetT = 4;
  pub const VT_DISTANCE_ALONG_CURVE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ProjectedAnchor { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ProjectedAnchorArgs<'args>
  ) -> flatbuffers::WIPOffset<ProjectedAnchor<'bldr>> {
    let mut builder = ProjectedAnchorBuilder::new(_fbb);
    builder.add_distance_along_curve(args.distance_along_curve);
    if let Some(x) = args.geometry { builder.add_geometry(x); }
    builder.finish()
  }


  /// The projected position on the curve
  #[inline]
  pub fn geometry(&self) -> Option<&'a Point> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Point>(ProjectedAnchor::VT_GEOMETRY, None)}
  }
  /// The distance from the start of the curve until the projected position of the anchor
  #[inline]
  pub fn distance_along_curve(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ProjectedAnchor::VT_DISTANCE_ALONG_CURVE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ProjectedAnchor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Point>("geometry", Self::VT_GEOMETRY, false)?
     .visit_field::<f64>("distance_along_curve", Self::VT_DISTANCE_ALONG_CURVE, false)?
     .finish();
    Ok(())
  }
}
pub struct ProjectedAnchorArgs<'a> {
    pub geometry: Option<&'a Point>,
    pub distance_along_curve: f64,
}
impl<'a> Default for ProjectedAnchorArgs<'a> {
  #[inline]
  fn default() -> Self {
    ProjectedAnchorArgs {
      geometry: None,
      distance_along_curve: 0.0,
    }
  }
}

pub struct ProjectedAnchorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ProjectedAnchorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_geometry(&mut self, geometry: &Point) {
    self.fbb_.push_slot_always::<&Point>(ProjectedAnchor::VT_GEOMETRY, geometry);
  }
  #[inline]
  pub fn add_distance_along_curve(&mut self, distance_along_curve: f64) {
    self.fbb_.push_slot::<f64>(ProjectedAnchor::VT_DISTANCE_ALONG_CURVE, distance_along_curve, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ProjectedAnchorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ProjectedAnchorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ProjectedAnchor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ProjectedAnchor<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ProjectedAnchor");
      ds.field("geometry", &self.geometry());
      ds.field("distance_along_curve", &self.distance_along_curve());
      ds.finish()
  }
}
pub enum LinearReferencingMethodOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Linear Referencing Methods (LRMs) are curves in space, along which distances can be measured.
/// Each linear referencing method has:
///   * a network traversal, which defines the path of the curve
///   * a sequence of anchors, which are projected on the curve, and used as positioning reference points
///   * distances between anchors have to be defined: even though distances can be measured on the curve,
pub struct LinearReferencingMethod<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LinearReferencingMethod<'a> {
  type Inner = LinearReferencingMethod<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LinearReferencingMethod<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_PROPERTIES: flatbuffers::VOffsetT = 6;
  pub const VT_TRAVERSAL_INDEX: flatbuffers::VOffsetT = 8;
  pub const VT_ANCHOR_INDICES: flatbuffers::VOffsetT = 10;
  pub const VT_DISTANCES: flatbuffers::VOffsetT = 12;
  pub const VT_PROJECTED_ANCHORS: flatbuffers::VOffsetT = 14;
  pub const VT_DISTANCE_UNIT: flatbuffers::VOffsetT = 16;
  pub const VT_MEASURE_UNIT: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LinearReferencingMethod { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LinearReferencingMethodArgs<'args>
  ) -> flatbuffers::WIPOffset<LinearReferencingMethod<'bldr>> {
    let mut builder = LinearReferencingMethodBuilder::new(_fbb);
    if let Some(x) = args.projected_anchors { builder.add_projected_anchors(x); }
    if let Some(x) = args.distances { builder.add_distances(x); }
    if let Some(x) = args.anchor_indices { builder.add_anchor_indices(x); }
    builder.add_traversal_index(args.traversal_index);
    if let Some(x) = args.properties { builder.add_properties(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_measure_unit(args.measure_unit);
    builder.add_distance_unit(args.distance_unit);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinearReferencingMethod::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn properties(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property>>>>(LinearReferencingMethod::VT_PROPERTIES, None)}
  }
  #[inline]
  pub fn traversal_index(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(LinearReferencingMethod::VT_TRAVERSAL_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn anchor_indices(&self) -> flatbuffers::Vector<'a, u64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(LinearReferencingMethod::VT_ANCHOR_INDICES, None).unwrap()}
  }
  #[inline]
  pub fn distances(&self) -> flatbuffers::Vector<'a, f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(LinearReferencingMethod::VT_DISTANCES, None).unwrap()}
  }
  /// If the anchors are projected, the all must be projected.
  /// `projected_anchors` is either null, or has the same size as `anchor_indices`
  #[inline]
  pub fn projected_anchors(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProjectedAnchor<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProjectedAnchor>>>>(LinearReferencingMethod::VT_PROJECTED_ANCHORS, None)}
  }
  /// The unit used to measure the distance between anchors
  #[inline]
  pub fn distance_unit(&self) -> DistanceUnit {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DistanceUnit>(LinearReferencingMethod::VT_DISTANCE_UNIT, Some(DistanceUnit::Meters)).unwrap()}
  }
  /// The unit used to express measures relative to anchors (12+230).
  #[inline]
  pub fn measure_unit(&self) -> DistanceUnit {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DistanceUnit>(LinearReferencingMethod::VT_MEASURE_UNIT, Some(DistanceUnit::Meters)).unwrap()}
  }
}

impl flatbuffers::Verifiable for LinearReferencingMethod<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Property>>>>("properties", Self::VT_PROPERTIES, false)?
     .visit_field::<u32>("traversal_index", Self::VT_TRAVERSAL_INDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("anchor_indices", Self::VT_ANCHOR_INDICES, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("distances", Self::VT_DISTANCES, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ProjectedAnchor>>>>("projected_anchors", Self::VT_PROJECTED_ANCHORS, false)?
     .visit_field::<DistanceUnit>("distance_unit", Self::VT_DISTANCE_UNIT, false)?
     .visit_field::<DistanceUnit>("measure_unit", Self::VT_MEASURE_UNIT, false)?
     .finish();
    Ok(())
  }
}
pub struct LinearReferencingMethodArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub properties: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Property<'a>>>>>,
    pub traversal_index: u32,
    pub anchor_indices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub distances: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub projected_anchors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ProjectedAnchor<'a>>>>>,
    pub distance_unit: DistanceUnit,
    pub measure_unit: DistanceUnit,
}
impl<'a> Default for LinearReferencingMethodArgs<'a> {
  #[inline]
  fn default() -> Self {
    LinearReferencingMethodArgs {
      id: None, // required field
      properties: None,
      traversal_index: 0,
      anchor_indices: None, // required field
      distances: None, // required field
      projected_anchors: None,
      distance_unit: DistanceUnit::Meters,
      measure_unit: DistanceUnit::Meters,
    }
  }
}

pub struct LinearReferencingMethodBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LinearReferencingMethodBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinearReferencingMethod::VT_ID, id);
  }
  #[inline]
  pub fn add_properties(&mut self, properties: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Property<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinearReferencingMethod::VT_PROPERTIES, properties);
  }
  #[inline]
  pub fn add_traversal_index(&mut self, traversal_index: u32) {
    self.fbb_.push_slot::<u32>(LinearReferencingMethod::VT_TRAVERSAL_INDEX, traversal_index, 0);
  }
  #[inline]
  pub fn add_anchor_indices(&mut self, anchor_indices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinearReferencingMethod::VT_ANCHOR_INDICES, anchor_indices);
  }
  #[inline]
  pub fn add_distances(&mut self, distances: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinearReferencingMethod::VT_DISTANCES, distances);
  }
  #[inline]
  pub fn add_projected_anchors(&mut self, projected_anchors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ProjectedAnchor<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinearReferencingMethod::VT_PROJECTED_ANCHORS, projected_anchors);
  }
  #[inline]
  pub fn add_distance_unit(&mut self, distance_unit: DistanceUnit) {
    self.fbb_.push_slot::<DistanceUnit>(LinearReferencingMethod::VT_DISTANCE_UNIT, distance_unit, DistanceUnit::Meters);
  }
  #[inline]
  pub fn add_measure_unit(&mut self, measure_unit: DistanceUnit) {
    self.fbb_.push_slot::<DistanceUnit>(LinearReferencingMethod::VT_MEASURE_UNIT, measure_unit, DistanceUnit::Meters);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LinearReferencingMethodBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LinearReferencingMethodBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LinearReferencingMethod<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, LinearReferencingMethod::VT_ID,"id");
    self.fbb_.required(o, LinearReferencingMethod::VT_ANCHOR_INDICES,"anchor_indices");
    self.fbb_.required(o, LinearReferencingMethod::VT_DISTANCES,"distances");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LinearReferencingMethod<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LinearReferencingMethod");
      ds.field("id", &self.id());
      ds.field("properties", &self.properties());
      ds.field("traversal_index", &self.traversal_index());
      ds.field("anchor_indices", &self.anchor_indices());
      ds.field("distances", &self.distances());
      ds.field("projected_anchors", &self.projected_anchors());
      ds.field("distance_unit", &self.distance_unit());
      ds.field("measure_unit", &self.measure_unit());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Lrs`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_lrs_unchecked`.
pub fn root_as_lrs(buf: &[u8]) -> Result<Lrs, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Lrs>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Lrs` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_lrs_unchecked`.
pub fn size_prefixed_root_as_lrs(buf: &[u8]) -> Result<Lrs, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Lrs>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Lrs` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_lrs_unchecked`.
pub fn root_as_lrs_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Lrs<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Lrs<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Lrs` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_lrs_unchecked`.
pub fn size_prefixed_root_as_lrs_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Lrs<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Lrs<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Lrs and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Lrs`.
pub unsafe fn root_as_lrs_unchecked(buf: &[u8]) -> Lrs {
  flatbuffers::root_unchecked::<Lrs>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Lrs and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Lrs`.
pub unsafe fn size_prefixed_root_as_lrs_unchecked(buf: &[u8]) -> Lrs {
  flatbuffers::size_prefixed_root_unchecked::<Lrs>(buf)
}
pub const LRS_IDENTIFIER: &str = "LRSD";

#[inline]
pub fn lrs_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, LRS_IDENTIFIER, false)
}

#[inline]
pub fn lrs_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, LRS_IDENTIFIER, true)
}

#[inline]
pub fn finish_lrs_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Lrs<'a>>) {
  fbb.finish(root, Some(LRS_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_lrs_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Lrs<'a>>) {
  fbb.finish_size_prefixed(root, Some(LRS_IDENTIFIER));
}
