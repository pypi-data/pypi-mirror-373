import pickle
import sqlite3
import uuid
from collections.abc import Callable
from pathlib import Path
from tempfile import TemporaryDirectory

import duckdb

from chrysalis._internal._relation import Relation
from chrysalis._internal._writer import TerminalUIWriter

_CREATE_INPUT_DATA_TABLE = """
CREATE TABLE input_data (
    id TEXT PRIMARY KEY,
    obj BLOB NOT NULL
);
"""

_CREATE_APPLIED_TRANSFORMATION_TABLE = """
CREATE TABLE applied_transformation (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    previous_transformation TEXT,
    link_index INT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (previous_transformation) REFERENCES applied_transformation(id)
);
"""

_CREATE_INVARIANT_TABLE = """
CREATE TABLE failed_invariant (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    applied_transformation TEXT NOT NULL,
    input_data TEXT NOT NULL,

    FOREIGN KEY (applied_transformation) REFERENCES applied_transformation(id),
    FOREIGN KEY (input_data) REFERENCES input_data(id)
);
"""


class TemporarySqlite3RelationConnection(TemporaryDirectory):
    """
    A temporary sqlite3 database designed to be used for transactional inserts.

    During metamorphic testing, we want to record the order of which transformations are
    applied and the result of each invariant tested in a relation chain. This data is
    available after each step that is executed in the engine. By definition, this
    pattern follows the transactional processing pattern and thus justifies using
    sqlite3.

    This database maintains two tables that are required to store the results of
    execution of a relation chain. The first table is the `transformation` table which
    records the order of which tranformations are applied to input data. The second
    table `failed_invariant` represents the result of a individual invariant tested for
    a given transformation that failed. It is important to note, it is possible that
    multiple invariants apply to the same transformation and thus a single transformation
    can have multiple invariants that fail.

    Given this database design, it is not required to store the result of
    transformations on the input data. Instead, the transformations can be reapplied to
    the input data to acheive indiviudal instances of transformed data that is
    requested. This dramatically reduces the amount of data that is required to be
    stored.

    Since this is a temporary sqlite3 connection, it is expected that all data will be
    extracted before exiting the context manager.
    """

    def __enter__(self, *args, **kwargs) -> tuple[sqlite3.Connection, Path]:
        """
        Create a database in the temporary directory created during initialization.

        In addition to creating the database, configure the sqlite3 database rules and
        create the relevant tables.
        """
        temp_dir = super().__enter__(*args, **kwargs)
        # Arguably, this context manager should be based off `TemporaryFile` instead of
        # `TemporaryDirectory`, but this design was chosen due to ease of
        # implementation.
        self.db_path = Path(temp_dir) / "chry.db"
        self.conn = sqlite3.connect(self.db_path)

        # Sqlite3 doesn't enfore foreign key existance by default.
        self.conn.execute("PRAGMA foreign_keys = ON")

        self.conn.execute(_CREATE_INPUT_DATA_TABLE)
        self.conn.execute(_CREATE_APPLIED_TRANSFORMATION_TABLE)
        self.conn.execute(_CREATE_INVARIANT_TABLE)

        return self.conn, self.db_path

    def __exit__(self, *args, **kwargs):
        # Close the SQLite connection *before* deleting the directory
        try:
            self.conn.close()
        except Exception:
            pass
        return super().__exit__(*args, **kwargs)


class Engine[T, R]:
    """
    A class responsible for execution in metamorphic testing.

    The engine performs the actual execution of tests specificed by provided relation
    chains. To start, an engine is initialized with a static SUT (system under test) and
    input dataset. Then, the SUT can be tested using provided relation chains (likely
    generated by the search space class). Each relation chain is completely independent
    from all other relation chains, although multiple chains can be passed to `execute`
    at once for performance reasons. Additionally, all input data objects are tested for
    each specified relation chain.

    Performing metamorphic testing on a single input data object and relation chain
    combination is an iterative process. First, the results of execution of the SUT on
    the input data is determined. Then, the input data is transformed by the
    transformation specified by the first relation in the relation chain. Lastly, the
    result of execution of the SUT on the transformed data is compared to the previous
    result so it can be determined if each invariant for the given transformation held.
    This process is repeated for each transformation in the relation chain.

    Under the hood, a sqlite database is maintained which denotes the results of
    executing each relation chain on all of the input data. This data is kept so it can
    be used later for debugging if an invariant failed.
    """

    def __init__(
        self,
        sut: Callable[[T], R],
        input_data: list[T],
        sqlite_conn: sqlite3.Connection,
        sqlite_db: Path,
        writer: TerminalUIWriter,
        num_processes: int = 8,
    ):
        if num_processes > 1:
            raise NotImplementedError

        self._sut = sut
        self._conn = sqlite_conn
        self._sqlite_db = sqlite_db
        self._writer = writer
        self._num_processes = num_processes

        # Insert input data into database and store uuid for future reference.
        self._input_data: dict[str, T] = {}
        cur = self._conn.cursor()
        for input_obj in input_data:
            obj_id = self._insert_input_data(
                obj=input_obj,
                cursor=cur,
            )
            self._input_data[obj_id] = input_obj

    def _generate_uuid(self) -> str:
        """Generate a 16 byte random uuid using the UUID4 specification."""
        return uuid.uuid4().hex

    def _insert_input_data(
        self,
        obj: T,
        cursor: sqlite3.Cursor,
    ) -> str:
        """Insert a record into the `input_data` table."""
        input_data_id = self._generate_uuid()
        cursor.execute(
            """
INSERT INTO input_data (id, obj)
VALUES (?, ?);
""",
            (input_data_id, pickle.dumps(obj)),
        )
        return input_data_id

    def _insert_applied_transformation(
        self,
        name: str,
        previous_transformation: str | None,
        link_index: int,
        cursor: sqlite3.Cursor,
    ) -> str:
        """Insert a record into the `applied_transformation` table."""
        applied_transformation_id = self._generate_uuid()
        cursor.execute(
            """
INSERT INTO applied_transformation (id, name, previous_transformation, link_index)
VALUES (?, ?, ?, ?);
""",
            (applied_transformation_id, name, previous_transformation, link_index),
        )
        return applied_transformation_id

    def _insert_failed_invariant(
        self,
        name: str,
        applied_transformation: str,
        input_data: str,
        cursor: sqlite3.Cursor,
    ) -> None:
        """Insert a record into the `failed_invariant` table."""
        invaraint_id = self._generate_uuid()
        cursor.execute(
            """
INSERT INTO failed_invariant (id, name, applied_transformation, input_data)
VALUES (?, ?, ?, ?);
        """,
            (invaraint_id, name, applied_transformation, input_data),
        )

    def _execute_chain(
        self,
        relation_chain: list[Relation],
        cursor: sqlite3.Cursor,
    ) -> None:
        """Execute a relation chain and store all results in a provided database."""
        results: list[R] = []
        input_data_ids = list(self._input_data.keys())
        # TODO(nathanhuey44.gmail.com): The results of the SUT on the input data is
        # consistent for all relation chains and should be cached.
        for curr_input in self._input_data.values():
            # TODO(nathanhuey44@gmail.com): Catch errors, exit gracefully, and report
            # error.
            results.append(self._sut(curr_input))  # NOQA: PERF401
        previous_transformation_id: str | None = None
        previous_inputs = list(self._input_data.values())
        previous_results = results

        self._writer.start_live()
        for link_index, relation in enumerate(relation_chain):
            current_inputs: list[T] = []
            for prev_input in previous_inputs:
                # TODO(nathanhuey44@gmail.com): Catch errors, exit gracefully, and
                # report error.
                current_inputs.append(  # NOQA: PERF401
                    relation.apply_transform(prev_input)
                )

            current_results: list[R] = []
            for curr_input in current_inputs:
                # TODO(nathanhuey44@gmail.com): Catch errors, exit gracefully, and
                # report error.
                current_results.append(self._sut(curr_input))  # NOQA: PERF401

            current_transformation_id = self._insert_applied_transformation(
                name=relation.transformation_name,
                previous_transformation=previous_transformation_id,
                link_index=link_index,
                cursor=cursor,
            )
            failed_invariants: set[str] = set()
            for invariant in relation.invariants:
                for i, (prev_result, curr_result) in enumerate(
                    zip(previous_results, current_results, strict=False)
                ):
                    if not invariant(curr_result, prev_result):
                        failed_invariants.add(invariant.__name__)
                        self._insert_failed_invariant(
                            name=invariant.__name__,
                            applied_transformation=current_transformation_id,
                            input_data=input_data_ids[i],
                            cursor=cursor,
                        )

            if len(failed_invariants) == 0:
                self._writer.print_tested_relation(
                    success=True,
                    metadata={
                        "relation": relation.transformation_name,
                        "index": link_index,
                    },
                )
            else:
                self._writer.store_failed_relation(
                    failed_relation=relation.transformation_name,
                    failed_invariants=list(failed_invariants),
                )
                self._writer.print_tested_relation(
                    success=False,
                    metadata={
                        "relation": relation.transformation_name,
                        "index": link_index,
                        "failed_invariants": list(failed_invariants),
                    },
                )

            previous_transformation_id = current_transformation_id
            previous_inputs = current_inputs
            previous_results = current_results

        self._writer.stop_live()
        self._writer.print_failed_relations()
        self._writer.print_summary()

    def execute(self, relation_chains: list[list[Relation]]) -> None:
        """
        Execute a list of provided relation chains and store the results.

        Execution of a relation chain involves iteratively applying transformations to
        each item in the input data and ensuring all invariants hold. At the moment,
        we do not anticipate transformations causing errors regardless of the input.
        It is important to note that multiple relations can reference the same
        transformation and thus multiple invariant can be checked during a single step
        in a relation chain.
        """
        # TODO(nathanhuey44@gmail.com): Implement a multi-process version of this
        # execute functionality using sqlite3 cursors.
        cursor = self._conn.cursor()
        for relation_chain in relation_chains:
            self._execute_chain(relation_chain=relation_chain, cursor=cursor)
        self._conn.commit()

    def results_to_duckdb(self) -> duckdb.DuckDBPyConnection:
        """
        Convert the sqlite3 database into a duckdb database.

        Sqlite databases are designed for transactional processing, which fits our use
        case when inserting transaction and invariant records, especially if the program
        is using multiple cores. Once all the results have been accumulated, we can
        convert the database into a duckdb database due to duckdb's better performance
        on analytical queries and better data compression.
        """
        duckdb_conn = duckdb.connect()

        # Sqlite needs to be installed within duckdb before `sqlite_scan` can be used.
        duckdb_conn.execute("INSTALL sqlite;")

        # The schema of the tables needs to be specified before records are inserted. If
        # the schema is inferred from sqlite, it may be wrong.
        duckdb_conn.execute(_CREATE_INPUT_DATA_TABLE)
        duckdb_conn.execute(_CREATE_APPLIED_TRANSFORMATION_TABLE)
        duckdb_conn.execute(_CREATE_INVARIANT_TABLE)

        duckdb_conn.execute(
            """
INSERT INTO input_data
SELECT * FROM sqlite_scan(?, ?);
                """,
            (str(self._sqlite_db), "input_data"),
        )

        # Unfortunately, there is a bug in `duckdb` with self-referential tables when
        # batch loading. To work around this issue, we can partition the data ourselves
        # into batches per `link_index` and insert the batches sequentially.
        # https://github.com/duckdb/duckdb/issues/10574
        match duckdb_conn.execute(
            "SELECT MAX(link_index) FROM sqlite_scan(?, ?)",
            (str(self._sqlite_db), "applied_transformation"),
        ).fetchone():
            case (max_link_index,):
                pass
            case _:
                raise RuntimeError(
                    "The chrysalis sqlite database has been tampered with during execution, exiting."
                )

        for i in range(max_link_index + 1):
            duckdb_conn.execute(
                """
INSERT INTO applied_transformation
SELECT * FROM sqlite_scan(?, ?) WHERE link_index = ?;
                    """,
                (str(self._sqlite_db), "applied_transformation", i),
            )

        duckdb_conn.execute(
            """
INSERT INTO failed_invariant
SELECT * FROM sqlite_scan(?, ?);
                """,
            (str(self._sqlite_db), "failed_invariant"),
        )
        return duckdb_conn
