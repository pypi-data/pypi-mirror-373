"""
TimeSignature class binding
"""
from __future__ import annotations
import typing
__all__ = ['Barline', 'C', 'Chord', 'Clef', 'ClefSign', 'F', 'G', 'HeapData', 'Helper', 'Interval', 'Key', 'Measure', 'Note', 'NoteData', 'NoteDataHeap', 'P', 'Part', 'RhythmFigure', 'Score', 'ScoreCollection', 'TimeSignature']
class Barline:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __hash__(self) -> int:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def clean(self) -> None:
        ...
    def getBarStyle(self) -> str:
        ...
    def getDirection(self) -> str:
        ...
    def getLocation(self) -> str:
        ...
    def setBarStyle(self, barStyle: str) -> None:
        ...
    def setDirection(self, direction: str) -> None:
        ...
    def setLocation(self, location: str) -> None:
        ...
    def setRepeatEnd(self) -> None:
        ...
    def setRepeatStart(self) -> None:
        ...
    def toXML(self, identSize: int = 2) -> str:
        ...
class Chord:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __add__(self, arg0: Chord) -> Chord:
        ...
    def __eq__(self, arg0: Chord) -> bool:
        ...
    def __getitem__(self, arg0: int) -> Note:
        ...
    def __hash__(self) -> int:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, notes: list[Note], rhythmFigure: RhythmFigure = ...) -> None:
        ...
    @typing.overload
    def __init__(self, pitches: list[str], rhythmFigure: RhythmFigure = ...) -> None:
        ...
    def __ne__(self, arg0: Chord) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int) -> Note:
        ...
    @typing.overload
    def addNote(self, note: Note) -> None:
        ...
    @typing.overload
    def addNote(self, pitch: str) -> None:
        ...
    def clear(self) -> None:
        ...
    def getBassNote(self) -> Note:
        ...
    def getCloseChord(self, enharmonyNotes: bool = False) -> Chord:
        ...
    def getCloseStackChord(self, enharmonyNotes: bool = False) -> Chord:
        ...
    def getCloseStackHarmonicComplexity(self, useEnharmony: bool = False) -> float:
        ...
    def getCloseStackIntervals(self, firstNoteAsReference: bool = False) -> list[Interval]:
        ...
    def getDegree(self, key: Key, enharmonyNotes: bool = False) -> int:
        ...
    def getDuration(self) -> str:
        ...
    def getDurationTicks(self) -> int:
        ...
    def getFrequencyStd(self) -> float:
        ...
    @typing.overload
    def getHarmonicDensity(self, lowerBoundMIDI: int = -1, higherBoundMIDI: int = -1) -> float:
        ...
    @typing.overload
    def getHarmonicDensity(self, lowerBoundPitch: str = '', higherBoundPitch: str = '') -> float:
        ...
    def getHarmonicSpectrum(self, numPartialsPerNote: int = 6, amplCallback: typing.Callable[[list[float]], list[float]] = None, partialsDecayExpRate: float = 0.8799999952316284) -> tuple[list[float], list[float]]:
        ...
    def getIntervals(self, firstNoteAsReference: bool = False) -> list[Interval]:
        ...
    def getIntervalsFromOriginalSortedNotes(self) -> list[Interval]:
        ...
    def getMeanFrequency(self) -> float:
        ...
    def getMeanMidiValue(self) -> int:
        ...
    def getMeanOfExtremesFrequency(self) -> float:
        ...
    def getMeanOfExtremesMidiValue(self) -> int:
        ...
    def getMeanOfExtremesPitch(self, accType: str = '') -> str:
        ...
    def getMeanPitch(self, accType: str = '') -> str:
        ...
    def getMidiIntervals(self, firstNoteAsReference: bool = False) -> list[int]:
        ...
    def getMidiValueStd(self) -> float:
        ...
    def getName(self) -> str:
        ...
    @typing.overload
    def getNote(self, noteIndex: int) -> Note:
        ...
    @typing.overload
    def getNote(self, noteIndex: int) -> Note:
        ...
    def getNotes(self) -> list[Note]:
        ...
    def getOpenStackChord(self, enharmonyNotes: bool = False) -> Chord:
        ...
    def getOpenStackIntervals(self, firstNoteAsReference: bool = False) -> list[Interval]:
        ...
    def getOpenStackNotes(self) -> list[Note]:
        ...
    def getQuality(self) -> str:
        ...
    def getQuarterDuration(self) -> float:
        ...
    def getRomanDegree(self, key: Key, enharmonyNotes: bool = False) -> str:
        ...
    def getRoot(self) -> Note:
        ...
    def getSetharesDissonance(self, numPartialsPerNote: int = 6, useMinModel: bool = True, amplCallback: typing.Callable[[list[float]], list[float]] = None, partialsDecayExpRate: float = 0.8799999952316284, dissCallback: typing.Callable[[list[float]], float] = None) -> float:
        ...
    def getSetharesDyadsDataFrame(self, numPartialsPerNote: int = 6, useMinModel: bool = True, amplCallback: typing.Callable[[list[float]], list[float]] = None, partialsDecayExpRate: float = 0.8799999952316284) -> typing.Any:
        ...
    def getStackDataFrame(self, enharmonyNotes: bool = False) -> typing.Any:
        ...
    def haveAnyOctaveAugmentedFifth(self, useEnharmony: bool = False) -> bool:
        ...
    def haveAnyOctaveAugmentedFourth(self, useEnharmony: bool = False) -> bool:
        ...
    def haveAnyOctaveAugmentedOctave(self, useEnharmony: bool = False) -> bool:
        ...
    def haveAnyOctaveDiminishedFifth(self, useEnharmony: bool = False) -> bool:
        ...
    def haveAnyOctaveDiminishedOctave(self, useEnharmony: bool = False) -> bool:
        ...
    def haveAnyOctaveDiminishedSeventh(self, useEnharmony: bool = False) -> bool:
        ...
    def haveAnyOctaveFifth(self) -> bool:
        ...
    def haveAnyOctaveFourth(self) -> bool:
        ...
    def haveAnyOctaveMajorSecond(self, useEnharmony: bool = False) -> bool:
        ...
    def haveAnyOctaveMajorSeventh(self, useEnharmony: bool = False) -> bool:
        ...
    def haveAnyOctaveMajorSixth(self, useEnharmony: bool = False) -> bool:
        ...
    def haveAnyOctaveMajorThird(self, useEnharmony: bool = False) -> bool:
        ...
    def haveAnyOctaveMinorSecond(self, useEnharmony: bool = False) -> bool:
        ...
    def haveAnyOctaveMinorSeventh(self, useEnharmony: bool = False) -> bool:
        ...
    def haveAnyOctaveMinorSixth(self, useEnharmony: bool = False) -> bool:
        ...
    def haveAnyOctaveMinorThird(self, useEnharmony: bool = False) -> bool:
        ...
    def haveAnyOctaveOctave(self) -> bool:
        ...
    def haveAnyOctavePerfectFifth(self, useEnharmony: bool = False) -> bool:
        ...
    def haveAnyOctavePerfectFourth(self, useEnharmony: bool = False) -> bool:
        ...
    def haveAnyOctavePerfectOctave(self, useEnharmony: bool = False) -> bool:
        ...
    def haveAnyOctaveSecond(self) -> bool:
        ...
    def haveAnyOctaveSeventh(self) -> bool:
        ...
    def haveAnyOctaveSixth(self) -> bool:
        ...
    def haveAnyOctaveThird(self) -> bool:
        ...
    def haveAugmentedFifth(self, useEnharmony: bool = False) -> bool:
        ...
    def haveAugmentedFourth(self, useEnharmony: bool = False) -> bool:
        ...
    def haveAugmentedInterval(self, useEnharmony: bool = False) -> bool:
        ...
    def haveAugmentedOctave(self, useEnharmony: bool = False) -> bool:
        ...
    def haveAugmentedUnisson(self, useEnharmony: bool = False) -> bool:
        ...
    def haveDiminishedFifth(self, useEnharmony: bool = False) -> bool:
        ...
    def haveDiminishedInterval(self, useEnharmony: bool = False) -> bool:
        ...
    def haveDiminishedOctave(self, useEnharmony: bool = False) -> bool:
        ...
    def haveDiminishedSeventh(self, useEnharmony: bool = False) -> bool:
        ...
    def haveDiminishedUnisson(self, useEnharmony: bool = False) -> bool:
        ...
    def haveEleventh(self, useEnharmony: bool = False) -> bool:
        ...
    def haveFifth(self, useEnharmony: bool = False) -> bool:
        ...
    def haveFourth(self, useEnharmony: bool = False) -> bool:
        ...
    def haveMajorInterval(self, useEnharmony: bool = False) -> bool:
        ...
    def haveMajorNinth(self, useEnharmony: bool = False) -> bool:
        ...
    def haveMajorSecond(self, useEnharmony: bool = False) -> bool:
        ...
    def haveMajorSeventh(self, useEnharmony: bool = False) -> bool:
        ...
    def haveMajorSixth(self, useEnharmony: bool = False) -> bool:
        ...
    def haveMajorThird(self, useEnharmony: bool = False) -> bool:
        ...
    def haveMajorThirdteenth(self, useEnharmony: bool = False) -> bool:
        ...
    def haveMinorInterval(self, useEnharmony: bool = False) -> bool:
        ...
    def haveMinorNinth(self, useEnharmony: bool = False) -> bool:
        ...
    def haveMinorSecond(self, useEnharmony: bool = False) -> bool:
        ...
    def haveMinorSeventh(self, useEnharmony: bool = False) -> bool:
        ...
    def haveMinorSixth(self, useEnharmony: bool = False) -> bool:
        ...
    def haveMinorThird(self, useEnharmony: bool = False) -> bool:
        ...
    def haveMinorThirdteenth(self, useEnharmony: bool = False) -> bool:
        ...
    def haveNinth(self, useEnharmony: bool = False) -> bool:
        ...
    def haveOctave(self, useEnharmony: bool = False) -> bool:
        ...
    def havePerfectEleventh(self, useEnharmony: bool = False) -> bool:
        ...
    def havePerfectFifth(self, useEnharmony: bool = False) -> bool:
        ...
    def havePerfectFourth(self, useEnharmony: bool = False) -> bool:
        ...
    def havePerfectInterval(self, useEnharmony: bool = False) -> bool:
        ...
    def havePerfectOctave(self, useEnharmony: bool = False) -> bool:
        ...
    def havePerfectUnisson(self, useEnharmony: bool = False) -> bool:
        ...
    def haveSecond(self, useEnharmony: bool = False) -> bool:
        ...
    def haveSeventh(self, useEnharmony: bool = False) -> bool:
        ...
    def haveSharpEleventh(self, useEnharmony: bool = False) -> bool:
        ...
    def haveSixth(self, useEnharmony: bool = False) -> bool:
        ...
    def haveThird(self, useEnharmony: bool = False) -> bool:
        ...
    def haveThirdteenth(self, useEnharmony: bool = False) -> bool:
        ...
    def info(self) -> None:
        ...
    def insertNote(self, insertNote: Note, positionNote: int = 0) -> None:
        ...
    def isAugmentedChord(self) -> bool:
        ...
    def isDiminishedChord(self) -> bool:
        ...
    def isDominantSeventhChord(self) -> bool:
        ...
    def isHalfDiminishedChord(self) -> bool:
        ...
    def isInRootPosition(self) -> bool:
        ...
    def isMajorChord(self) -> bool:
        ...
    def isMinorChord(self) -> bool:
        ...
    def isSorted(self) -> bool:
        ...
    def isSus(self) -> bool:
        ...
    def isTonal(self, model: typing.Callable[[Chord], bool] = None) -> bool:
        ...
    def isWholeDiminishedChord(self) -> bool:
        ...
    def print(self) -> None:
        ...
    def printStack(self) -> None:
        ...
    def removeDuplicateNotes(self) -> None:
        ...
    def removeNote(self, noteIndex: int) -> None:
        ...
    def removeTopNote(self) -> None:
        ...
    @typing.overload
    def setDuration(self, duration: Duration) -> None:
        ...
    @typing.overload
    def setDuration(self, quarterDuration: float, divisionsPerQuarterNote: int = 256) -> None:
        ...
    def size(self) -> int:
        ...
    def sortNotes(self) -> None:
        ...
    def stackSize(self) -> int:
        ...
    def toCents(self) -> list[int]:
        ...
    def toInversion(self, inversionNumber: int) -> None:
        ...
    def transpose(self, semiTonesNumber: int) -> None:
        ...
    def transposeStackOnly(self, semiTonesNumber: int) -> None:
        ...
class Clef:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __hash__(self) -> int:
        ...
    def __init__(self, sign: ClefSign = ..., line: int = -1) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def getLine(self) -> int:
        ...
    def getSign(self) -> ClefSign:
        ...
    def setLine(self, line: int) -> None:
        ...
    def setSign(self, sign: ClefSign) -> None:
        ...
    def toXML(self, clefNumber: int = -1, identSize: int = 2) -> str:
        ...
class ClefSign:
    """
    Members:
    
      G
    
      F
    
      C
    
      P
    """
    C: typing.ClassVar[ClefSign]  # value = <ClefSign.C: 2>
    F: typing.ClassVar[ClefSign]  # value = <ClefSign.F: 1>
    G: typing.ClassVar[ClefSign]  # value = <ClefSign.G: 0>
    P: typing.ClassVar[ClefSign]  # value = <ClefSign.P: 3>
    __members__: typing.ClassVar[dict[str, ClefSign]]  # value = {'G': <ClefSign.G: 0>, 'F': <ClefSign.F: 1>, 'C': <ClefSign.C: 2>, 'P': <ClefSign.P: 3>}
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class HeapData:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
class Helper:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @staticmethod
    @typing.overload
    def calculateMelodyEuclideanSimilarity(melodyPattern: list[Note], otherMelody: list[Note]) -> float:
        ...
    @staticmethod
    @typing.overload
    def calculateMelodyEuclideanSimilarity(semitonesDifference: list[float]) -> float:
        ...
    @staticmethod
    @typing.overload
    def calculateRhythmicEuclideanSimilarity(rhythmPattern: list[Note], otherRhythm: list[Note]) -> float:
        ...
    @staticmethod
    @typing.overload
    def calculateRhythmicEuclideanSimilarity(durationDifferences: list[float]) -> float:
        ...
    @staticmethod
    def durationRatio(duration_A: float, duration_B: float) -> float:
        ...
    @staticmethod
    def freq2equalTemperament(freq: float, referenceFreq: float = 440.0) -> float:
        ...
    @staticmethod
    def freq2midiNote(freq: float, modelo: typing.Callable[[float], int] = None) -> tuple[int, int]:
        ...
    @staticmethod
    def freq2pitch(freq: float, accType: str = '') -> tuple[str, int]:
        ...
    @staticmethod
    def frequencies2cents(freq_A: float, freq_B: float) -> int:
        ...
    @staticmethod
    def getDurationDifferenceBetweenRhythms(referenceRhythm: list[Note], otherRhythm: list[Note]) -> list[float]:
        ...
    @staticmethod
    def getPercentiles(arg0: typing.Any, arg1: list[float]) -> typing.Any:
        ...
    @staticmethod
    def getSemitonesDifferenceBetweenMelodies(referenceMelody: list[Note], otherMelody: list[Note]) -> list[float]:
        ...
    @staticmethod
    def isEnharmonic(arg0: str, arg1: str) -> bool:
        ...
    @staticmethod
    def midiNote2freq(midiNoteValue: int, freqA4: float = 440.0) -> float:
        ...
    @staticmethod
    def midiNote2octave(midiNote: int) -> int:
        ...
    @staticmethod
    def midiNote2pitch(midiNote: int, accType: str = '') -> str:
        ...
    @staticmethod
    def midiNote2pitches(midiNote: int) -> list[str]:
        ...
    @staticmethod
    def noteSimilarity(pitchClass_A: str, octave_A: int, duration_A: float, pitchClass_B: str, octave_B: int, duration_B: float, enableEnharmonic: bool = False) -> tuple[float, float, float]:
        ...
    @staticmethod
    def noteType2RhythmFigure(noteType: str) -> RhythmFigure:
        ...
    @staticmethod
    def noteType2ticks(noteType: str, divisionsPerQuarterNote: int = 256) -> int:
        ...
    @staticmethod
    @typing.overload
    def notes2Intervals(pitches: list[str], firstNoteAsReference: bool = False) -> list[Interval]:
        ...
    @staticmethod
    @typing.overload
    def notes2Intervals(notes: list[Note], firstNoteAsReference: bool = False) -> list[Interval]:
        ...
    @staticmethod
    def pitch2freq(pitch: str) -> float:
        ...
    @staticmethod
    def pitch2midiNote(pitch: str) -> int:
        ...
    @staticmethod
    @typing.overload
    def pitch2number(pitch: str) -> float:
        ...
    @staticmethod
    @typing.overload
    def pitch2number(pitch: str) -> float:
        ...
    @staticmethod
    def pitchRatio(pitch_A: str, pitch_B: str) -> float:
        ...
    @staticmethod
    def rhythmFigure2Ticks(rhythmFigure: RhythmFigure, divisionsPerQuarterNote: int = 265) -> int:
        ...
    @staticmethod
    def rhythmFigure2noteType(rhythmFigure: RhythmFigure) -> str:
        ...
    @staticmethod
    def ticks2noteType(durationTicks: int, divisionsPerQuarterNote: int = 256, actualNotes: int = 1, normalNotes: int = 1) -> tuple[str, int]:
        ...
    @staticmethod
    def transposePitch(pitch: str, semitones: int, accType: str = '#') -> str:
        ...
class Interval:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __hash__(self) -> int:
        ...
    @typing.overload
    def __init__(self, pitch_A: str = 'C4', pitch_B: str = 'C4') -> None:
        ...
    @typing.overload
    def __init__(self, note_A: Note, note_B: Note) -> None:
        ...
    def __lt__(self, arg0: Interval) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def getDiatonicInterval(self, useSingleOctave: bool = True, absoluteValue: bool = False) -> int:
        ...
    def getDiatonicSteps(self, useSingleOctave: bool = True, absoluteValue: bool = False) -> int:
        ...
    def getDirection(self) -> str:
        ...
    def getName(self) -> str:
        ...
    def getNotes(self) -> list[Note]:
        ...
    def getNumOctaves(self, absoluteValue: bool = False) -> int:
        ...
    def getNumSemitones(self, absoluteValue: bool = False) -> int:
        ...
    def getPitchStepInterval(self) -> int:
        ...
    def isAnyOctaveAugmentedFifth(self, useEnharmony: bool = False) -> bool:
        ...
    def isAnyOctaveAugmentedFourth(self, useEnharmony: bool = False) -> bool:
        ...
    def isAnyOctaveAugmentedOctave(self, useEnharmony: bool = False) -> bool:
        ...
    def isAnyOctaveDiminishedFifth(self, useEnharmony: bool = False) -> bool:
        ...
    def isAnyOctaveDiminishedOctave(self, useEnharmony: bool = False) -> bool:
        ...
    def isAnyOctaveDiminishedSeventh(self, useEnharmony: bool = False) -> bool:
        ...
    def isAnyOctaveFifth(self) -> bool:
        ...
    def isAnyOctaveFourth(self) -> bool:
        ...
    def isAnyOctaveMajorSecond(self, useEnharmony: bool = False) -> bool:
        ...
    def isAnyOctaveMajorSeventh(self, useEnharmony: bool = False) -> bool:
        ...
    def isAnyOctaveMajorSixth(self, useEnharmony: bool = False) -> bool:
        ...
    def isAnyOctaveMajorThird(self, useEnharmony: bool = False) -> bool:
        ...
    def isAnyOctaveMinorSecond(self, useEnharmony: bool = False) -> bool:
        ...
    def isAnyOctaveMinorSeventh(self, useEnharmony: bool = False) -> bool:
        ...
    def isAnyOctaveMinorSixth(self, useEnharmony: bool = False) -> bool:
        ...
    def isAnyOctaveMinorThird(self, useEnharmony: bool = False) -> bool:
        ...
    def isAnyOctaveOctave(self) -> bool:
        ...
    def isAnyOctavePerfectFifth(self, useEnharmony: bool = False) -> bool:
        ...
    def isAnyOctavePerfectFourth(self, useEnharmony: bool = False) -> bool:
        ...
    def isAnyOctavePerfectOctave(self, useEnharmony: bool = False) -> bool:
        ...
    def isAnyOctaveSecond(self) -> bool:
        ...
    def isAnyOctaveSeventh(self) -> bool:
        ...
    def isAnyOctaveSixth(self) -> bool:
        ...
    def isAnyOctaveThird(self) -> bool:
        ...
    def isAscendant(self) -> bool:
        ...
    def isAugmented(self, useEnharmony: bool = False) -> bool:
        ...
    def isAugmentedFifth(self, useEnharmony: bool = False) -> bool:
        ...
    def isAugmentedFourth(self, useEnharmony: bool = False) -> bool:
        ...
    def isAugmentedOctave(self, useEnharmony: bool = False) -> bool:
        ...
    def isAugmentedUnisson(self, useEnharmony: bool = False) -> bool:
        ...
    def isCompound(self) -> bool:
        ...
    def isDescendant(self) -> bool:
        ...
    def isDiminished(self, useEnharmony: bool = False) -> bool:
        ...
    def isDiminishedFifth(self, useEnharmony: bool = False) -> bool:
        ...
    def isDiminishedOctave(self, useEnharmony: bool = False) -> bool:
        ...
    def isDiminishedSeventh(self, useEnharmony: bool = False) -> bool:
        ...
    def isDiminishedUnisson(self, useEnharmony: bool = False) -> bool:
        ...
    def isEleventh(self, useEnharmony: bool = False) -> bool:
        ...
    def isFifth(self, useEnharmony: bool = False) -> bool:
        ...
    def isFourth(self, useEnharmony: bool = False) -> bool:
        ...
    def isMajor(self, useEnharmony: bool = False) -> bool:
        ...
    def isMajorNinth(self, useEnharmony: bool = False) -> bool:
        ...
    def isMajorSecond(self, useEnharmony: bool = False) -> bool:
        ...
    def isMajorSeventh(self, useEnharmony: bool = False) -> bool:
        ...
    def isMajorSixth(self, useEnharmony: bool = False) -> bool:
        ...
    def isMajorThird(self, useEnharmony: bool = False) -> bool:
        ...
    def isMajorThirdteenth(self, useEnharmony: bool = False) -> bool:
        ...
    def isMinor(self, useEnharmony: bool = False) -> bool:
        ...
    def isMinorNinth(self, useEnharmony: bool = False) -> bool:
        ...
    def isMinorSecond(self, useEnharmony: bool = False) -> bool:
        ...
    def isMinorSeventh(self, useEnharmony: bool = False) -> bool:
        ...
    def isMinorSixth(self, useEnharmony: bool = False) -> bool:
        ...
    def isMinorThird(self, useEnharmony: bool = False) -> bool:
        ...
    def isMinorThirdteenth(self, useEnharmony: bool = False) -> bool:
        ...
    def isNinth(self, useEnharmony: bool = False) -> bool:
        ...
    def isOctave(self, useEnharmony: bool = False) -> bool:
        ...
    def isPerfect(self, useEnharmony: bool = False) -> bool:
        ...
    def isPerfectEleventh(self, useEnharmony: bool = False) -> bool:
        ...
    def isPerfectFifth(self, useEnharmony: bool = False) -> bool:
        ...
    def isPerfectFourth(self, useEnharmony: bool = False) -> bool:
        ...
    def isPerfectOctave(self, useEnharmony: bool = False) -> bool:
        ...
    def isPerfectUnisson(self, useEnharmony: bool = False) -> bool:
        ...
    def isSecond(self, useEnharmony: bool = False) -> bool:
        ...
    def isSeventh(self, useEnharmony: bool = False) -> bool:
        ...
    def isSharpEleventh(self, useEnharmony: bool = False) -> bool:
        ...
    def isSimple(self) -> bool:
        ...
    def isSixth(self, useEnharmony: bool = False) -> bool:
        ...
    def isThird(self, useEnharmony: bool = False) -> bool:
        ...
    def isThirdteenth(self, useEnharmony: bool = False) -> bool:
        ...
    def isTonal(self) -> bool:
        ...
    @typing.overload
    def setNotes(self, pitch_A: str, pitch_B: str) -> None:
        ...
    @typing.overload
    def setNotes(self, note_A: Note, note_B: Note) -> None:
        ...
    def toCents(self) -> int:
        ...
class Key:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __hash__(self) -> int:
        ...
    @typing.overload
    def __init__(self, fifthCircle: int = 0, isMajorMode: bool = True) -> None:
        ...
    @typing.overload
    def __init__(self, key: str) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def getFifthCircle(self) -> int:
        ...
    def getName(self) -> str:
        ...
    def getRelativeKeyName(self) -> str:
        ...
    def isMajorMode(self) -> int:
        ...
    def setFifthCircle(self, fifthCircle: int) -> None:
        ...
    def setIsMajorMode(self, isMajorMode: bool) -> None:
        ...
class Measure:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __hash__(self) -> int:
        ...
    def __init__(self, numStaves: int = 1, divisionsPerQuarterNote: int = 256) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def addNote(self, note: Note, staveId: int = 0, position: int = -1) -> None:
        """
        Add a single Note object
        """
    @typing.overload
    def addNote(self, noteVec: list[Note], staveId: int = 0, position: int = -1) -> None:
        """
        Add a Note object vector
        """
    @typing.overload
    def addNote(self, pitchClass: str, staveId: int = 0, position: int = -1) -> None:
        """
        Create a new Note Obj and add it
        """
    @typing.overload
    def addNote(self, pitchClassVec: list[str], staveId: int = 0, position: int = -1) -> None:
        """
        Create a new Note vector and add it
        """
    def clear(self) -> None:
        ...
    def divisionsPerQuarterNoteChanged(self) -> bool:
        ...
    @typing.overload
    def getBarlineLeft(self) -> Barline:
        ...
    @typing.overload
    def getBarlineLeft(self) -> Barline:
        ...
    @typing.overload
    def getBarlineRight(self) -> Barline:
        ...
    @typing.overload
    def getBarlineRight(self) -> Barline:
        ...
    @typing.overload
    def getClef(self, clefId: int = 0) -> Clef:
        ...
    @typing.overload
    def getClef(self, clefId: int = 0) -> Clef:
        ...
    def getDivisionsPerQuarterNote(self) -> int:
        ...
    def getDurationTicks(self) -> int:
        ...
    def getEmptyDurationTicks(self) -> int:
        ...
    def getFifthCircle(self) -> int:
        ...
    def getFilledDurationTicks(self, staveId: int = 0) -> int:
        ...
    def getFilledQuarterDuration(self, staveId: int = 0) -> float:
        ...
    def getFractionDuration(self) -> Fraction:
        ...
    def getFreeDurationTicks(self, staveId: int = 0) -> int:
        ...
    def getFreeQuarterDuration(self, staveId: int = 0) -> float:
        ...
    def getKey(self) -> Key:
        ...
    def getKeyName(self) -> str:
        ...
    def getKeySignature(self) -> str:
        ...
    @typing.overload
    def getNote(self, noteId: int, staveId: int = 0) -> Note:
        ...
    @typing.overload
    def getNote(self, noteId: int, staveId: int = 0) -> Note:
        ...
    @typing.overload
    def getNoteOff(self, noteOffId: int, staveId: int = 0) -> Note:
        ...
    @typing.overload
    def getNoteOff(self, noteOffId: int, staveId: int = 0) -> Note:
        ...
    @typing.overload
    def getNoteOn(self, noteOnId: int, staveId: int = 0) -> Note:
        ...
    @typing.overload
    def getNoteOn(self, noteOnId: int, staveId: int = 0) -> Note:
        ...
    @typing.overload
    def getNumNotes(self) -> int:
        ...
    @typing.overload
    def getNumNotes(self, staveId: int) -> int:
        ...
    @typing.overload
    def getNumNotesOff(self) -> int:
        ...
    @typing.overload
    def getNumNotesOff(self, staveId: int) -> int:
        ...
    @typing.overload
    def getNumNotesOn(self) -> int:
        ...
    @typing.overload
    def getNumNotesOn(self, staveId: int) -> int:
        ...
    def getNumStaves(self) -> int:
        ...
    def getNumber(self) -> int:
        ...
    def getQuarterDuration(self) -> float:
        ...
    def getTimeMetronome(self) -> tuple[str, int]:
        ...
    def getTimeSignature(self) -> TimeSignature:
        ...
    def info(self) -> None:
        ...
    def isClefChanged(self) -> bool:
        ...
    def isEmpty(self) -> bool:
        ...
    def isMajorKeyMode(self) -> bool:
        ...
    def keySignatureChanged(self) -> bool:
        ...
    def metronomeChanged(self) -> bool:
        ...
    def removeNote(self, noteId: int, staveId: int = 0) -> None:
        ...
    def removeRepeatEnd(self) -> None:
        ...
    def removeRepeatStart(self) -> None:
        ...
    def setDivisionsPerQuarterNote(self, arg0: int) -> None:
        ...
    def setIsDivisionsPerQuarterNoteChanged(self, isDivisionsPerQuarterNoteChanged: bool = False) -> None:
        ...
    def setIsKeySignatureChanged(self, isKeySignatureChanged: bool = False) -> None:
        ...
    def setIsMetronomeChanged(self, isMetronomeChanged: bool = False) -> None:
        ...
    def setIsTimeSignatureChanged(self, isTimeSignatureChanged: bool = False) -> None:
        ...
    def setKey(self, fifthCircle: int, isMajorMode: bool = True) -> None:
        ...
    def setKeyMode(self, isMajorMode: bool) -> None:
        ...
    def setKeySignature(self, fifthCircle: int, isMajorMode: bool = True) -> None:
        ...
    def setMetronome(self, bpm: int, rhythmFigure: RhythmFigure = ...) -> None:
        ...
    def setNumStaves(self, numStaves: int) -> None:
        ...
    def setNumber(self, measureNumber: int) -> None:
        ...
    def setRepeatEnd(self) -> None:
        ...
    def setRepeatStart(self) -> None:
        ...
    def setTimeSignature(self, upper: int, lower: int) -> None:
        ...
    def timeSignatureChanged(self) -> bool:
        ...
    def toJSON(self) -> str:
        ...
    def toXML(self, instrumentId: int = 1, identSize: int = 2) -> str:
        ...
class Note:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __eq__(self, arg0: Note) -> bool:
        ...
    def __ge__(self, arg0: Note) -> bool:
        ...
    def __gt__(self, arg0: Note) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    @typing.overload
    def __init__(self, pitch: str, rhythmFigure: RhythmFigure = ..., isNoteOn: bool = True, inChord: bool = False, transposeDiatonic: int = 0, transposeChromatic: int = 0, divisionsPerQuarterNote: int = 256) -> None:
        ...
    @typing.overload
    def __init__(self, midiNumber: int, accType: str = '', rhythmFigure: RhythmFigure = ..., isNoteOn: bool = True, inChord: bool = False, transposeDiatonic: int = 0, transposeChromatic: int = 0, divisionsPerQuarterNote: int = 256) -> None:
        ...
    def __le__(self, arg0: Note) -> bool:
        ...
    def __lt__(self, arg0: Note) -> bool:
        ...
    def __ne__(self, arg0: Note) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def addArticulation(self, articulation: str) -> None:
        ...
    def addBeam(self, beam: str) -> None:
        ...
    def addSlur(self, slurType: str, slurOrientation: str) -> None:
        ...
    def addTie(self, tieType: str) -> None:
        ...
    def getAlterSymbol(self) -> str:
        ...
    def getArticulation(self) -> list[str]:
        ...
    def getBeam(self) -> list[str]:
        ...
    def getDiatonicSoundingPitchClass(self) -> str:
        ...
    def getDiatonicWrittenPitchClass(self) -> str:
        ...
    def getDivisionsPerQuarterNote(self) -> int:
        ...
    def getDuration(self) -> Duration:
        ...
    def getDurationTicks(self) -> int:
        ...
    def getEnharmonicNote(self, alternativeEnhamonicPitch: bool = False) -> Note:
        ...
    def getEnharmonicNotes(self, includeCurrentPitch: bool = False) -> list[Note]:
        ...
    def getEnharmonicPitch(self, alternativeEnhamonicPitch: bool = False) -> str:
        ...
    def getEnharmonicPitches(self, includeCurrentPitch: bool = False) -> list[str]:
        ...
    def getFrequency(self, equalTemperament: bool = True, freqA4: float = 440.0) -> float:
        ...
    def getHarmonicSpectrum(self, numPartials: int = 6, amplCallback: typing.Callable[[list[float]], list[float]] = None, partialsDecayExpRate: float = 0.8799999952316284) -> tuple[list[float], list[float]]:
        ...
    def getLongType(self) -> str:
        ...
    def getMidiNumber(self) -> int:
        ...
    @typing.overload
    def getNumDots(self) -> int:
        ...
    @typing.overload
    def getNumDots(self) -> int:
        ...
    def getOctave(self) -> int:
        ...
    def getPitch(self) -> str:
        ...
    def getPitchClass(self) -> str:
        ...
    def getPitchStep(self) -> str:
        ...
    def getQuarterDuration(self) -> float:
        ...
    def getScaleDegree(self, key: Key) -> int:
        ...
    def getShortType(self) -> str:
        ...
    def getSlur(self) -> tuple[str, str]:
        ...
    def getSoundingOctave(self) -> int:
        ...
    def getSoundingPitch(self) -> str:
        ...
    def getSoundingPitchClass(self) -> str:
        ...
    def getSoundingPitchStep(self) -> str:
        ...
    def getStaff(self) -> int:
        ...
    def getStem(self) -> str:
        ...
    def getTie(self) -> list[str]:
        ...
    def getTransposeChromatic(self) -> int:
        ...
    def getTransposeDiatonic(self) -> int:
        ...
    @typing.overload
    def getType(self) -> str:
        ...
    @typing.overload
    def getType(self) -> str:
        ...
    def getUnpitchedIndex(self) -> int:
        ...
    def getVoice(self) -> int:
        ...
    def getWrittenOctave(self) -> int:
        ...
    def getWrittenPitch(self) -> str:
        ...
    def getWrittenPitchClass(self) -> str:
        ...
    def getWrittenPitchStep(self) -> str:
        ...
    def inChord(self) -> bool:
        ...
    def info(self) -> None:
        ...
    def isDotted(self) -> bool:
        ...
    def isDoubleDotted(self) -> bool:
        ...
    def isGraceNote(self) -> bool:
        ...
    def isNoteOff(self) -> bool:
        ...
    def isNoteOn(self) -> bool:
        ...
    def isPitched(self) -> bool:
        ...
    def isTransposed(self) -> bool:
        ...
    def removeTies(self) -> None:
        ...
    @typing.overload
    def setDuration(self, duration: Duration) -> None:
        ...
    @typing.overload
    def setDuration(self, quarterDuration: float, divisionsPerQuarterNote: int = 256) -> None:
        ...
    def setIsGraceNote(self, isGraceNote: bool = False) -> None:
        ...
    def setIsInChord(self, inChord: bool) -> None:
        ...
    def setIsNoteOn(self, isNoteOn: bool) -> None:
        ...
    def setIsPitched(self, isPitched: bool = True) -> None:
        ...
    def setIsTuplet(self, isTuplet: bool = False) -> None:
        ...
    def setOctave(self, octave: int) -> None:
        ...
    def setPitch(self, pitch: str) -> None:
        ...
    def setPitchClass(self, pitchClass: str) -> None:
        """
        Set the note pitch class
        """
    def setStaff(self, staff: int) -> None:
        ...
    def setStem(self, stem: str) -> None:
        ...
    def setTieStart(self) -> None:
        ...
    def setTieStop(self) -> None:
        ...
    def setTieStopStart(self) -> None:
        ...
    def setTransposingInterval(self, diatonicInterval: int, chromaticInterval: int) -> None:
        ...
    def setTupleValues(self, actualNotes: int, normalNotes: int, normalType: str = 'eighth') -> None:
        ...
    def setUnpitchedIndex(self, arg0: int) -> None:
        ...
    def setVoice(self, voice: int) -> None:
        ...
    def toEnharmonicPitch(self, alternativeEnhamonicPitch: bool = False) -> None:
        ...
    def toXML(self, instrumentId: int = 1, identSize: int = 2) -> str:
        ...
    def transpose(self, semitones: int, accType: str = '') -> None:
        ...
class NoteData:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, note: Note, wasEnharmonized: bool, enharmonicDiatonicDistance: int) -> None:
        ...
class NoteDataHeap:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
class Part:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __hash__(self) -> int:
        ...
    def __init__(self, partName: str, numStaves: int = 1, isPitched: bool = True, divisionsPerQuarterNote: int = 256) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def addMeasure(self, numMeasures: int) -> None:
        ...
    def addMidiUnpitched(self, midiUnpitched: int) -> None:
        ...
    def addStaves(self, numStaves: int = 1) -> None:
        ...
    @typing.overload
    def append(self, obj: Note | Chord, position: int = -1, staveId: int = 0) -> None:
        ...
    @typing.overload
    def append(self, objs: list[Note | Chord], position: int = -1, staveId: int = 0) -> None:
        ...
    def clear(self) -> None:
        ...
    @typing.overload
    def getMeasure(self, measureId: int) -> Measure:
        ...
    @typing.overload
    def getMeasure(self, measureId: int) -> Measure:
        ...
    def getMeasures(self) -> list[Measure]:
        ...
    def getMidiUnpitched(self) -> list[int]:
        ...
    def getName(self) -> str:
        ...
    def getNumMeasures(self) -> int:
        ...
    def getNumNotes(self, staveId: int = -1) -> int:
        ...
    def getNumNotesOff(self, staveId: int = -1) -> int:
        ...
    def getNumNotesOn(self, staveId: int = -1) -> int:
        ...
    def getNumStaves(self) -> int:
        ...
    def getPartIndex(self) -> int:
        ...
    def getShortName(self) -> str:
        ...
    def getStaffLines(self) -> int:
        ...
    def info(self) -> None:
        ...
    def isPitched(self) -> bool:
        ...
    def removeMeasure(self, measureStart: int, measureEnd: int) -> None:
        ...
    def removeStave(self, staveId: int) -> None:
        ...
    def setIsPitched(self, isPitched: bool = True) -> None:
        ...
    def setNumStaves(self, numStaves: int) -> None:
        ...
    def setPartIndex(self, partIdx: int) -> None:
        ...
    def setShortName(self, shortName: str) -> None:
        ...
    def setStaffLines(self, staffLines: int = 5) -> None:
        ...
    def toJSON(self) -> str:
        ...
    def toXML(self, instrumentId: int = 1, identSize: int = 2) -> str:
        ...
class RhythmFigure:
    """
    Members:
    
      MAXIMA
    
      LONG
    
      BREVE
    
      WHOLE
    
      HALF
    
      QUARTER
    
      EIGHTH
    
      N16TH
    
      N32ND
    
      N64TH
    
      N128TH
    
      N256TH
    
      N512TH
    
      N1024TH
    """
    BREVE: typing.ClassVar[RhythmFigure]  # value = <RhythmFigure.BREVE: 2>
    EIGHTH: typing.ClassVar[RhythmFigure]  # value = <RhythmFigure.EIGHTH: 6>
    HALF: typing.ClassVar[RhythmFigure]  # value = <RhythmFigure.HALF: 4>
    LONG: typing.ClassVar[RhythmFigure]  # value = <RhythmFigure.LONG: 1>
    MAXIMA: typing.ClassVar[RhythmFigure]  # value = <RhythmFigure.MAXIMA: 0>
    N1024TH: typing.ClassVar[RhythmFigure]  # value = <RhythmFigure.N1024TH: 13>
    N128TH: typing.ClassVar[RhythmFigure]  # value = <RhythmFigure.N128TH: 10>
    N16TH: typing.ClassVar[RhythmFigure]  # value = <RhythmFigure.N16TH: 7>
    N256TH: typing.ClassVar[RhythmFigure]  # value = <RhythmFigure.N256TH: 11>
    N32ND: typing.ClassVar[RhythmFigure]  # value = <RhythmFigure.N32ND: 8>
    N512TH: typing.ClassVar[RhythmFigure]  # value = <RhythmFigure.N512TH: 12>
    N64TH: typing.ClassVar[RhythmFigure]  # value = <RhythmFigure.N64TH: 9>
    QUARTER: typing.ClassVar[RhythmFigure]  # value = <RhythmFigure.QUARTER: 5>
    WHOLE: typing.ClassVar[RhythmFigure]  # value = <RhythmFigure.WHOLE: 3>
    __members__: typing.ClassVar[dict[str, RhythmFigure]]  # value = {'MAXIMA': <RhythmFigure.MAXIMA: 0>, 'LONG': <RhythmFigure.LONG: 1>, 'BREVE': <RhythmFigure.BREVE: 2>, 'WHOLE': <RhythmFigure.WHOLE: 3>, 'HALF': <RhythmFigure.HALF: 4>, 'QUARTER': <RhythmFigure.QUARTER: 5>, 'EIGHTH': <RhythmFigure.EIGHTH: 6>, 'N16TH': <RhythmFigure.N16TH: 7>, 'N32ND': <RhythmFigure.N32ND: 8>, 'N64TH': <RhythmFigure.N64TH: 9>, 'N128TH': <RhythmFigure.N128TH: 10>, 'N256TH': <RhythmFigure.N256TH: 11>, 'N512TH': <RhythmFigure.N512TH: 12>, 'N1024TH': <RhythmFigure.N1024TH: 13>}
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Score:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __hash__(self) -> int:
        ...
    @typing.overload
    def __init__(self, partsName: list[str], numMeasures: int = 20) -> None:
        ...
    @typing.overload
    def __init__(self, filePath: str) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def addMeasure(self, numMeasures: int) -> None:
        ...
    def addPart(self, partName: str, numStaves: int = 1) -> None:
        ...
    def clear(self) -> None:
        ...
    @typing.overload
    def findMelodyPatternDataFrame(self, melodyPattern: list[Note], totalIntervalsSimilarityThreshold: float = 0.5, totalRhythmSimilarityThreshold: float = 0.5, intervalsSimilarityCallback: typing.Callable[[list[Note], list[Note]], list[float]] = None, rhythmSimilarityCallback: typing.Callable[[list[Note], list[Note]], list[float]] = None, totalIntervalSimilarityCallback: typing.Callable[[list[float]], float] = None, totalRhythmSimilarityCallback: typing.Callable[[list[float]], float] = None, totalSimilarityCallback: typing.Callable[[float, float], float] = None) -> typing.Any:
        ...
    @typing.overload
    def findMelodyPatternDataFrame(self, melodyPatterns: list[list[Note]], intervalSimilarityThreshold: float = 0.5, rhythmSimilarityThreshold: float = 0.5, intervalsSimilarityCallback: typing.Callable[[list[Note], list[Note]], list[float]] = None, rhythmSimilarityCallback: typing.Callable[[list[Note], list[Note]], list[float]] = None, totalIntervalSimilarityCallback: typing.Callable[[list[float]], float] = None, totalRhythmSimilarityCallback: typing.Callable[[list[float]], float] = None, totalSimilarityCallback: typing.Callable[[float, float], float] = None) -> typing.Any:
        ...
    def forEachNote(self, callback: typing.Callable[[Part, Measure, int, Note], None], measureStart: int = 0, measureEnd: int = -1, partNames: list[str] = []) -> None:
        ...
    def getChords(self, config: json = None) -> list[tuple[int, float, Key, Chord, bool]]:
        ...
    def getChordsDataFrame(self, config: json = None) -> typing.Any:
        ...
    def getComposerName(self) -> str:
        ...
    def getFileName(self) -> str:
        ...
    def getFilePath(self) -> str:
        ...
    def getNumMeasures(self) -> int:
        ...
    def getNumNotes(self) -> int:
        ...
    def getNumParts(self) -> int:
        ...
    @typing.overload
    def getPart(self, partId: int) -> Part:
        ...
    @typing.overload
    def getPart(self, partName: str) -> Part:
        ...
    def getPartIndex(self, partName: str, index: int) -> bool:
        ...
    def getPartName(self, partId: int) -> str:
        ...
    def getPartsNames(self) -> list[str]:
        ...
    def getTitle(self) -> str:
        ...
    def haveAnacrusisMeasure(self) -> bool:
        ...
    def info(self) -> None:
        ...
    def isValid(self) -> bool:
        ...
    def removeMeasure(self, measureStart: int, measureEnd: int) -> None:
        ...
    def removePart(self, partId: int) -> None:
        ...
    def setComposerName(self, composerName: str) -> None:
        ...
    @typing.overload
    def setKeySignature(self, fifthCicle: int, isMajorMode: bool = True, measureId: int = 0) -> None:
        ...
    @typing.overload
    def setKeySignature(self, key: str, measureId: int = 0) -> None:
        ...
    def setMetronomeMark(self, bpm: int, rhythmFigure: RhythmFigure = ..., measureStart: int = 0) -> None:
        ...
    def setRepeat(self, measureStart: int, measureEnd: int = -1) -> None:
        ...
    def setTimeSignature(self, timeUpper: int, timeLower: int, measureId: int = -1) -> None:
        ...
    def setTitle(self, scoreTitle: str) -> None:
        ...
    def toDataFrame(self) -> typing.Any:
        ...
    def toFile(self, fileName: str, compressedXML: bool = False, identSize: int = 2) -> None:
        ...
    def toJSON(self) -> str:
        ...
    def toXML(self, identSize: int = 2) -> str:
        ...
    def xPathCountNodes(self, xPath: str) -> int:
        ...
class ScoreCollection:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __add__(self, arg0: ScoreCollection) -> ScoreCollection:
        ...
    def __hash__(self) -> int:
        ...
    @typing.overload
    def __init__(self, directoryPath: str = '') -> None:
        ...
    @typing.overload
    def __init__(self, directoriesPaths: list[str] = []) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def addDirectory(self, directoryPath: str) -> None:
        ...
    @typing.overload
    def addScore(self, score: Score) -> None:
        ...
    @typing.overload
    def addScore(self, filePath: str) -> None:
        ...
    @typing.overload
    def addScore(self, filePaths: list[str]) -> None:
        ...
    def clear(self) -> None:
        ...
    @typing.overload
    def findMelodyPatternDataFrame(self, melodyPattern: list[Note], totalIntervalsSimilarityThreshold: float = 0.5, totalRhythmSimilarityThreshold: float = 0.5, intervalsSimilarityCallback: typing.Callable[[list[Note], list[Note]], list[float]] = None, rhythmSimilarityCallback: typing.Callable[[list[Note], list[Note]], list[float]] = None, totalIntervalSimilarityCallback: typing.Callable[[list[float]], float] = None, totalRhythmSimilarityCallback: typing.Callable[[list[float]], float] = None, totalSimilarityCallback: typing.Callable[[float, float], float] = None) -> typing.Any:
        ...
    @typing.overload
    def findMelodyPatternDataFrame(self, melodyPatterns: list[list[Note]], totalIntervalsSimilarityThreshold: float = 0.5, totalRhythmSimilarityThreshold: float = 0.5, intervalsSimilarityCallback: typing.Callable[[list[Note], list[Note]], list[float]] = None, rhythmSimilarityCallback: typing.Callable[[list[Note], list[Note]], list[float]] = None, totalIntervalSimilarityCallback: typing.Callable[[list[float]], float] = None, totalRhythmSimilarityCallback: typing.Callable[[list[float]], float] = None, totalSimilarityCallback: typing.Callable[[float, float], float] = None) -> typing.Any:
        ...
    def getDirectoriesPaths(self) -> list[str]:
        ...
    def getNumDirectories(self) -> int:
        ...
    def getNumScores(self) -> int:
        ...
    @typing.overload
    def getScores(self) -> list[Score]:
        ...
    @typing.overload
    def getScores(self) -> list[Score]:
        ...
    def isEmpty(self) -> bool:
        ...
    def merge(self, other: ScoreCollection) -> None:
        ...
    def removeScore(self, scoreIdx: int) -> None:
        ...
    def setDirectoriesPaths(self, directoriesPaths: list[str]) -> None:
        ...
class TimeSignature:
    @staticmethod
    def _pybind11_conduit_v1_(*args, **kwargs):
        ...
    def __init__(self, timeUpper: int = 4, timeLower: int = 4) -> None:
        ...
    def getLowerValue(self) -> int:
        ...
    def getMetric(self) -> METRIC:
        ...
    def getUpperValue(self) -> int:
        ...
    def setLowerValue(self, timeLower: int) -> None:
        ...
    def setUpperValue(self, timeUpper: int) -> None:
        ...
C: ClefSign  # value = <ClefSign.C: 2>
F: ClefSign  # value = <ClefSign.F: 1>
G: ClefSign  # value = <ClefSign.G: 0>
P: ClefSign  # value = <ClefSign.P: 3>
__version__: str = '"1.9.5"'
