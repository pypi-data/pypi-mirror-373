# **Product Requirements Document (PRD)**

**Package Name for Display:** MorphCards

**Package Name in pypi (import name):** morphcards

**Author Full Name:** Felipe Campos Penha

**Author GitHub Profile:** felipepenha

**Author E-mail Address:** felipe.penha@alumni.usp.br

**Status:** Approved

## 

## **1\. Introduction/Overview**

Spaced Spatial Repetition (SSR) software, in particular when applied to Language Learning, is often based on the repetition of the exact same sentence cards\* over and over. To the point that the users memorize the front of the cards and are unable to identify the same word in a different sentence later on. This kills the purpose of the method, since learners struggle to apply the language to their real-life experience. 

\* A sentence card is a flashcard that teaches a new word or concept within a full sentence. 

## 

## **2\. Goals & Objectives**

* **Goal 1:** To reproduce the functionality of traditional SSR software, but now focused on sentence cards for language learning.  
* **Goal 2:** Each time a card for a given word is reviewed, it displays a different sentence to the user where that word is used.  
* **Goal 3:** The content of each new sentence in a card is constrained to the learned vocabulary up to that point.

## 

## 

## **3\. Target Audience**

Language Learners.

## **4\. User Stories/Use Cases**

* **As a language learner (end user)**, I want to see a new sentence on the front of a sentence card each time I need to revisit that card (based on the SSR cycle), so that I can learn to identify the same word, with the same meaning, in different sentences. I would like those sentences (1) to be contained within my learned vocabulary, (2) to be grammarly correct, and (3) to sound natural to a native speaker of that language.  
* **As a UI developer**, I do not want to worry about integrating traditional SSR software that feeds my UI to an LLM API to be able to change the content of the sentence cards dynamically. I would like to have results ready to display at the package-level.

## 

## **5\. Functional Requirements**

* **Core Functionality:**  
  * \[Feature 1\]: Traditional SSR functionality based on FSRS (Free Spaced Repetition Scheduler). May use the fsrs python package.  
  * \[Feature 2\]: In-memory database to store learned vocabulary. May use DuckDB.   
  * \[Feature 3\]: Integration to an LLM API of choice by providing credentials, e.g. Gemini.  
  * \[Feature 4\]: When stored vocabulary is too short, the output sentence falls back to the originally stored sentence.


* **User Interface (CLI/API):**

**The FSRS Scheduler**

The scheduler is the primary component for day-to-day operations.

It takes a card's current state and a user's rating to calculate the next optimal review date.

The following set of requirements is adapted from the fsrs python package (pypi). Changes highlighted in yellow.

#### **Inputs**

| Parameter | Type | Description |
| :---- | :---- | :---- |
| card | Card object | An object representing the flashcard's current state. This object must contain properties for **stability**, **difficulty**, the **due\_date, word, and sentence (sentence originally stored upon card creation)**. |
| rating | int or Rating enum | The user's subjective rating of their recall. The standard integer values are: 1 (Again), 2 (Hard), 3 (Good), and 4 (Easy). |
| now | datetime object | The precise date and time of the current review. This is crucial for calculating the time elapsed since the last review. |
| parameters | list or array | A set of numerical weights that govern the algorithm's behavior. While default parameters are included, a personalized set generated by the optimizer is recommended for optimal performance. |
| ai\_api\_key | str | **Required API key for the AI service** (e.g., Google's Gemini API). This credential authenticates the application's requests for content generation. |

#### **Outputs**

| Output | Type | Description |
| :---- | :---- | :---- |
| new\_card | Card object | An updated card object with its new stability and difficulty scores. This object also includes the new\_due\_date for the next review and the new sentence generated by AI. |
| review\_log | ReviewLog object | A record of the completed review. This is returned to the host application for storage and includes the timestamp, rating, and interval of the review. |

### The FSRS Optimizer (Optional)

The optimizer is a separate tool designed to analyze a user's complete review history and generate a personalized set of parameters for the scheduler.

This is a one-time or infrequent process that fine-tunes the algorithm to a user's unique memory characteristics.

#### **Inputs**

| Parameter | Type | Description |
| :---- | :---- | :---- |
| review\_history | list of objects | A collection of all past review logs for a user. Each log must contain card\_id, review\_time, and review\_rating. |
| timezone | str or object | The user's time zone. This is used to correctly handle daily review cycles, especially for users who review across a day-change boundary. |
| desired\_retention | float | A user-controlled value, typically between 0.80 and 0.95, that allows FSRS to balance retention goals with daily workload. |

#### **Output**

| Output | Type | Description |
| :---- | :---- | :---- |
| optimal\_parameters | list or array | A list of numerical weights that are optimized to provide the most efficient review schedule for the given review history. These are the parameters you would feed into the scheduler.review\_card() method. |

## **6\. Technical Requirements & Constraints**

This section outlines the technical details and limitations of the project.

* **Language & Environment:**  
  * The package must be developed in **Python** to be hosted at pypi.  
* **Dependencies:**  
  * fsrs  
  * duckdb  
  * requests, gemini.  
* **API Usage:**  
  * The package must handle authentication with the LLM APIs (e.g., using API keys).
  * It must manage API rate limits and handle potential errors gracefully.  
* **Performance:**  
  * The package should be performant for its intended use cases, i.e. API calls should not exceed 1 second.

* **Scalability:**  
  * The architecture should be designed to handle future feature additions without major refactoring.

## **7\. Non-Functional Requirements**

These are the qualities the package should have.

* **Usability:** The public API should be intuitive and well-documented.  
* **Reliability:** The package should be stable and handle unexpected inputs or API errors without crashing.  
* **Maintainability:** The code should be well-commented and easy for others to understand and modify.  
* **Testing:** The package must have a comprehensive suite of unit and integration tests.

## **8\. Out of Scope**

What will this package **not** do?

Listing these helps prevent "scope creep"

* \[Feature 1\]: Generate images.  
* \[Feature 2\]: Generate explanations.