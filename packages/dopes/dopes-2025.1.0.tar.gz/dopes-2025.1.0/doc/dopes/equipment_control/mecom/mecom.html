<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>dopes.equipment_control.mecom.mecom API documentation</title>
<meta name="description" content="&#34;
The magic happens in this file.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dopes.equipment_control.mecom.mecom</code></h1>
</header>
<section id="section-intro">
<p>"
The magic happens in this file.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dopes.equipment_control.mecom.mecom.ACK"><code class="flex name class">
<span>class <span class="ident">ACK</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ACK(MeFrame):
    &#34;&#34;&#34;
    ACK command sent by the device.
    &#34;&#34;&#34;
    _SOURCE = &#34;!&#34;
    
    def decompose(self, frame_bytes):
        &#34;&#34;&#34;
        Takes bytes as input and builds the instance.
        :param frame_bytes: bytes
        :return:
        &#34;&#34;&#34;
        frame_bytes = self._SOURCE.encode() + frame_bytes
        self._decompose_header(frame_bytes)
        
        frame = frame_bytes.decode()
        self.CRC = int(frame[-4:], 16)</code></pre>
</details>
<div class="desc"><p>ACK command sent by the device.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dopes.equipment_control.mecom.mecom.MeFrame" href="#dopes.equipment_control.mecom.mecom.MeFrame">MeFrame</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dopes.equipment_control.mecom.mecom.ACK.decompose"><code class="name flex">
<span>def <span class="ident">decompose</span></span>(<span>self, frame_bytes)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decompose(self, frame_bytes):
    &#34;&#34;&#34;
    Takes bytes as input and builds the instance.
    :param frame_bytes: bytes
    :return:
    &#34;&#34;&#34;
    frame_bytes = self._SOURCE.encode() + frame_bytes
    self._decompose_header(frame_bytes)
    
    frame = frame_bytes.decode()
    self.CRC = int(frame[-4:], 16)</code></pre>
</details>
<div class="desc"><p>Takes bytes as input and builds the instance.
:param frame_bytes: bytes
:return:</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dopes.equipment_control.mecom.mecom.MeFrame" href="#dopes.equipment_control.mecom.mecom.MeFrame">MeFrame</a></b></code>:
<ul class="hlist">
<li><code><a title="dopes.equipment_control.mecom.mecom.MeFrame.CalcCRC_CCITT" href="#dopes.equipment_control.mecom.mecom.MeFrame.CalcCRC_CCITT">CalcCRC_CCITT</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeFrame.compose" href="#dopes.equipment_control.mecom.mecom.MeFrame.compose">compose</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeFrame.crc" href="#dopes.equipment_control.mecom.mecom.MeFrame.crc">crc</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.DeviceError"><code class="flex name class">
<span>class <span class="ident">DeviceError</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeviceError(MeFrame):
    &#34;&#34;&#34;
    Queries failing return a device error, implemented as repsonse by this class.
    &#34;&#34;&#34;
    _SOURCE = &#34;!&#34;

    def __init__(self):
        &#34;&#34;&#34;
        Read error codes from command.py and parse into a list of Error() instances.
        &#34;&#34;&#34;
        super(DeviceError, self).__init__()
        self._ERRORS = []
        for error in ERRORS:
            self._ERRORS.append(Error(error))

    def _get_by_code(self, code):
        &#34;&#34;&#34;
        Returns a Error() identified by it&#39;s error code.
        :param code: int
        :return: Error()
        &#34;&#34;&#34;
        for error in self._ERRORS:
            if error.code == code:
                return error
        # we do not need to raise here since error are well defined

    def compose(self, part=False):
        &#34;&#34;&#34;
        Device errors have a different but simple structure.
        :param part: bool
        :return:
        &#34;&#34;&#34;
        # first part
        frame = self._SOURCE + &#34;{:02X}&#34;.format(self.ADDRESS) + &#34;{:04X}&#34;.format(self.SEQUENCE)
        # payload is [&#39;+&#39;, #_of_error]
        frame += self.PAYLOAD[0]
        frame += &#34;{:02x}&#34;.format(self.PAYLOAD[1])
        # if we only want a partial frame, return here
        if part:
            return frame.encode()
        # add checksum
        if self.CRC is None:
            self.crc()
        frame += &#34;{:04X}&#34;.format(self.CRC)
        # add end of line (carriage return)
        frame += self._EOL
        return frame.encode()

    def decompose(self, frame_bytes):
        &#34;&#34;&#34;
        Again, different but consistent structure.
        :param frame_bytes: bytes
        :return:
        &#34;&#34;&#34;
        frame_bytes = self._SOURCE.encode() + frame_bytes
        self._decompose_header(frame_bytes)
        frame = frame_bytes.decode()
        self.PAYLOAD.append(frame[7])
        self.PAYLOAD.append(int(frame[8:10], 16))
        self.crc(int(frame[-4:], 16))

    def error(self):
        &#34;&#34;&#34;
        Returns error code, description and symbol as [str,].
        :return: [str, str, str]
        &#34;&#34;&#34;
        error_code = self.PAYLOAD[1]
        # returns [code, description, symbol]
        return self._get_by_code(error_code).as_list()</code></pre>
</details>
<div class="desc"><p>Queries failing return a device error, implemented as repsonse by this class.</p>
<p>Read error codes from command.py and parse into a list of Error() instances.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dopes.equipment_control.mecom.mecom.MeFrame" href="#dopes.equipment_control.mecom.mecom.MeFrame">MeFrame</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dopes.equipment_control.mecom.mecom.DeviceError.compose"><code class="name flex">
<span>def <span class="ident">compose</span></span>(<span>self, part=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compose(self, part=False):
    &#34;&#34;&#34;
    Device errors have a different but simple structure.
    :param part: bool
    :return:
    &#34;&#34;&#34;
    # first part
    frame = self._SOURCE + &#34;{:02X}&#34;.format(self.ADDRESS) + &#34;{:04X}&#34;.format(self.SEQUENCE)
    # payload is [&#39;+&#39;, #_of_error]
    frame += self.PAYLOAD[0]
    frame += &#34;{:02x}&#34;.format(self.PAYLOAD[1])
    # if we only want a partial frame, return here
    if part:
        return frame.encode()
    # add checksum
    if self.CRC is None:
        self.crc()
    frame += &#34;{:04X}&#34;.format(self.CRC)
    # add end of line (carriage return)
    frame += self._EOL
    return frame.encode()</code></pre>
</details>
<div class="desc"><p>Device errors have a different but simple structure.
:param part: bool
:return:</p></div>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.DeviceError.decompose"><code class="name flex">
<span>def <span class="ident">decompose</span></span>(<span>self, frame_bytes)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decompose(self, frame_bytes):
    &#34;&#34;&#34;
    Again, different but consistent structure.
    :param frame_bytes: bytes
    :return:
    &#34;&#34;&#34;
    frame_bytes = self._SOURCE.encode() + frame_bytes
    self._decompose_header(frame_bytes)
    frame = frame_bytes.decode()
    self.PAYLOAD.append(frame[7])
    self.PAYLOAD.append(int(frame[8:10], 16))
    self.crc(int(frame[-4:], 16))</code></pre>
</details>
<div class="desc"><p>Again, different but consistent structure.
:param frame_bytes: bytes
:return:</p></div>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.DeviceError.error"><code class="name flex">
<span>def <span class="ident">error</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error(self):
    &#34;&#34;&#34;
    Returns error code, description and symbol as [str,].
    :return: [str, str, str]
    &#34;&#34;&#34;
    error_code = self.PAYLOAD[1]
    # returns [code, description, symbol]
    return self._get_by_code(error_code).as_list()</code></pre>
</details>
<div class="desc"><p>Returns error code, description and symbol as [str,].
:return: [str, str, str]</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dopes.equipment_control.mecom.mecom.MeFrame" href="#dopes.equipment_control.mecom.mecom.MeFrame">MeFrame</a></b></code>:
<ul class="hlist">
<li><code><a title="dopes.equipment_control.mecom.mecom.MeFrame.CalcCRC_CCITT" href="#dopes.equipment_control.mecom.mecom.MeFrame.CalcCRC_CCITT">CalcCRC_CCITT</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeFrame.crc" href="#dopes.equipment_control.mecom.mecom.MeFrame.crc">crc</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.Error"><code class="flex name class">
<span>class <span class="ident">Error</span></span>
<span>(</span><span>error_dict)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Error(object):
    &#34;&#34;&#34;&#34;
    Every error dict from commands.py is parsed into a Error instance.
    &#34;&#34;&#34;

    def __init__(self, error_dict):
        &#34;&#34;&#34;
        Takes a dict e.g. {&#34;code&#34;: 1, &#34;symbol&#34;: &#34;EER_CMD_NOT_AVAILABLE&#34;, &#34;description&#34;: &#34;Command not available&#34;} which
        defines a error specified by the protocol.
        :param error_dict: dict
        &#34;&#34;&#34;
        self.code = error_dict[&#34;code&#34;]
        self.symbol = error_dict[&#34;symbol&#34;]
        self.description = error_dict[&#34;description&#34;]

    def as_list(self):
        &#34;&#34;&#34;
        Returns a list representation of this object.
        :return: list
        &#34;&#34;&#34;
        return [self.code, self.description, self.symbol]</code></pre>
</details>
<div class="desc"><p>"
Every error dict from commands.py is parsed into a Error instance.</p>
<p>Takes a dict e.g. {"code": 1, "symbol": "EER_CMD_NOT_AVAILABLE", "description": "Command not available"} which
defines a error specified by the protocol.
:param error_dict: dict</p></div>
<h3>Methods</h3>
<dl>
<dt id="dopes.equipment_control.mecom.mecom.Error.as_list"><code class="name flex">
<span>def <span class="ident">as_list</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_list(self):
    &#34;&#34;&#34;
    Returns a list representation of this object.
    :return: list
    &#34;&#34;&#34;
    return [self.code, self.description, self.symbol]</code></pre>
</details>
<div class="desc"><p>Returns a list representation of this object.
:return: list</p></div>
</dd>
</dl>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.IF"><code class="flex name class">
<span>class <span class="ident">IF</span></span>
<span>(</span><span>address=0, parameter_instance=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IF(Query):
    &#34;&#34;&#34;
    Implementing device info query.
    &#34;&#34;&#34;
    _PAYLOAD_START = &#39;?IF&#39;

    def __init__(self, address=0, parameter_instance=1):
        &#34;&#34;&#34;
        Create a query to set a parameter value.
        :param address: int
        :param parameter_instance: int
        &#34;&#34;&#34;
        
        # init header (equal for get and set queries)
        super(IF, self).__init__(parameter=None,
                         address=address,
                         parameter_instance=parameter_instance)

        # no need to initialize response format, we want ACK</code></pre>
</details>
<div class="desc"><p>Implementing device info query.</p>
<p>Create a query to set a parameter value.
:param address: int
:param parameter_instance: int</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dopes.equipment_control.mecom.mecom.Query" href="#dopes.equipment_control.mecom.mecom.Query">Query</a></li>
<li><a title="dopes.equipment_control.mecom.mecom.MeFrame" href="#dopes.equipment_control.mecom.mecom.MeFrame">MeFrame</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dopes.equipment_control.mecom.mecom.Query" href="#dopes.equipment_control.mecom.mecom.Query">Query</a></b></code>:
<ul class="hlist">
<li><code><a title="dopes.equipment_control.mecom.mecom.Query.CalcCRC_CCITT" href="#dopes.equipment_control.mecom.mecom.MeFrame.CalcCRC_CCITT">CalcCRC_CCITT</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.Query.compose" href="#dopes.equipment_control.mecom.mecom.MeFrame.compose">compose</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.Query.crc" href="#dopes.equipment_control.mecom.mecom.MeFrame.crc">crc</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.Query.set_response" href="#dopes.equipment_control.mecom.mecom.Query.set_response">set_response</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.IFResponse"><code class="flex name class">
<span>class <span class="ident">IFResponse</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IFResponse(MeFrame):
    &#34;&#34;&#34;
    ACK command sent by the device.
    &#34;&#34;&#34;
    _SOURCE = &#34;!&#34;

    def crc(self, in_crc=None):
        &#34;&#34;&#34;
        ACK has the same checksum as the VS command.
        :param in_crc: int
        :return:
        &#34;&#34;&#34;
        pass

    def decompose(self, frame_bytes):
        &#34;&#34;&#34;
        Takes bytes as input and builds the instance.
        :param frame_bytes: bytes
        :return:
        &#34;&#34;&#34;
        frame_bytes = self._SOURCE.encode() + frame_bytes
        self._decompose_header(frame_bytes)

        frame = frame_bytes.decode()
        self.PAYLOAD = frame[7:-4]
        self.CRC = int(frame[-4:], 16)</code></pre>
</details>
<div class="desc"><p>ACK command sent by the device.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dopes.equipment_control.mecom.mecom.MeFrame" href="#dopes.equipment_control.mecom.mecom.MeFrame">MeFrame</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dopes.equipment_control.mecom.mecom.IFResponse.crc"><code class="name flex">
<span>def <span class="ident">crc</span></span>(<span>self, in_crc=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crc(self, in_crc=None):
    &#34;&#34;&#34;
    ACK has the same checksum as the VS command.
    :param in_crc: int
    :return:
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>ACK has the same checksum as the VS command.
:param in_crc: int
:return:</p></div>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.IFResponse.decompose"><code class="name flex">
<span>def <span class="ident">decompose</span></span>(<span>self, frame_bytes)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decompose(self, frame_bytes):
    &#34;&#34;&#34;
    Takes bytes as input and builds the instance.
    :param frame_bytes: bytes
    :return:
    &#34;&#34;&#34;
    frame_bytes = self._SOURCE.encode() + frame_bytes
    self._decompose_header(frame_bytes)

    frame = frame_bytes.decode()
    self.PAYLOAD = frame[7:-4]
    self.CRC = int(frame[-4:], 16)</code></pre>
</details>
<div class="desc"><p>Takes bytes as input and builds the instance.
:param frame_bytes: bytes
:return:</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dopes.equipment_control.mecom.mecom.MeFrame" href="#dopes.equipment_control.mecom.mecom.MeFrame">MeFrame</a></b></code>:
<ul class="hlist">
<li><code><a title="dopes.equipment_control.mecom.mecom.MeFrame.CalcCRC_CCITT" href="#dopes.equipment_control.mecom.mecom.MeFrame.CalcCRC_CCITT">CalcCRC_CCITT</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeFrame.compose" href="#dopes.equipment_control.mecom.mecom.MeFrame.compose">compose</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.MeCom"><code class="flex name class">
<span>class <span class="ident">MeCom</span></span>
<span>(</span><span>serialport='/dev/ttyUSB0', timeout=1, baudrate=57600, metype='TEC')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MeCom(MeComSerial):
    &#34;&#34;&#34;
    Deprecated. Use MeComSerial instead.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Deprecated. Use MeComSerial instead.</p>
<p>Initialize communication with serial port.
:param serialport: str: Linux example: '/dev/ttyUSB0', Windows example: 'COM1'
:param timeout: int
:param metype: str: either 'TEC', 'LDD-112x', 'LDD-130x' or 'LDD-1321'</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dopes.equipment_control.mecom.mecom.MeComSerial" href="#dopes.equipment_control.mecom.mecom.MeComSerial">MeComSerial</a></li>
<li><a title="dopes.equipment_control.mecom.mecom.MeComCommon" href="#dopes.equipment_control.mecom.mecom.MeComCommon">MeComCommon</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dopes.equipment_control.mecom.mecom.MeComSerial" href="#dopes.equipment_control.mecom.mecom.MeComSerial">MeComSerial</a></b></code>:
<ul class="hlist">
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComSerial.get_parameter" href="#dopes.equipment_control.mecom.mecom.MeComCommon.get_parameter">get_parameter</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComSerial.get_parameter_raw" href="#dopes.equipment_control.mecom.mecom.MeComCommon.get_parameter_raw">get_parameter_raw</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComSerial.info" href="#dopes.equipment_control.mecom.mecom.MeComCommon.info">info</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComSerial.reset_device" href="#dopes.equipment_control.mecom.mecom.MeComCommon.reset_device">reset_device</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComSerial.set_parameter" href="#dopes.equipment_control.mecom.mecom.MeComCommon.set_parameter">set_parameter</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComSerial.set_parameter_raw" href="#dopes.equipment_control.mecom.mecom.MeComCommon.set_parameter_raw">set_parameter_raw</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComSerial.status" href="#dopes.equipment_control.mecom.mecom.MeComCommon.status">status</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComSerial.trigger_save_to_flash" href="#dopes.equipment_control.mecom.mecom.MeComCommon.trigger_save_to_flash">trigger_save_to_flash</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComSerial.write_to_flash" href="#dopes.equipment_control.mecom.mecom.MeComCommon.write_to_flash">write_to_flash</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.MeComCommon"><code class="flex name class">
<span>class <span class="ident">MeComCommon</span></span>
<span>(</span><span>metype='TEC')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MeComCommon:
    &#34;&#34;&#34;
    Shared communication class
    &#34;&#34;&#34;
    SEQUENCE_COUNTER = 1

    def __init__(self, metype=&#39;TEC&#39;):
        &#34;&#34;&#34;
        Initialize communication with serial port.
        :param serialport: str
        :param timeout: int
        :param metype: str: either &#39;TEC&#39;, &#39;LDD-112x&#39;, &#39;LDD-130x&#39; or &#39;LDD-1321&#39;
        &#34;&#34;&#34;
        self.lock = Lock()

        # initialize parameters
        self.PARAMETERS = ParameterList(metype)

    def _find_parameter(self, parameter_name, parameter_id):
        &#34;&#34;&#34;
        Return Parameter() with either name or id given.
        :param parameter_name: str
        :param parameter_id: int
        :return: Parameter
        &#34;&#34;&#34;
        assert parameter_name is not None or parameter_id is not None

        return self.PARAMETERS.get_by_name(parameter_name) if parameter_name is not None\
            else self.PARAMETERS.get_by_id(parameter_id)

    def _inc(self):
        self.SEQUENCE_COUNTER += 1
        # sequence in controller is int16 and overflows 
        self.SEQUENCE_COUNTER = self.SEQUENCE_COUNTER % (2**16)

    @staticmethod
    def _raise(query):
        &#34;&#34;&#34;
        If DeviceError is received, raise!
        :param query: VR or VS
        :return:
        &#34;&#34;&#34;
        # did we encounter an error?
        if type(query.RESPONSE) is DeviceError:
            code, description, symbol = query.RESPONSE.error()
            raise ResponseException(&#34;device {} raised {}&#34;.format(query.RESPONSE.ADDRESS, description))

    def _get(self, parameter_name=None, parameter_id=None, *args, **kwargs):
        &#34;&#34;&#34;
        Get a query object for a VR command.
        :param parameter_name:
        :param parameter_id:
        :param args:
        :param kwargs:
        :return:
        &#34;&#34;&#34;

        # search in DataFrame returns a dict
        parameter = self._find_parameter(parameter_name, parameter_id)

        # execute query
        vr = self._execute(VR(parameter=parameter, *args, **kwargs))

        # print(vr.PAYLOAD)
        # print(vr.RESPONSE.PAYLOAD)
        # return the query with response
        return vr

    def _get_raw(self, parameter_id, parameter_format, *args, **kwargs):
        &#34;&#34;&#34;
        Get a query object for a VR command (raw version).
        :param parameter:
        :param args:
        :param kwargs:
        :return:
        &#34;&#34;&#34;

        # construct from raw id and format specifier
        parameter = Parameter({&#34;id&#34;: parameter_id, &#34;name&#34;: None, &#34;format&#34;: parameter_format})

        # execute query
        vr = self._execute(VR(parameter=parameter, *args, **kwargs))

        # print(vr.PAYLOAD)
        # print(vr.RESPONSE.PAYLOAD)
        # return the query with response
        return vr

    def _set(self, value, parameter_name=None, parameter_id=None, *args, **kwargs):
        &#34;&#34;&#34;
        Get a query object for a VS command.
        :param value:
        :param parameter_name:
        :param parameter_id:
        :param args:
        :param kwargs:
        :return:
        &#34;&#34;&#34;

        # search in DataFrame returns a dict
        parameter = self._find_parameter(parameter_name, parameter_id)

        # execute query
        vs = self._execute(VS(value=value, parameter=parameter, *args, **kwargs))

        # return the query with response
        return vs

    def _set_raw(self, value, parameter_id, parameter_format, *args, **kwargs):
        &#34;&#34;&#34;
        Get a query object for a VS command (raw version).
        :param value:
        :param parameter:
        :param args:
        :param kwargs:
        :return:
        &#34;&#34;&#34;

        # construct from raw id and format specifier
        parameter = Parameter({&#34;id&#34;: parameter_id, &#34;name&#34;: None, &#34;format&#34;: parameter_format})

        # execute query
        vs = self._execute(VS(value=value, parameter=parameter, *args, **kwargs))

        # return the query with response
        return vs

    def get_parameter(self, parameter_name=None, parameter_id=None, *args, **kwargs):
        &#34;&#34;&#34;
        Get the value of a parameter given by name or id.
        Returns a list of success and value.
        :param parameter_name:
        :param parameter_id:
        :param args:
        :param kwargs:
        :return: int or float
        &#34;&#34;&#34;
        # get the query object
        vr = self._get(parameter_id=parameter_id, parameter_name=parameter_name, *args, **kwargs)

        return vr.RESPONSE.PAYLOAD[0]

    def get_parameter_raw(self, parameter_id, parameter_format, *args, **kwargs):
        &#34;&#34;&#34;
        Get the value of a parameter given by its id and format specifier.
        note: use get_parameter() if you only want to use known commands
        Returns a list of success and value.
        :param parameter:
        :param args:
        :param kwargs:
        :return: int or float
        &#34;&#34;&#34;
        # get the query object
        vr = self._get_raw(parameter_id=parameter_id, parameter_format=parameter_format, *args, **kwargs)

        return vr.RESPONSE.PAYLOAD[0]

    def set_parameter(self, value, parameter_name=None, parameter_id=None, *args, **kwargs):
        &#34;&#34;&#34;
        Set the new value of a parameter given by name or id.
        Returns success.
        :param value:
        :param parameter_name:
        :param parameter_id:
        :param args:
        :param kwargs:
        :return: bool
        &#34;&#34;&#34;
        # get the query object
        vs = self._set(value=value, parameter_id=parameter_id, parameter_name=parameter_name, *args, **kwargs)

        # check if value setting has succeeded
        #
        # Not necessary as we get an acknowledge response or Value is out of range
        # exception when an invalid value was passed. 
        # current implementation also often fails due to rounding, e.g. setting 1.0
        # but returning 0.999755859375 when performing a self.get_parameter
        # value_set = self.get_parameter(parameter_id=parameter_id, parameter_name=parameter_name, *args, **kwargs)

        # return True if we got an ACK
        return type(vs.RESPONSE) == ACK

    def set_parameter_raw(self, value, parameter_id, parameter_format, *args, **kwargs):
        &#34;&#34;&#34;
        Set the new value of a parameter given by its id and format specifier.
        note: use set_parameter() if you only want to use known commands
        Returns success.
        :param value:
        :param parameter:
        :param args:
        :param kwargs:
        :return: bool
        &#34;&#34;&#34;
        # get the query object
        vs = self._set_raw(value=value, parameter_id=parameter_id, parameter_format=parameter_format, *args, **kwargs)

        # check if value setting has succeeded
        #
        # Not necessary as we get an acknowledge response or Value is out of range
        # exception when an invalid value was passed. 
        # current implementation also often fails due to rounding, e.g. setting 1.0
        # but returning 0.999755859375 when performing a self.get_parameter
        # value_set = self.get_parameter(parameter_id=parameter_id, parameter_name=parameter_name, *args, **kwargs)

        # return True if we got an ACK
        return type(vs.RESPONSE) == ACK
    
    def reset_device(self,*args, **kwargs):
        &#34;&#34;&#34;
        Resets the device after an error has occured
        &#34;&#34;&#34;
        rs = self._execute(RS(*args, **kwargs))
        return type(rs.RESPONSE) == ACK
    
    def info(self,*args, **kwargs):
        &#34;&#34;&#34;
        Resets the device after an error has occured
        &#34;&#34;&#34;
        info = self._execute(IF(*args, **kwargs))
        return info.RESPONSE.PAYLOAD


    # returns device address
    identify = partialmethod(get_parameter, parameter_name=&#34;Device Address&#34;)
    &#34;&#34;&#34;
    Returns success and device address as int.
    &#34;&#34;&#34;

    def status(self, *args, **kwargs):
        &#34;&#34;&#34;
        Get the device status.
        Returns success and status as readable str.
        :param args:
        :param kwargs:
        :return: [bool, str]
        &#34;&#34;&#34;
        # query device status
        status_id = self.get_parameter(parameter_name=&#34;Device Status&#34;, *args, **kwargs)

        if status_id == 0:
            status_name = &#34;Init&#34;
        elif status_id == 1:
            status_name = &#34;Ready&#34;
        elif status_id == 2:
            status_name = &#34;Run&#34;
        elif status_id == 3:
            status_name = &#34;Error&#34;
        elif status_id == 4:
            status_name = &#34;Bootloader&#34;
        elif status_id == 5:
            status_name = &#34;Device will Reset within next 200ms&#34;
        else:
            status_name = &#34;Unknown&#34;

        # return address and status
        return status_name
    
    # enable or disable auto saving to flash
    enable_autosave = partialmethod(set_parameter, value=0, parameter_name=&#34;Save Data to Flash&#34;)
    disable_autosave = partialmethod(set_parameter, value=1, parameter_name=&#34;Save Data to Flash&#34;)

    def write_to_flash(self, *args, **kwargs):
        &#34;&#34;&#34;
        Write parameters to flash.
        Note: This function only works on:
         - TEC Controllers using a firmware &lt; v6.00
         - LDD-130x devices with a firmware &lt; v2.00
         - LDD-112x devices on any firmware
        for devices not listed here, refer to the device documentation
        and check whether the old automatic flash saving mechanism
        is used on your device
        :param args:
        :param kwargs:
        :return: bool
        &#34;&#34;&#34;
        self.enable_autosave()
        timer_start = time.time()

        # value 0 means &#34;All Parameters are saved to Flash&#34;
        while self.get_parameter(parameter_name=&#34;Flash Status&#34;) != 0:
            # check for timeout
            if time.time() - timer_start &gt; 10:
                raise ResponseTimeout(&#34;writing to flash timed out!&#34;)
            time.sleep(0.5)

        self.disable_autosave()

        return True

    def trigger_save_to_flash(self, *args, **kwargs):
        &#34;&#34;&#34;
        Writes all parameter values to the flash of the device.
        Note: This function only works on:
         - TEC Controllers using a firmware &gt;= v6.00
         - LDD-130x devices with a firmware &gt;= v2.00
         - LDD-1321 devices on any firmware
        for devices not listed here, refer to the device documentation
        and check whether the new explicit flash saving mechanism
        is used on your device
        &#34;&#34;&#34;
        rs = self._execute(SP(*args, **kwargs))
        return type(rs.RESPONSE) == ACK</code></pre>
</details>
<div class="desc"><p>Shared communication class</p>
<p>Initialize communication with serial port.
:param serialport: str
:param timeout: int
:param metype: str: either 'TEC', 'LDD-112x', 'LDD-130x' or 'LDD-1321'</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="dopes.equipment_control.mecom.mecom.MeComSerial" href="#dopes.equipment_control.mecom.mecom.MeComSerial">MeComSerial</a></li>
<li><a title="dopes.equipment_control.mecom.mecom.MeComTcp" href="#dopes.equipment_control.mecom.mecom.MeComTcp">MeComTcp</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="dopes.equipment_control.mecom.mecom.MeComCommon.SEQUENCE_COUNTER"><code class="name">var <span class="ident">SEQUENCE_COUNTER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dopes.equipment_control.mecom.mecom.MeComCommon.disable_autosave"><code class="name flex">
<span>def <span class="ident">disable_autosave</span></span>(<span>self, *, value=1, parameter_name='Save Data to Flash', parameter_id=None, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _method(cls_or_self, /, *args, **keywords):
    keywords = {**self.keywords, **keywords}
    return self.func(cls_or_self, *self.args, *args, **keywords)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.MeComCommon.enable_autosave"><code class="name flex">
<span>def <span class="ident">enable_autosave</span></span>(<span>self, *, value=0, parameter_name='Save Data to Flash', parameter_id=None, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _method(cls_or_self, /, *args, **keywords):
    keywords = {**self.keywords, **keywords}
    return self.func(cls_or_self, *self.args, *args, **keywords)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.MeComCommon.get_parameter"><code class="name flex">
<span>def <span class="ident">get_parameter</span></span>(<span>self, parameter_name=None, parameter_id=None, *args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_parameter(self, parameter_name=None, parameter_id=None, *args, **kwargs):
    &#34;&#34;&#34;
    Get the value of a parameter given by name or id.
    Returns a list of success and value.
    :param parameter_name:
    :param parameter_id:
    :param args:
    :param kwargs:
    :return: int or float
    &#34;&#34;&#34;
    # get the query object
    vr = self._get(parameter_id=parameter_id, parameter_name=parameter_name, *args, **kwargs)

    return vr.RESPONSE.PAYLOAD[0]</code></pre>
</details>
<div class="desc"><p>Get the value of a parameter given by name or id.
Returns a list of success and value.
:param parameter_name:
:param parameter_id:
:param args:
:param kwargs:
:return: int or float</p></div>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.MeComCommon.get_parameter_raw"><code class="name flex">
<span>def <span class="ident">get_parameter_raw</span></span>(<span>self, parameter_id, parameter_format, *args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_parameter_raw(self, parameter_id, parameter_format, *args, **kwargs):
    &#34;&#34;&#34;
    Get the value of a parameter given by its id and format specifier.
    note: use get_parameter() if you only want to use known commands
    Returns a list of success and value.
    :param parameter:
    :param args:
    :param kwargs:
    :return: int or float
    &#34;&#34;&#34;
    # get the query object
    vr = self._get_raw(parameter_id=parameter_id, parameter_format=parameter_format, *args, **kwargs)

    return vr.RESPONSE.PAYLOAD[0]</code></pre>
</details>
<div class="desc"><p>Get the value of a parameter given by its id and format specifier.
note: use get_parameter() if you only want to use known commands
Returns a list of success and value.
:param parameter:
:param args:
:param kwargs:
:return: int or float</p></div>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.MeComCommon.identify"><code class="name flex">
<span>def <span class="ident">identify</span></span>(<span>self, *, parameter_name='Device Address', parameter_id=None, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _method(cls_or_self, /, *args, **keywords):
    keywords = {**self.keywords, **keywords}
    return self.func(cls_or_self, *self.args, *args, **keywords)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.MeComCommon.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self,*args, **kwargs):
    &#34;&#34;&#34;
    Resets the device after an error has occured
    &#34;&#34;&#34;
    info = self._execute(IF(*args, **kwargs))
    return info.RESPONSE.PAYLOAD</code></pre>
</details>
<div class="desc"><p>Resets the device after an error has occured</p></div>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.MeComCommon.reset_device"><code class="name flex">
<span>def <span class="ident">reset_device</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_device(self,*args, **kwargs):
    &#34;&#34;&#34;
    Resets the device after an error has occured
    &#34;&#34;&#34;
    rs = self._execute(RS(*args, **kwargs))
    return type(rs.RESPONSE) == ACK</code></pre>
</details>
<div class="desc"><p>Resets the device after an error has occured</p></div>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.MeComCommon.set_parameter"><code class="name flex">
<span>def <span class="ident">set_parameter</span></span>(<span>self, value, parameter_name=None, parameter_id=None, *args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_parameter(self, value, parameter_name=None, parameter_id=None, *args, **kwargs):
    &#34;&#34;&#34;
    Set the new value of a parameter given by name or id.
    Returns success.
    :param value:
    :param parameter_name:
    :param parameter_id:
    :param args:
    :param kwargs:
    :return: bool
    &#34;&#34;&#34;
    # get the query object
    vs = self._set(value=value, parameter_id=parameter_id, parameter_name=parameter_name, *args, **kwargs)

    # check if value setting has succeeded
    #
    # Not necessary as we get an acknowledge response or Value is out of range
    # exception when an invalid value was passed. 
    # current implementation also often fails due to rounding, e.g. setting 1.0
    # but returning 0.999755859375 when performing a self.get_parameter
    # value_set = self.get_parameter(parameter_id=parameter_id, parameter_name=parameter_name, *args, **kwargs)

    # return True if we got an ACK
    return type(vs.RESPONSE) == ACK</code></pre>
</details>
<div class="desc"><p>Set the new value of a parameter given by name or id.
Returns success.
:param value:
:param parameter_name:
:param parameter_id:
:param args:
:param kwargs:
:return: bool</p></div>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.MeComCommon.set_parameter_raw"><code class="name flex">
<span>def <span class="ident">set_parameter_raw</span></span>(<span>self, value, parameter_id, parameter_format, *args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_parameter_raw(self, value, parameter_id, parameter_format, *args, **kwargs):
    &#34;&#34;&#34;
    Set the new value of a parameter given by its id and format specifier.
    note: use set_parameter() if you only want to use known commands
    Returns success.
    :param value:
    :param parameter:
    :param args:
    :param kwargs:
    :return: bool
    &#34;&#34;&#34;
    # get the query object
    vs = self._set_raw(value=value, parameter_id=parameter_id, parameter_format=parameter_format, *args, **kwargs)

    # check if value setting has succeeded
    #
    # Not necessary as we get an acknowledge response or Value is out of range
    # exception when an invalid value was passed. 
    # current implementation also often fails due to rounding, e.g. setting 1.0
    # but returning 0.999755859375 when performing a self.get_parameter
    # value_set = self.get_parameter(parameter_id=parameter_id, parameter_name=parameter_name, *args, **kwargs)

    # return True if we got an ACK
    return type(vs.RESPONSE) == ACK</code></pre>
</details>
<div class="desc"><p>Set the new value of a parameter given by its id and format specifier.
note: use set_parameter() if you only want to use known commands
Returns success.
:param value:
:param parameter:
:param args:
:param kwargs:
:return: bool</p></div>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.MeComCommon.status"><code class="name flex">
<span>def <span class="ident">status</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def status(self, *args, **kwargs):
    &#34;&#34;&#34;
    Get the device status.
    Returns success and status as readable str.
    :param args:
    :param kwargs:
    :return: [bool, str]
    &#34;&#34;&#34;
    # query device status
    status_id = self.get_parameter(parameter_name=&#34;Device Status&#34;, *args, **kwargs)

    if status_id == 0:
        status_name = &#34;Init&#34;
    elif status_id == 1:
        status_name = &#34;Ready&#34;
    elif status_id == 2:
        status_name = &#34;Run&#34;
    elif status_id == 3:
        status_name = &#34;Error&#34;
    elif status_id == 4:
        status_name = &#34;Bootloader&#34;
    elif status_id == 5:
        status_name = &#34;Device will Reset within next 200ms&#34;
    else:
        status_name = &#34;Unknown&#34;

    # return address and status
    return status_name</code></pre>
</details>
<div class="desc"><p>Get the device status.
Returns success and status as readable str.
:param args:
:param kwargs:
:return: [bool, str]</p></div>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.MeComCommon.trigger_save_to_flash"><code class="name flex">
<span>def <span class="ident">trigger_save_to_flash</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trigger_save_to_flash(self, *args, **kwargs):
    &#34;&#34;&#34;
    Writes all parameter values to the flash of the device.
    Note: This function only works on:
     - TEC Controllers using a firmware &gt;= v6.00
     - LDD-130x devices with a firmware &gt;= v2.00
     - LDD-1321 devices on any firmware
    for devices not listed here, refer to the device documentation
    and check whether the new explicit flash saving mechanism
    is used on your device
    &#34;&#34;&#34;
    rs = self._execute(SP(*args, **kwargs))
    return type(rs.RESPONSE) == ACK</code></pre>
</details>
<div class="desc"><p>Writes all parameter values to the flash of the device.
Note: This function only works on:
- TEC Controllers using a firmware &gt;= v6.00
- LDD-130x devices with a firmware &gt;= v2.00
- LDD-1321 devices on any firmware
for devices not listed here, refer to the device documentation
and check whether the new explicit flash saving mechanism
is used on your device</p></div>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.MeComCommon.write_to_flash"><code class="name flex">
<span>def <span class="ident">write_to_flash</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_to_flash(self, *args, **kwargs):
    &#34;&#34;&#34;
    Write parameters to flash.
    Note: This function only works on:
     - TEC Controllers using a firmware &lt; v6.00
     - LDD-130x devices with a firmware &lt; v2.00
     - LDD-112x devices on any firmware
    for devices not listed here, refer to the device documentation
    and check whether the old automatic flash saving mechanism
    is used on your device
    :param args:
    :param kwargs:
    :return: bool
    &#34;&#34;&#34;
    self.enable_autosave()
    timer_start = time.time()

    # value 0 means &#34;All Parameters are saved to Flash&#34;
    while self.get_parameter(parameter_name=&#34;Flash Status&#34;) != 0:
        # check for timeout
        if time.time() - timer_start &gt; 10:
            raise ResponseTimeout(&#34;writing to flash timed out!&#34;)
        time.sleep(0.5)

    self.disable_autosave()

    return True</code></pre>
</details>
<div class="desc"><p>Write parameters to flash.
Note: This function only works on:
- TEC Controllers using a firmware &lt; v6.00
- LDD-130x devices with a firmware &lt; v2.00
- LDD-112x devices on any firmware
for devices not listed here, refer to the device documentation
and check whether the old automatic flash saving mechanism
is used on your device
:param args:
:param kwargs:
:return: bool</p></div>
</dd>
</dl>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.MeComSerial"><code class="flex name class">
<span>class <span class="ident">MeComSerial</span></span>
<span>(</span><span>serialport='/dev/ttyUSB0', timeout=1, baudrate=57600, metype='TEC')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MeComSerial(MeComCommon):
    &#34;&#34;&#34;
    Main class (Serial). Import this one:
    from qao.devices.mecom import MeComSerial

    For a usage example see __main__
    &#34;&#34;&#34;
    SEQUENCE_COUNTER = 1

    def __init__(self, serialport=&#34;/dev/ttyUSB0&#34;, timeout=1, baudrate=57600, metype=&#39;TEC&#39;):
        &#34;&#34;&#34;
        Initialize communication with serial port.
        :param serialport: str: Linux example: &#39;/dev/ttyUSB0&#39;, Windows example: &#39;COM1&#39;
        :param timeout: int
        :param metype: str: either &#39;TEC&#39;, &#39;LDD-112x&#39;, &#39;LDD-130x&#39; or &#39;LDD-1321&#39;
        &#34;&#34;&#34;
        # initialize serial connection
        self.ser = Serial(port=serialport, timeout=timeout, write_timeout=timeout, baudrate=baudrate)

        # start protocol thread
        # self.protocol = ReaderThread(serial_instance=self.ser, protocol_factory=MePacket)
        # self.receiver = self.protocol.__enter__()

        # initialize parameters
        self.PARAMETERS = ParameterList(metype)

        super().__init__(metype)

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.ser.__exit__(exc_type, exc_val, exc_tb)

    def __enter__(self):
        return self

    def stop(self):
        self.ser.flush()
        self.ser.close()

    def _read(self, size):
        &#34;&#34;&#34;
        Read n=size bytes from serial, if &lt;n bytes are received (serial.read() return because of timeout), raise a timeout.
        &#34;&#34;&#34;
        recv = self.ser.read(size=size)
        if len(recv) &lt; size:
            raise ResponseTimeout(&#34;timeout while communication via serial&#34;)
        else:
            return recv

    def _execute(self, query):
        self.lock.acquire()

        try:
            # clear buffers
            self.ser.reset_output_buffer()
            self.ser.reset_input_buffer()

            query.set_sequence(self.SEQUENCE_COUNTER)
            # send query
            self.ser.write(query.compose())
            # print(query.compose())

            # flush write cache
            self.ser.flush()

            # initialize response and carriage return
            cr = &#34;\r&#34;.encode()
            response_frame = b&#39;&#39;
            response_byte = self._read(size=1)  # read one byte at a time, timeout is set on instance level

            # read until stop byte
            while response_byte != cr:
                response_frame += response_byte
                response_byte = self._read(size=1)
        finally:
            # increment sequence counter
            self._inc()
            self.lock.release()

        # strip source byte (! or #, but for a response always !)
        response_frame = response_frame[1:]

        # print(response_frame)
        query.set_response(response_frame)

        # did we encounter an error?
        self._raise(query)

        return query</code></pre>
</details>
<div class="desc"><p>Main class (Serial). Import this one:
from qao.devices.mecom import MeComSerial</p>
<p>For a usage example see <strong>main</strong></p>
<p>Initialize communication with serial port.
:param serialport: str: Linux example: '/dev/ttyUSB0', Windows example: 'COM1'
:param timeout: int
:param metype: str: either 'TEC', 'LDD-112x', 'LDD-130x' or 'LDD-1321'</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dopes.equipment_control.mecom.mecom.MeComCommon" href="#dopes.equipment_control.mecom.mecom.MeComCommon">MeComCommon</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="dopes.equipment_control.mecom.mecom.MeCom" href="#dopes.equipment_control.mecom.mecom.MeCom">MeCom</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="dopes.equipment_control.mecom.mecom.MeComSerial.SEQUENCE_COUNTER"><code class="name">var <span class="ident">SEQUENCE_COUNTER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dopes.equipment_control.mecom.mecom.MeComSerial.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    self.ser.flush()
    self.ser.close()</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dopes.equipment_control.mecom.mecom.MeComCommon" href="#dopes.equipment_control.mecom.mecom.MeComCommon">MeComCommon</a></b></code>:
<ul class="hlist">
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.get_parameter" href="#dopes.equipment_control.mecom.mecom.MeComCommon.get_parameter">get_parameter</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.get_parameter_raw" href="#dopes.equipment_control.mecom.mecom.MeComCommon.get_parameter_raw">get_parameter_raw</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.info" href="#dopes.equipment_control.mecom.mecom.MeComCommon.info">info</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.reset_device" href="#dopes.equipment_control.mecom.mecom.MeComCommon.reset_device">reset_device</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.set_parameter" href="#dopes.equipment_control.mecom.mecom.MeComCommon.set_parameter">set_parameter</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.set_parameter_raw" href="#dopes.equipment_control.mecom.mecom.MeComCommon.set_parameter_raw">set_parameter_raw</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.status" href="#dopes.equipment_control.mecom.mecom.MeComCommon.status">status</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.trigger_save_to_flash" href="#dopes.equipment_control.mecom.mecom.MeComCommon.trigger_save_to_flash">trigger_save_to_flash</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.write_to_flash" href="#dopes.equipment_control.mecom.mecom.MeComCommon.write_to_flash">write_to_flash</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.MeComTcp"><code class="flex name class">
<span>class <span class="ident">MeComTcp</span></span>
<span>(</span><span>ipaddress, ipport=50000, metype='TEC')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MeComTcp(MeComCommon):
    &#34;&#34;&#34;
    Main class (TCP). Import this one:
    from qao.devices.mecom import MeComTCP

    For a usage example see __main__
    &#34;&#34;&#34;
    SEQUENCE_COUNTER = 1

    def __init__(self, ipaddress, ipport=50000, metype=&#39;TEC&#39;):
        &#34;&#34;&#34;
        Initialize communication with TCP connection.
        :param ipaddress: str
        :param ipport: int
        :param timeout: int
        :param metype: str: either &#39;TEC&#39;, &#39;LDD-112x&#39;, &#39;LDD-130x&#39; or &#39;LDD-1321&#39;
        &#34;&#34;&#34;
        # initialize network connection
        self.tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.tcp.connect((ipaddress, ipport))

        # initialize parameters
        self.PARAMETERS = ParameterList(metype)

        super().__init__(metype)

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.tcp.__exit__(exc_type, exc_val, exc_tb)

    def __enter__(self):
        return self

    def stop(self):
        self.tcp.close()

    def _read(self, size):
        &#34;&#34;&#34;
        Read n=size bytes from TCP, if &lt;n bytes are received, raise a timeout.
        &#34;&#34;&#34;
        recv = b&#34;&#34;
        while (size - len(recv)) &gt; 0:
            recv += self.tcp.recv(size - len(recv))
        if len(recv) &lt; size:
            raise ResponseTimeout(&#34;timeout while communication via network&#34;)
        else:
            return recv

    def _execute(self, query):
        self.lock.acquire()

        try:
            query.set_sequence(self.SEQUENCE_COUNTER)
            # send query
            self.tcp.sendall(query.compose())
            # print(query.compose())

            # initialize response and carriage return
            cr = &#34;\r&#34;.encode()
            response_frame = b&#39;&#39;
            response_byte = self._read(size=1)  # read one byte at a time, timeout is set on instance level

            # read until stop byte
            while response_byte != cr:
                response_frame += response_byte
                response_byte = self._read(size=1)
        finally:
            # increment sequence counter
            self._inc()
            self.lock.release()

        # strip source byte (! or #, but for a response always !)
        response_frame = response_frame[1:]

        # print(response_frame)
        query.set_response(response_frame)

        # did we encounter an error?
        self._raise(query)

        return query</code></pre>
</details>
<div class="desc"><p>Main class (TCP). Import this one:
from qao.devices.mecom import MeComTCP</p>
<p>For a usage example see <strong>main</strong></p>
<p>Initialize communication with TCP connection.
:param ipaddress: str
:param ipport: int
:param timeout: int
:param metype: str: either 'TEC', 'LDD-112x', 'LDD-130x' or 'LDD-1321'</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dopes.equipment_control.mecom.mecom.MeComCommon" href="#dopes.equipment_control.mecom.mecom.MeComCommon">MeComCommon</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="dopes.equipment_control.mecom.mecom.MeComTcp.SEQUENCE_COUNTER"><code class="name">var <span class="ident">SEQUENCE_COUNTER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dopes.equipment_control.mecom.mecom.MeComTcp.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    self.tcp.close()</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dopes.equipment_control.mecom.mecom.MeComCommon" href="#dopes.equipment_control.mecom.mecom.MeComCommon">MeComCommon</a></b></code>:
<ul class="hlist">
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.get_parameter" href="#dopes.equipment_control.mecom.mecom.MeComCommon.get_parameter">get_parameter</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.get_parameter_raw" href="#dopes.equipment_control.mecom.mecom.MeComCommon.get_parameter_raw">get_parameter_raw</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.info" href="#dopes.equipment_control.mecom.mecom.MeComCommon.info">info</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.reset_device" href="#dopes.equipment_control.mecom.mecom.MeComCommon.reset_device">reset_device</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.set_parameter" href="#dopes.equipment_control.mecom.mecom.MeComCommon.set_parameter">set_parameter</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.set_parameter_raw" href="#dopes.equipment_control.mecom.mecom.MeComCommon.set_parameter_raw">set_parameter_raw</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.status" href="#dopes.equipment_control.mecom.mecom.MeComCommon.status">status</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.trigger_save_to_flash" href="#dopes.equipment_control.mecom.mecom.MeComCommon.trigger_save_to_flash">trigger_save_to_flash</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.write_to_flash" href="#dopes.equipment_control.mecom.mecom.MeComCommon.write_to_flash">write_to_flash</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.MeFrame"><code class="flex name class">
<span>class <span class="ident">MeFrame</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MeFrame(object):
    &#34;&#34;&#34;
    Basis structure of a MeCom frame as defined in the specs.
    &#34;&#34;&#34;
    _TYPES = {&#34;UINT8&#34;: &#34;!H&#34;, &#34;UINT16&#34;: &#34;!L&#34;, &#34;INT32&#34;: &#34;!i&#34;, &#34;FLOAT32&#34;: &#34;!f&#34;}
    _SOURCE = &#34;&#34;
    _EOL = &#34;\r&#34;  # carriage return

    def __init__(self):
        self.ADDRESS = 0
        self.SEQUENCE = 0
        self.PAYLOAD = []
        self.CRC = None

    def CalcCRC_CCITT(self, input_data):
        &#34;&#34;&#34;
        Calculates the CRC-CCITT checksum of the given data
        &#34;&#34;&#34;
        CRC = 0

        for byte in input_data:
            CRC ^= byte &lt;&lt; 8
            for _ in range(8):
                if (CRC &amp; 0x8000) != 0:
                    CRC = (CRC &lt;&lt; 1) ^ 0x1021 # CCITT CRC-16 Polynomial
                else:
                    CRC = CRC &lt;&lt; 1
                CRC &amp;= 0xFFFF

        return CRC

    def crc(self, in_crc=None):
        &#34;&#34;&#34;
        Calculates the checksum of a given frame, if a checksum is given as parameter, the two are compared.
        :param in_crc:
        :return: int
        &#34;&#34;&#34;
        if self.CRC is None:
            self.CRC = self.CalcCRC_CCITT(input_data=self.compose(part=True))

        # crc check
        # print(self.CRC)
        # print(in_crc)
        if in_crc is not None and in_crc != self.CRC:
            raise WrongChecksum

    def set_sequence(self, sequence):
        self.SEQUENCE = sequence

    def compose(self, part=False):
        &#34;&#34;&#34;
        Returns the frame as bytes, the return-value can be directly send via serial.
        :param part: bool
        :return: bytes
        &#34;&#34;&#34;
        # first part
        frame = self._SOURCE + &#34;{:02X}&#34;.format(self.ADDRESS) + &#34;{:04X}&#34;.format(self.SEQUENCE)
        # payload can be str or float or int
        for p in self.PAYLOAD:
            if type(p) is str:
                frame += p
            elif type(p) is int:
                frame += &#34;{:08X}&#34;.format(p)
            elif type(p) is float:
                # frame += hex(unpack(&#39;&lt;I&#39;, pack(&#39;&lt;f&#39;, p))[0])[2:].upper()  # please do not ask
                # if p = 0 CRC fails, e.g. !01000400000000 composes to b&#39;!0100040&#39; / missing zero padding
                frame += &#39;{:08X}&#39;.format(unpack(&#39;&lt;I&#39;, pack(&#39;&lt;f&#39;, p))[0])   #still do not aks
        # if we only want a partial frame, return here
        if part:
            return frame.encode()
        # add checksum
        if self.CRC is None:
            self.crc()
        frame += &#34;{:04X}&#34;.format(self.CRC)
        # add end of line (carriage return)
        frame += self._EOL
        return frame.encode()

    def _decompose_header(self, frame_bytes):
        &#34;&#34;&#34;
        Takes bytes as input and decomposes into the instance variables.
        :param frame_bytes: bytes
        :return:
        &#34;&#34;&#34;
        frame = frame_bytes.decode()

        self._SOURCE = frame[0]
        self.ADDRESS = int(frame[1:3], 16)
        self.SEQUENCE = int(frame[3:7], 16)</code></pre>
</details>
<div class="desc"><p>Basis structure of a MeCom frame as defined in the specs.</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="dopes.equipment_control.mecom.mecom.ACK" href="#dopes.equipment_control.mecom.mecom.ACK">ACK</a></li>
<li><a title="dopes.equipment_control.mecom.mecom.DeviceError" href="#dopes.equipment_control.mecom.mecom.DeviceError">DeviceError</a></li>
<li><a title="dopes.equipment_control.mecom.mecom.IFResponse" href="#dopes.equipment_control.mecom.mecom.IFResponse">IFResponse</a></li>
<li><a title="dopes.equipment_control.mecom.mecom.Query" href="#dopes.equipment_control.mecom.mecom.Query">Query</a></li>
<li><a title="dopes.equipment_control.mecom.mecom.VRResponse" href="#dopes.equipment_control.mecom.mecom.VRResponse">VRResponse</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dopes.equipment_control.mecom.mecom.MeFrame.CalcCRC_CCITT"><code class="name flex">
<span>def <span class="ident">CalcCRC_CCITT</span></span>(<span>self, input_data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CalcCRC_CCITT(self, input_data):
    &#34;&#34;&#34;
    Calculates the CRC-CCITT checksum of the given data
    &#34;&#34;&#34;
    CRC = 0

    for byte in input_data:
        CRC ^= byte &lt;&lt; 8
        for _ in range(8):
            if (CRC &amp; 0x8000) != 0:
                CRC = (CRC &lt;&lt; 1) ^ 0x1021 # CCITT CRC-16 Polynomial
            else:
                CRC = CRC &lt;&lt; 1
            CRC &amp;= 0xFFFF

    return CRC</code></pre>
</details>
<div class="desc"><p>Calculates the CRC-CCITT checksum of the given data</p></div>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.MeFrame.compose"><code class="name flex">
<span>def <span class="ident">compose</span></span>(<span>self, part=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compose(self, part=False):
    &#34;&#34;&#34;
    Returns the frame as bytes, the return-value can be directly send via serial.
    :param part: bool
    :return: bytes
    &#34;&#34;&#34;
    # first part
    frame = self._SOURCE + &#34;{:02X}&#34;.format(self.ADDRESS) + &#34;{:04X}&#34;.format(self.SEQUENCE)
    # payload can be str or float or int
    for p in self.PAYLOAD:
        if type(p) is str:
            frame += p
        elif type(p) is int:
            frame += &#34;{:08X}&#34;.format(p)
        elif type(p) is float:
            # frame += hex(unpack(&#39;&lt;I&#39;, pack(&#39;&lt;f&#39;, p))[0])[2:].upper()  # please do not ask
            # if p = 0 CRC fails, e.g. !01000400000000 composes to b&#39;!0100040&#39; / missing zero padding
            frame += &#39;{:08X}&#39;.format(unpack(&#39;&lt;I&#39;, pack(&#39;&lt;f&#39;, p))[0])   #still do not aks
    # if we only want a partial frame, return here
    if part:
        return frame.encode()
    # add checksum
    if self.CRC is None:
        self.crc()
    frame += &#34;{:04X}&#34;.format(self.CRC)
    # add end of line (carriage return)
    frame += self._EOL
    return frame.encode()</code></pre>
</details>
<div class="desc"><p>Returns the frame as bytes, the return-value can be directly send via serial.
:param part: bool
:return: bytes</p></div>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.MeFrame.crc"><code class="name flex">
<span>def <span class="ident">crc</span></span>(<span>self, in_crc=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crc(self, in_crc=None):
    &#34;&#34;&#34;
    Calculates the checksum of a given frame, if a checksum is given as parameter, the two are compared.
    :param in_crc:
    :return: int
    &#34;&#34;&#34;
    if self.CRC is None:
        self.CRC = self.CalcCRC_CCITT(input_data=self.compose(part=True))

    # crc check
    # print(self.CRC)
    # print(in_crc)
    if in_crc is not None and in_crc != self.CRC:
        raise WrongChecksum</code></pre>
</details>
<div class="desc"><p>Calculates the checksum of a given frame, if a checksum is given as parameter, the two are compared.
:param in_crc:
:return: int</p></div>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.MeFrame.set_sequence"><code class="name flex">
<span>def <span class="ident">set_sequence</span></span>(<span>self, sequence)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_sequence(self, sequence):
    self.SEQUENCE = sequence</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.Parameter"><code class="flex name class">
<span>class <span class="ident">Parameter</span></span>
<span>(</span><span>parameter_dict)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Parameter(object):
    &#34;&#34;&#34;&#34;
    Every parameter dict from commands.py is parsed into a Parameter instance.
    &#34;&#34;&#34;

    def __init__(self, parameter_dict):
        &#34;&#34;&#34;
        Takes a dict e.g. {&#34;id&#34;: 104, &#34;name&#34;: &#34;Device Status&#34;, &#34;format&#34;: &#34;INT32&#34;} and creates an object which can be
        passed to a Query().
        :param parameter_dict: dict
        &#34;&#34;&#34;
        self.id = parameter_dict[&#34;id&#34;]
        self.name = parameter_dict[&#34;name&#34;]
        self.format = parameter_dict[&#34;format&#34;]</code></pre>
</details>
<div class="desc"><p>"
Every parameter dict from commands.py is parsed into a Parameter instance.</p>
<p>Takes a dict e.g. {"id": 104, "name": "Device Status", "format": "INT32"} and creates an object which can be
passed to a Query().
:param parameter_dict: dict</p></div>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.ParameterList"><code class="flex name class">
<span>class <span class="ident">ParameterList</span></span>
<span>(</span><span>metype='TEC')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParameterList(object):
    &#34;&#34;&#34;
    Contains a list of Parameter() for either TEC controller (metype = &#39;TEC&#39;),
    LDD-112x (metype = &#39;LDD-112x&#39;), LDD-130x (metype = &#39;LDD-130x&#39;) or LDD-1321 (metype = &#39;LDD-1321&#39;).
    Provides searching via id or name.
    The deprecated metype = &#39;LDD&#39; is equal to passing metype = &#39;LDD-112x&#39;.
    :param error_dict: dict
    &#34;&#34;&#34;

    def __init__(self,metype=&#39;TEC&#39;):
        &#34;&#34;&#34;
        Reads the parameter dicts from commands.py.
        &#34;&#34;&#34;
        self._PARAMETERS = []
        if metype == &#39;TEC&#39;:
            for parameter in TEC_PARAMETERS:
                self._PARAMETERS.append(Parameter(parameter))
        elif metype ==&#39;LDD-112x&#39; or metype ==&#39;LDD&#39;:
            for parameter in LDD_112x_PARAMETERS:
                self._PARAMETERS.append(Parameter(parameter))
        elif metype ==&#39;LDD-130x&#39;:
            for parameter in LDD_130x_PARAMETERS:
                self._PARAMETERS.append(Parameter(parameter))
        elif metype ==&#39;LDD-1321&#39;:
            for parameter in LDD_1321_PARAMETERS:
                self._PARAMETERS.append(Parameter(parameter))
        else:
            raise UnknownMeComType

    def get_by_id(self, id):
        &#34;&#34;&#34;
        Returns a Parameter() identified by it&#39;s id.
        :param id: int
        :return: Parameter()
        &#34;&#34;&#34;
        for parameter in self._PARAMETERS:
            if parameter.id == id:
                return parameter
        raise UnknownParameter

    def get_by_name(self, name):
        &#34;&#34;&#34;
        Returns a Parameter() identified by it&#39;s name.
        :param name: str
        :return: Parameter()
        &#34;&#34;&#34;
        for parameter in self._PARAMETERS:
            if parameter.name == name:
                return parameter
        raise UnknownParameter</code></pre>
</details>
<div class="desc"><p>Contains a list of Parameter() for either TEC controller (metype = 'TEC'),
LDD-112x (metype = 'LDD-112x'), LDD-130x (metype = 'LDD-130x') or LDD-1321 (metype = 'LDD-1321').
Provides searching via id or name.
The deprecated metype = 'LDD' is equal to passing metype = 'LDD-112x'.
:param error_dict: dict</p>
<p>Reads the parameter dicts from commands.py.</p></div>
<h3>Methods</h3>
<dl>
<dt id="dopes.equipment_control.mecom.mecom.ParameterList.get_by_id"><code class="name flex">
<span>def <span class="ident">get_by_id</span></span>(<span>self, id)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_by_id(self, id):
    &#34;&#34;&#34;
    Returns a Parameter() identified by it&#39;s id.
    :param id: int
    :return: Parameter()
    &#34;&#34;&#34;
    for parameter in self._PARAMETERS:
        if parameter.id == id:
            return parameter
    raise UnknownParameter</code></pre>
</details>
<div class="desc"><p>Returns a Parameter() identified by it's id.
:param id: int
:return: Parameter()</p></div>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.ParameterList.get_by_name"><code class="name flex">
<span>def <span class="ident">get_by_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_by_name(self, name):
    &#34;&#34;&#34;
    Returns a Parameter() identified by it&#39;s name.
    :param name: str
    :return: Parameter()
    &#34;&#34;&#34;
    for parameter in self._PARAMETERS:
        if parameter.name == name:
            return parameter
    raise UnknownParameter</code></pre>
</details>
<div class="desc"><p>Returns a Parameter() identified by it's name.
:param name: str
:return: Parameter()</p></div>
</dd>
</dl>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.Query"><code class="flex name class">
<span>class <span class="ident">Query</span></span>
<span>(</span><span>parameter=None, address=0, parameter_instance=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Query(MeFrame):
    &#34;&#34;&#34;
    Basic structure of a query to get or set a parameter. Has the attribute RESPONSE which contains the answer received
    by the device. The response is set via set_response
    &#34;&#34;&#34;
    _SOURCE = &#34;#&#34;
    _PAYLOAD_START = None

    def __init__(self, parameter=None, address=0, parameter_instance=1):
        &#34;&#34;&#34;
        To be initialized with a target device address (default=broadcast), the channel, teh sequence number and a
        Parameter() instance of the corresponding parameter.
        :param parameter: Parameter
        :param sequence: int
        :param address: int
        :param parameter_instance: int
        &#34;&#34;&#34;
        super(Query, self).__init__()

        if hasattr(self, &#34;_PAYLOAD_START&#34;):
            self.PAYLOAD.append(self._PAYLOAD_START)

        self.RESPONSE = None
        self._RESPONSE_FORMAT = None

        self.ADDRESS = address
        if parameter is not None:
            # UNIT16 4 hex digits
            self.PAYLOAD.append(&#34;{:04X}&#34;.format(parameter.id))
            # UNIT8 2 hex digits
            self.PAYLOAD.append(&#34;{:02X}&#34;.format(parameter_instance))

    def set_response(self, response_frame):
        &#34;&#34;&#34;
        Takes the bytes received from the device as input and creates the corresponding response instance.
        :param response_frame: bytes
        :return:
        &#34;&#34;&#34;
        # check the type of the response
        # is it an ACK packet?
        if len(response_frame) == 10:
            self.RESPONSE = ACK()
            self.RESPONSE.decompose(response_frame)
        # is it an info string packet/response_frame does not contain source (!)
        elif len(response_frame) == 30:
            self.RESPONSE = IFResponse()
            self.RESPONSE.decompose(response_frame)
        # is it an error packet?
        elif b&#39;+&#39; in response_frame:
            self.RESPONSE = DeviceError()
            self.RESPONSE.decompose(response_frame)
        # nope it&#39;s a response to a parameter query
        else:
            self.RESPONSE = VRResponse(self._RESPONSE_FORMAT)
            # if the checksum is wrong, this statement raises
            self.RESPONSE.decompose(response_frame)

        # did we get the right response to our query?
        if self.SEQUENCE != self.RESPONSE.SEQUENCE:
            raise WrongResponseSequence</code></pre>
</details>
<div class="desc"><p>Basic structure of a query to get or set a parameter. Has the attribute RESPONSE which contains the answer received
by the device. The response is set via set_response</p>
<p>To be initialized with a target device address (default=broadcast), the channel, teh sequence number and a
Parameter() instance of the corresponding parameter.
:param parameter: Parameter
:param sequence: int
:param address: int
:param parameter_instance: int</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dopes.equipment_control.mecom.mecom.MeFrame" href="#dopes.equipment_control.mecom.mecom.MeFrame">MeFrame</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="dopes.equipment_control.mecom.mecom.IF" href="#dopes.equipment_control.mecom.mecom.IF">IF</a></li>
<li><a title="dopes.equipment_control.mecom.mecom.RS" href="#dopes.equipment_control.mecom.mecom.RS">RS</a></li>
<li><a title="dopes.equipment_control.mecom.mecom.SP" href="#dopes.equipment_control.mecom.mecom.SP">SP</a></li>
<li><a title="dopes.equipment_control.mecom.mecom.VR" href="#dopes.equipment_control.mecom.mecom.VR">VR</a></li>
<li><a title="dopes.equipment_control.mecom.mecom.VS" href="#dopes.equipment_control.mecom.mecom.VS">VS</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dopes.equipment_control.mecom.mecom.Query.set_response"><code class="name flex">
<span>def <span class="ident">set_response</span></span>(<span>self, response_frame)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_response(self, response_frame):
    &#34;&#34;&#34;
    Takes the bytes received from the device as input and creates the corresponding response instance.
    :param response_frame: bytes
    :return:
    &#34;&#34;&#34;
    # check the type of the response
    # is it an ACK packet?
    if len(response_frame) == 10:
        self.RESPONSE = ACK()
        self.RESPONSE.decompose(response_frame)
    # is it an info string packet/response_frame does not contain source (!)
    elif len(response_frame) == 30:
        self.RESPONSE = IFResponse()
        self.RESPONSE.decompose(response_frame)
    # is it an error packet?
    elif b&#39;+&#39; in response_frame:
        self.RESPONSE = DeviceError()
        self.RESPONSE.decompose(response_frame)
    # nope it&#39;s a response to a parameter query
    else:
        self.RESPONSE = VRResponse(self._RESPONSE_FORMAT)
        # if the checksum is wrong, this statement raises
        self.RESPONSE.decompose(response_frame)

    # did we get the right response to our query?
    if self.SEQUENCE != self.RESPONSE.SEQUENCE:
        raise WrongResponseSequence</code></pre>
</details>
<div class="desc"><p>Takes the bytes received from the device as input and creates the corresponding response instance.
:param response_frame: bytes
:return:</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dopes.equipment_control.mecom.mecom.MeFrame" href="#dopes.equipment_control.mecom.mecom.MeFrame">MeFrame</a></b></code>:
<ul class="hlist">
<li><code><a title="dopes.equipment_control.mecom.mecom.MeFrame.CalcCRC_CCITT" href="#dopes.equipment_control.mecom.mecom.MeFrame.CalcCRC_CCITT">CalcCRC_CCITT</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeFrame.compose" href="#dopes.equipment_control.mecom.mecom.MeFrame.compose">compose</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeFrame.crc" href="#dopes.equipment_control.mecom.mecom.MeFrame.crc">crc</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.RS"><code class="flex name class">
<span>class <span class="ident">RS</span></span>
<span>(</span><span>address=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RS(Query):
    &#34;&#34;&#34;
    Implementing system reset.
    &#34;&#34;&#34;
    _PAYLOAD_START = &#39;RS&#39;

    def __init__(self, address=0):
        &#34;&#34;&#34;
        Create a query to set a parameter value.
        :param address: int
        :param parameter_instance: int
        &#34;&#34;&#34;
        
        # init header
        super(RS, self).__init__(parameter=None, address=address)

        # no need to initialize response format, we want ACK</code></pre>
</details>
<div class="desc"><p>Implementing system reset.</p>
<p>Create a query to set a parameter value.
:param address: int
:param parameter_instance: int</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dopes.equipment_control.mecom.mecom.Query" href="#dopes.equipment_control.mecom.mecom.Query">Query</a></li>
<li><a title="dopes.equipment_control.mecom.mecom.MeFrame" href="#dopes.equipment_control.mecom.mecom.MeFrame">MeFrame</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dopes.equipment_control.mecom.mecom.Query" href="#dopes.equipment_control.mecom.mecom.Query">Query</a></b></code>:
<ul class="hlist">
<li><code><a title="dopes.equipment_control.mecom.mecom.Query.CalcCRC_CCITT" href="#dopes.equipment_control.mecom.mecom.MeFrame.CalcCRC_CCITT">CalcCRC_CCITT</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.Query.compose" href="#dopes.equipment_control.mecom.mecom.MeFrame.compose">compose</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.Query.crc" href="#dopes.equipment_control.mecom.mecom.MeFrame.crc">crc</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.Query.set_response" href="#dopes.equipment_control.mecom.mecom.Query.set_response">set_response</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.SP"><code class="flex name class">
<span>class <span class="ident">SP</span></span>
<span>(</span><span>address=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SP(Query):
    &#34;&#34;&#34;
    Implementing query to save all parameter values to flash.
    &#34;&#34;&#34;
    _PAYLOAD_START = &#39;SP&#39;

    def __init__(self, address=0):
        &#34;&#34;&#34;
        Create a query to set a parameter value.
        :param address: int
        &#34;&#34;&#34;

        # init header
        super(SP, self).__init__(parameter=None, address=address)

        # no need to initialize response format, we want ACK</code></pre>
</details>
<div class="desc"><p>Implementing query to save all parameter values to flash.</p>
<p>Create a query to set a parameter value.
:param address: int</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dopes.equipment_control.mecom.mecom.Query" href="#dopes.equipment_control.mecom.mecom.Query">Query</a></li>
<li><a title="dopes.equipment_control.mecom.mecom.MeFrame" href="#dopes.equipment_control.mecom.mecom.MeFrame">MeFrame</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dopes.equipment_control.mecom.mecom.Query" href="#dopes.equipment_control.mecom.mecom.Query">Query</a></b></code>:
<ul class="hlist">
<li><code><a title="dopes.equipment_control.mecom.mecom.Query.CalcCRC_CCITT" href="#dopes.equipment_control.mecom.mecom.MeFrame.CalcCRC_CCITT">CalcCRC_CCITT</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.Query.compose" href="#dopes.equipment_control.mecom.mecom.MeFrame.compose">compose</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.Query.crc" href="#dopes.equipment_control.mecom.mecom.MeFrame.crc">crc</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.Query.set_response" href="#dopes.equipment_control.mecom.mecom.Query.set_response">set_response</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.VR"><code class="flex name class">
<span>class <span class="ident">VR</span></span>
<span>(</span><span>parameter, address=0, parameter_instance=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VR(Query):
    &#34;&#34;&#34;
    Implementing query to get a parameter from the device (?VR).
    &#34;&#34;&#34;
    _PAYLOAD_START = &#34;?VR&#34;

    def __init__(self, parameter, address=0, parameter_instance=1):
        &#34;&#34;&#34;
        Create a query to get a parameter value.
        :param parameter: Parameter
        :param address: int
        :param parameter_instance: int
        &#34;&#34;&#34;
        # init header (equal for get and set queries
        super(VR, self).__init__(parameter=parameter,
                         address=address,
                         parameter_instance=parameter_instance)
        # initialize response
        assert parameter.format in self._TYPES.keys()

        self._RESPONSE_FORMAT = parameter.format</code></pre>
</details>
<div class="desc"><p>Implementing query to get a parameter from the device (?VR).</p>
<p>Create a query to get a parameter value.
:param parameter: Parameter
:param address: int
:param parameter_instance: int</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dopes.equipment_control.mecom.mecom.Query" href="#dopes.equipment_control.mecom.mecom.Query">Query</a></li>
<li><a title="dopes.equipment_control.mecom.mecom.MeFrame" href="#dopes.equipment_control.mecom.mecom.MeFrame">MeFrame</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dopes.equipment_control.mecom.mecom.Query" href="#dopes.equipment_control.mecom.mecom.Query">Query</a></b></code>:
<ul class="hlist">
<li><code><a title="dopes.equipment_control.mecom.mecom.Query.CalcCRC_CCITT" href="#dopes.equipment_control.mecom.mecom.MeFrame.CalcCRC_CCITT">CalcCRC_CCITT</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.Query.compose" href="#dopes.equipment_control.mecom.mecom.MeFrame.compose">compose</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.Query.crc" href="#dopes.equipment_control.mecom.mecom.MeFrame.crc">crc</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.Query.set_response" href="#dopes.equipment_control.mecom.mecom.Query.set_response">set_response</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.VRResponse"><code class="flex name class">
<span>class <span class="ident">VRResponse</span></span>
<span>(</span><span>response_format)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VRResponse(MeFrame):
    &#34;&#34;&#34;
    Frame for the device response to a VR() query.
    &#34;&#34;&#34;
    _SOURCE = &#34;!&#34;
    _RESPONSE_FORMAT = None

    def __init__(self, response_format):
        &#34;&#34;&#34;
        The format of the response is given via VR.set_response()
        :param response_format: str
        &#34;&#34;&#34;
        super(VRResponse, self).__init__()
        self._RESPONSE_FORMAT = self._TYPES[response_format]

    def decompose(self, frame_bytes):
        &#34;&#34;&#34;
        Takes bytes as input and builds the instance.
        :param frame_bytes: bytes
        :return:
        &#34;&#34;&#34;
        assert self._RESPONSE_FORMAT is not None
        frame_bytes = self._SOURCE.encode() + frame_bytes
        self._decompose_header(frame_bytes)

        frame = frame_bytes.decode()
        self.PAYLOAD = [unpack(self._RESPONSE_FORMAT, bytes.fromhex(frame[7:15]))[0]]  # convert hex to float or int
        self.crc(int(frame[-4:], 16))  # sets crc or raises</code></pre>
</details>
<div class="desc"><p>Frame for the device response to a VR() query.</p>
<p>The format of the response is given via VR.set_response()
:param response_format: str</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dopes.equipment_control.mecom.mecom.MeFrame" href="#dopes.equipment_control.mecom.mecom.MeFrame">MeFrame</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dopes.equipment_control.mecom.mecom.VRResponse.decompose"><code class="name flex">
<span>def <span class="ident">decompose</span></span>(<span>self, frame_bytes)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decompose(self, frame_bytes):
    &#34;&#34;&#34;
    Takes bytes as input and builds the instance.
    :param frame_bytes: bytes
    :return:
    &#34;&#34;&#34;
    assert self._RESPONSE_FORMAT is not None
    frame_bytes = self._SOURCE.encode() + frame_bytes
    self._decompose_header(frame_bytes)

    frame = frame_bytes.decode()
    self.PAYLOAD = [unpack(self._RESPONSE_FORMAT, bytes.fromhex(frame[7:15]))[0]]  # convert hex to float or int
    self.crc(int(frame[-4:], 16))  # sets crc or raises</code></pre>
</details>
<div class="desc"><p>Takes bytes as input and builds the instance.
:param frame_bytes: bytes
:return:</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dopes.equipment_control.mecom.mecom.MeFrame" href="#dopes.equipment_control.mecom.mecom.MeFrame">MeFrame</a></b></code>:
<ul class="hlist">
<li><code><a title="dopes.equipment_control.mecom.mecom.MeFrame.CalcCRC_CCITT" href="#dopes.equipment_control.mecom.mecom.MeFrame.CalcCRC_CCITT">CalcCRC_CCITT</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeFrame.compose" href="#dopes.equipment_control.mecom.mecom.MeFrame.compose">compose</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeFrame.crc" href="#dopes.equipment_control.mecom.mecom.MeFrame.crc">crc</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dopes.equipment_control.mecom.mecom.VS"><code class="flex name class">
<span>class <span class="ident">VS</span></span>
<span>(</span><span>value, parameter, address=0, parameter_instance=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VS(Query):
    &#34;&#34;&#34;
    Implementing query to set a parameter from the device (VS).
    &#34;&#34;&#34;
    _PAYLOAD_START = &#34;VS&#34;

    def __init__(self, value, parameter, address=0, parameter_instance=1):
        &#34;&#34;&#34;
        Create a query to set a parameter value.
        :param value: int or float
        :param parameter: Parameter
        :param address: int
        :param parameter_instance: int
        &#34;&#34;&#34;
        # init header (equal for get and set queries)
        super(VS, self).__init__(parameter=parameter,
                         address=address,
                         parameter_instance=parameter_instance)


        # cast the value parameter to the correct type
        conversions = {&#39;FLOAT32&#39;: float, &#39;INT32&#39;: int}
        assert parameter.format in conversions.keys()
        
        value=conversions[parameter.format](value)

        # the set value
        self.PAYLOAD.append(value)

        # no need to initialize response format, we want ACK</code></pre>
</details>
<div class="desc"><p>Implementing query to set a parameter from the device (VS).</p>
<p>Create a query to set a parameter value.
:param value: int or float
:param parameter: Parameter
:param address: int
:param parameter_instance: int</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dopes.equipment_control.mecom.mecom.Query" href="#dopes.equipment_control.mecom.mecom.Query">Query</a></li>
<li><a title="dopes.equipment_control.mecom.mecom.MeFrame" href="#dopes.equipment_control.mecom.mecom.MeFrame">MeFrame</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dopes.equipment_control.mecom.mecom.Query" href="#dopes.equipment_control.mecom.mecom.Query">Query</a></b></code>:
<ul class="hlist">
<li><code><a title="dopes.equipment_control.mecom.mecom.Query.CalcCRC_CCITT" href="#dopes.equipment_control.mecom.mecom.MeFrame.CalcCRC_CCITT">CalcCRC_CCITT</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.Query.compose" href="#dopes.equipment_control.mecom.mecom.MeFrame.compose">compose</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.Query.crc" href="#dopes.equipment_control.mecom.mecom.MeFrame.crc">crc</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.Query.set_response" href="#dopes.equipment_control.mecom.mecom.Query.set_response">set_response</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dopes.equipment_control.mecom" href="index.html">dopes.equipment_control.mecom</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dopes.equipment_control.mecom.mecom.ACK" href="#dopes.equipment_control.mecom.mecom.ACK">ACK</a></code></h4>
<ul class="">
<li><code><a title="dopes.equipment_control.mecom.mecom.ACK.decompose" href="#dopes.equipment_control.mecom.mecom.ACK.decompose">decompose</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dopes.equipment_control.mecom.mecom.DeviceError" href="#dopes.equipment_control.mecom.mecom.DeviceError">DeviceError</a></code></h4>
<ul class="">
<li><code><a title="dopes.equipment_control.mecom.mecom.DeviceError.compose" href="#dopes.equipment_control.mecom.mecom.DeviceError.compose">compose</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.DeviceError.decompose" href="#dopes.equipment_control.mecom.mecom.DeviceError.decompose">decompose</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.DeviceError.error" href="#dopes.equipment_control.mecom.mecom.DeviceError.error">error</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dopes.equipment_control.mecom.mecom.Error" href="#dopes.equipment_control.mecom.mecom.Error">Error</a></code></h4>
<ul class="">
<li><code><a title="dopes.equipment_control.mecom.mecom.Error.as_list" href="#dopes.equipment_control.mecom.mecom.Error.as_list">as_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dopes.equipment_control.mecom.mecom.IF" href="#dopes.equipment_control.mecom.mecom.IF">IF</a></code></h4>
</li>
<li>
<h4><code><a title="dopes.equipment_control.mecom.mecom.IFResponse" href="#dopes.equipment_control.mecom.mecom.IFResponse">IFResponse</a></code></h4>
<ul class="">
<li><code><a title="dopes.equipment_control.mecom.mecom.IFResponse.crc" href="#dopes.equipment_control.mecom.mecom.IFResponse.crc">crc</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.IFResponse.decompose" href="#dopes.equipment_control.mecom.mecom.IFResponse.decompose">decompose</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dopes.equipment_control.mecom.mecom.MeCom" href="#dopes.equipment_control.mecom.mecom.MeCom">MeCom</a></code></h4>
</li>
<li>
<h4><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon" href="#dopes.equipment_control.mecom.mecom.MeComCommon">MeComCommon</a></code></h4>
<ul class="">
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.SEQUENCE_COUNTER" href="#dopes.equipment_control.mecom.mecom.MeComCommon.SEQUENCE_COUNTER">SEQUENCE_COUNTER</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.disable_autosave" href="#dopes.equipment_control.mecom.mecom.MeComCommon.disable_autosave">disable_autosave</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.enable_autosave" href="#dopes.equipment_control.mecom.mecom.MeComCommon.enable_autosave">enable_autosave</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.get_parameter" href="#dopes.equipment_control.mecom.mecom.MeComCommon.get_parameter">get_parameter</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.get_parameter_raw" href="#dopes.equipment_control.mecom.mecom.MeComCommon.get_parameter_raw">get_parameter_raw</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.identify" href="#dopes.equipment_control.mecom.mecom.MeComCommon.identify">identify</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.info" href="#dopes.equipment_control.mecom.mecom.MeComCommon.info">info</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.reset_device" href="#dopes.equipment_control.mecom.mecom.MeComCommon.reset_device">reset_device</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.set_parameter" href="#dopes.equipment_control.mecom.mecom.MeComCommon.set_parameter">set_parameter</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.set_parameter_raw" href="#dopes.equipment_control.mecom.mecom.MeComCommon.set_parameter_raw">set_parameter_raw</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.status" href="#dopes.equipment_control.mecom.mecom.MeComCommon.status">status</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.trigger_save_to_flash" href="#dopes.equipment_control.mecom.mecom.MeComCommon.trigger_save_to_flash">trigger_save_to_flash</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComCommon.write_to_flash" href="#dopes.equipment_control.mecom.mecom.MeComCommon.write_to_flash">write_to_flash</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dopes.equipment_control.mecom.mecom.MeComSerial" href="#dopes.equipment_control.mecom.mecom.MeComSerial">MeComSerial</a></code></h4>
<ul class="">
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComSerial.SEQUENCE_COUNTER" href="#dopes.equipment_control.mecom.mecom.MeComSerial.SEQUENCE_COUNTER">SEQUENCE_COUNTER</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComSerial.stop" href="#dopes.equipment_control.mecom.mecom.MeComSerial.stop">stop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dopes.equipment_control.mecom.mecom.MeComTcp" href="#dopes.equipment_control.mecom.mecom.MeComTcp">MeComTcp</a></code></h4>
<ul class="">
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComTcp.SEQUENCE_COUNTER" href="#dopes.equipment_control.mecom.mecom.MeComTcp.SEQUENCE_COUNTER">SEQUENCE_COUNTER</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeComTcp.stop" href="#dopes.equipment_control.mecom.mecom.MeComTcp.stop">stop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dopes.equipment_control.mecom.mecom.MeFrame" href="#dopes.equipment_control.mecom.mecom.MeFrame">MeFrame</a></code></h4>
<ul class="">
<li><code><a title="dopes.equipment_control.mecom.mecom.MeFrame.CalcCRC_CCITT" href="#dopes.equipment_control.mecom.mecom.MeFrame.CalcCRC_CCITT">CalcCRC_CCITT</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeFrame.compose" href="#dopes.equipment_control.mecom.mecom.MeFrame.compose">compose</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeFrame.crc" href="#dopes.equipment_control.mecom.mecom.MeFrame.crc">crc</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.MeFrame.set_sequence" href="#dopes.equipment_control.mecom.mecom.MeFrame.set_sequence">set_sequence</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dopes.equipment_control.mecom.mecom.Parameter" href="#dopes.equipment_control.mecom.mecom.Parameter">Parameter</a></code></h4>
</li>
<li>
<h4><code><a title="dopes.equipment_control.mecom.mecom.ParameterList" href="#dopes.equipment_control.mecom.mecom.ParameterList">ParameterList</a></code></h4>
<ul class="">
<li><code><a title="dopes.equipment_control.mecom.mecom.ParameterList.get_by_id" href="#dopes.equipment_control.mecom.mecom.ParameterList.get_by_id">get_by_id</a></code></li>
<li><code><a title="dopes.equipment_control.mecom.mecom.ParameterList.get_by_name" href="#dopes.equipment_control.mecom.mecom.ParameterList.get_by_name">get_by_name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dopes.equipment_control.mecom.mecom.Query" href="#dopes.equipment_control.mecom.mecom.Query">Query</a></code></h4>
<ul class="">
<li><code><a title="dopes.equipment_control.mecom.mecom.Query.set_response" href="#dopes.equipment_control.mecom.mecom.Query.set_response">set_response</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dopes.equipment_control.mecom.mecom.RS" href="#dopes.equipment_control.mecom.mecom.RS">RS</a></code></h4>
</li>
<li>
<h4><code><a title="dopes.equipment_control.mecom.mecom.SP" href="#dopes.equipment_control.mecom.mecom.SP">SP</a></code></h4>
</li>
<li>
<h4><code><a title="dopes.equipment_control.mecom.mecom.VR" href="#dopes.equipment_control.mecom.mecom.VR">VR</a></code></h4>
</li>
<li>
<h4><code><a title="dopes.equipment_control.mecom.mecom.VRResponse" href="#dopes.equipment_control.mecom.mecom.VRResponse">VRResponse</a></code></h4>
<ul class="">
<li><code><a title="dopes.equipment_control.mecom.mecom.VRResponse.decompose" href="#dopes.equipment_control.mecom.mecom.VRResponse.decompose">decompose</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dopes.equipment_control.mecom.mecom.VS" href="#dopes.equipment_control.mecom.mecom.VS">VS</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
