<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>dopes.equipment_control.oscilloscope API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dopes.equipment_control.oscilloscope</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dopes.equipment_control.oscilloscope.oscilloscope"><code class="flex name class">
<span>class <span class="ident">oscilloscope</span></span>
<span>(</span><span>address, rm=None, timeout=10000.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class oscilloscope(equipment.equipment):
    
    &#34;&#34;&#34;Class to control tektronix oscilloscope&#34;&#34;&#34;
    
    model=&#34;MSO56,TBS2000,MSO2024&#34;
    company=&#34;tektronix&#34;
    url=&#34;https://www.tek.com/en/products/oscilloscopes/&#34;
    
    def initialize(self, channel_used={&#34;CH1&#34;:&#34;ON&#34;,&#34;CH2&#34;:&#34;OFF&#34;,&#34;CH3&#34;:&#34;OFF&#34;,&#34;CH4&#34;:&#34;OFF&#34;},
                   autoset=True,continuous=True, num_sequence=1,high_resolution=False, average=False,num_average=10,data_bytes=1, command_delay=0.02, query_delay=0.1, sync_delay=0.2):
        &#34;&#34;&#34; Function to initialize the Tektronix oscilloscope  with the desired settings
        
            args:
               \n\t- channel_used (dictionnary) : dictionnary for which the key are the name of the channel (&#34;CH1&#34;,&#34;CH2&#34;,&#34;CH3&#34;,&#34;CH4&#34;) and the value is &#34;ON&#34; or &#34;OFF&#34; to activate or desactivate the channel
               \n\t- autoset (boolean) : if True, the oscilloscope performs an autoset during the initialization
               \n\t- continuous (boolean) : if True, the oscilloscope continue running after taken an acquisition
               \n\t- num_sequence (integer) : the number of sequence the oscilloscope will take for each acquisition. This is not an averaging.
               \n\t- high_resolution (boolean) : if True, the oscilloscope will enter high resolution mode, i.e. averaging over a fixed period in fast frame acquisition. High resolution is automatically turn on when 2 bytes are asked with TBS oscilloscope
               \n\t- average (boolean) : if True, the oscilloscope will take several signal to perform an averaging
               \n\t- num_average (integer) : the number of acquisitions to make the averaging
               \n\t- data_bytes (integer) : the number of bytes for the vertical resolution of the data (1 or 2 accepted)
        &#34;&#34;&#34;
        self.SMALL_SLEEP=command_delay
        self.MID_SLEEP=query_delay
        self.BIG_SLEEP=sync_delay
        
        self.channel_used=channel_used
        self.average=average
        self.num_average=num_average
        self.data_bytes=data_bytes
        
        
        self.pyvisa_resource.encoding = &#39;ascii&#39;
        self.pyvisa_resource.read_termination = &#39;\n&#39;
        self.pyvisa_resource.write_termination = None
        self.pyvisa_resource.send_termination = False
        
        identity=self.pyvisa_resource.query(&#34;*IDN?&#34;)
        self.model_tbs= (identity.upper().find(&#34;TBS&#34;)&gt;=0)
        
        if self.model_tbs and data_bytes==2 and high_resolution==False:
            high_resolution=True
            print(&#34;TBS oscilloscope can only work under 2 bytes with high resolution mode.\nThe equipment has been swith to high resolution mode.&#34;)

        self.pyvisa_resource.write(&#39;*CLS&#39;) # clear ESR
        self.pyvisa_resource.write(&#39;*RST&#39;) # clear ESR

        for key in channel_used.keys():        
            self.pyvisa_resource.write(&#39;SELECT:%s %s&#39;%(key,channel_used[key]))
                

        if autoset:
            self.pyvisa_resource.write(&#39;autoset EXECUTE&#39;) # autoset
            time.sleep(5)
        else:
            self.pyvisa_resource.write(&#39;HORIZONTAL:MODE AUTO&#39;)
            time.sleep(1)

        self.pyvisa_resource.write(&#39;ACQUIRE:STATE OFF&#39;)

        self.pyvisa_resource.query(&#39;*opc?&#39;,delay=1) # sync

        self.pyvisa_resource.write(&#34;HEADER 0&#34;)
        self.pyvisa_resource.write(&#34;DATA:ENCDG RIBINARY&#34;)   # Signed Binary Format, LSB order
        self.pyvisa_resource.write(&#34;DATA:WIDTH %d&#34;%data_bytes) # 1 byte per sample
        self.pyvisa_resource.write(&#34;DATA:START 1&#34;)
        record = int(self.pyvisa_resource.query(&#39;horizontal:recordlength?&#39;,delay=self.MID_SLEEP))
        self.pyvisa_resource.write(&#39;data:stop {}&#39;.format(record)) # last sample
        

        if average:
            self.pyvisa_resource.write(&#39;ACQUIRE:MODE AVERAGE&#39;)
            self.pyvisa_resource.write(&#39;ACQUIRE:NUMAVG %d&#39;%num_average)
        elif high_resolution:
            self.pyvisa_resource.write(&#39;ACQUIRE:MODE HIRES&#39;)
        else:
            self.pyvisa_resource.write(&#39;ACQUIRE:MODE SAMPLE&#39;)
        
        if continuous:
            self.pyvisa_resource.write(&#39;ACQUIRE:STOPAFTER RUNSTOP&#39;)
            self.pyvisa_resource.write(&#39;ACQUIRE:STATE RUN&#39;)
        else:
            self.pyvisa_resource.write(&#39;ACQUIRE:STOPAFTER SEQUENCE&#39;)
            self.pyvisa_resource.write(&#39;ACQUIRE:SEQUENCE:NUMSEQUENCE %d&#39;%num_sequence)    

    def acquire_wave(self):
        &#34;&#34;&#34; Intermediate function to acquire the data from the Tektronix oscilloscope
        
            return:
               \n\t- scaled_time, scaled_wave (numpy array) : time and waveform data vectors

        &#34;&#34;&#34;
        
        while float(self.pyvisa_resource.query(&#39;BUSY?&#39;,delay=self.BIG_SLEEP)):
            time.sleep(self.SMALL_SLEEP)
            
        if self.data_bytes==1:
            datatype=&#34;b&#34;
        elif self.data_bytes==2:
            datatype=&#34;h&#34;
        time.sleep(self.SMALL_SLEEP)               
        bin_wave = self.pyvisa_resource.query_binary_values(&#39;curve?&#39;, datatype=datatype, container=np.array,delay=self.MID_SLEEP)
        time.sleep(self.SMALL_SLEEP)

        tscale = float(self.pyvisa_resource.query(&#39;wfmoutpre:xincr?&#39;,delay=self.MID_SLEEP))
        time.sleep(self.SMALL_SLEEP)
        tstart = float(self.pyvisa_resource.query(&#39;wfmoutpre:xzero?&#39;,delay=self.MID_SLEEP))
        time.sleep(self.SMALL_SLEEP)
        vscale = float(self.pyvisa_resource.query(&#39;wfmoutpre:ymult?&#39;,delay=self.MID_SLEEP)) # volts / level
        time.sleep(self.SMALL_SLEEP)
        voff = float(self.pyvisa_resource.query(&#39;wfmoutpre:yzero?&#39;,delay=self.MID_SLEEP)) # reference voltage
        time.sleep(self.SMALL_SLEEP)
        vpos = float(self.pyvisa_resource.query(&#39;wfmoutpre:yoff?&#39;,delay=self.MID_SLEEP)) # reference position (level)
        time.sleep(self.SMALL_SLEEP)
        record = int(self.pyvisa_resource.query(&#39;horizontal:recordlength?&#39;,delay=self.MID_SLEEP))
        # create scaled vectors
        # horizontal (time)
        total_time = tscale * record
        tstop = tstart + total_time
        scaled_time = np.linspace(tstart, tstop, num=record, endpoint=False)
        # vertical (voltage)
        unscaled_wave = np.array(bin_wave, dtype=datatype) # data type conversion
        scaled_wave = (unscaled_wave - vpos) * vscale + voff
        
        return scaled_time, scaled_wave
            
    def acquire_single_channel(self,channel=&#34;CH1&#34;, force_trig=False):
        &#34;&#34;&#34; Function to acquire the data of a single channel from the Tektronix oscilloscope 
            
            args:
                \n\t- channel (string) : the channel from which the data has to be taken
                \n\t- force_trig (boolean) : if True, force the trigger to acquire the data. If False, an other trigger mechanism has to be used or manual triggering has to be done.
            return:
               \n\t- scaled_time, scaled_wave (numpy array) : time and waveform data vectors

        &#34;&#34;&#34;
        self.pyvisa_resource.write(&#39;ACQUIRE:STATE ON&#39;)
        time.sleep(self.MID_SLEEP)
        if force_trig:
            if self.average:
                for i in range(self.num_average):
                    self.pyvisa_resource.write(&#39;TRIGGER FORCE&#39;)
                    time.sleep(self.MID_SLEEP)
            else:
                self.pyvisa_resource.write(&#39;TRIGGER FORCE&#39;)

        while float(self.pyvisa_resource.query(&#39;BUSY?&#39;,delay=self.BIG_SLEEP)):
            time.sleep(self.SMALL_SLEEP)
        time.sleep(self.SMALL_SLEEP)

        self.pyvisa_resource.write(&#34;DATA:SOURCE %s&#34;%channel)
        time.sleep(self.MID_SLEEP)
        scaled_time, scaled_wave=self.acquire_wave()
        return scaled_time, scaled_wave
        
    def acquire_all_channels(self, force_trig=False):
        &#34;&#34;&#34; Function to acquire the data of all active channels from the Tektronix oscilloscope 
            
            args:
                \n\t- force_trig (boolean) : if True, force the trigger to acquire the data. If False, an other trigger mechanism has to be used or manual triggering has to be done.
            return:
               \n\t- scaled_time, scaled_wave (numpy array) : time and waveform data vectors

        &#34;&#34;&#34;
        
        self.pyvisa_resource.write(&#39;ACQUIRE:STATE ON&#39;)
        time.sleep(self.MID_SLEEP)

        if self.average:
            for i in range(self.num_average):
                self.pyvisa_resource.write(&#39;TRIGGER FORCE&#39;)
                time.sleep(self.MID_SLEEP)
        else:
            time.sleep(self.MID_SLEEP)
            self.pyvisa_resource.write(&#39;TRIGGER FORCE&#39;)


        while float(self.pyvisa_resource.query(&#39;BUSY?&#39;,delay=self.BIG_SLEEP)):
            time.sleep(self.SMALL_SLEEP)

        scaled_time={}
        scaled_wave={}
        for channel in self.channel_used.keys():
            if self.channel_used[channel].upper()==&#34;ON&#34; or self.channel_used[channel]==1:
                self.pyvisa_resource.write(&#34;DATA:SOURCE %s&#34;%channel)
                scaled_time[channel], scaled_wave[channel]=self.acquire_wave()
                time.sleep(self.MID_SLEEP)

        return scaled_time, scaled_wave

    def get_measurement(self,channel,meas_type,ref_channel=&#34;CH1&#34;):
        &#34;&#34;&#34; Function to get the measurement from a previous acquisition  
            
            args:
                \n\t- channel (string) : the channel on which the measurement has to be done
                \n\t- meas_type (string) : the measurement that has to be done. Possible measurements are &#34;FREQUENCY&#34;, &#34;AMPLITUDE&#34;, &#34;MIN&#34;, &#34;MAX&#34;, &#34;MEAN&#34;, &#34;RMS&#34;, &#34;PHASE&#34;, &#34;PK2Pk&#34;
                \n\t- ref_channel (string) : the reference channel if phase measurement is asked

            return:
               \n\t- meas (scalar) : the value of the measurement taken
 
        &#34;&#34;&#34;
        while float(self.pyvisa_resource.query(&#39;BUSY?&#39;,delay=self.BIG_SLEEP)):
            time.sleep(self.SMALL_SLEEP)
    
        time.sleep(self.SMALL_SLEEP)
    
        if meas_type.upper()==&#34;PHASE&#34;:
            self.pyvisa_resource.write(&#39;MEASUREMENT:IMMED:TYPE %s&#39;%meas_type)
            time.sleep(self.SMALL_SLEEP)
            self.pyvisa_resource.write(&#39;MEASUREMENT:IMMED:SOURCE1 %s&#39;%channel)
            time.sleep(self.SMALL_SLEEP)
            self.pyvisa_resource.write(&#39;MEASUREMENT:IMMED:SOURCE2 %s&#39;%ref_channel)
            time.sleep(self.SMALL_SLEEP)
            self.pyvisa_resource.write(&#34;MEASUREMENT:IMMED:TOEDGE OPPositeas&#34;)
            time.sleep(self.SMALL_SLEEP)
            print(self.pyvisa_resource.query(&#39;MEASUREMENT:IMMED:VALUE?&#39;, delay=self.MID_SLEEP))
            meas=float(self.pyvisa_resource.query(&#39;MEASUREMENT:IMMED:VALUE?&#39;, delay=self.MID_SLEEP))-180
            
        else:
            self.pyvisa_resource.write(&#39;MEASUREMENT:IMMED:TYPE %s&#39;%meas_type)
            time.sleep(self.SMALL_SLEEP)
    
            self.pyvisa_resource.write(&#39;MEASUREMENT:IMMED:SOURCE1 %s&#39;%channel)
            time.sleep(self.SMALL_SLEEP)
            meas=self.pyvisa_resource.query(&#39;MEASUREMENT:IMMED:VALUE?&#39;, delay=self.BIG_SLEEP)
        return float(meas)
    
    def get_measurement_list(self,channel,meas_list,ref_channel=&#34;CH1&#34;):
        &#34;&#34;&#34; Function to get a list of measurements from a previous acquisition  
            
            args:
                \n\t- channel (string) : the channel on which the measurement has to be done
                \n\t- meas_list (list of string) : the list of measurements that have to be done. Possible measurements are &#34;FREQUENCY&#34;, &#34;AMPLITUDE&#34;, &#34;MIN&#34;, &#34;MAX&#34;, &#34;MEAN&#34;, &#34;RMS&#34;, &#34;PHASE&#34;, &#34;PK2Pk&#34;
                \n\t- ref_channel (string) : the reference channel if phase measurement is asked

            return:
               \n\t- meas_dic (dictionnary) : dictionnary with the value of the measurements. The keys of the dictionnary are meas_list
 
        &#34;&#34;&#34;        
        meas_dic={}
        for meas_type in meas_list:
            time.sleep(self.SMALL_SLEEP)
            meas_dic[meas_type]=self.get_measurement(channel,meas_type,ref_channel)
    
            
        return meas_dic
        
    
    def acquire_channels_with_measurement(self,meas_list,force_trig=False,ref_channel=&#34;CH1&#34;):
        &#34;&#34;&#34; Function to acquire the data of all active channels from the Tektronix oscilloscope along a list of measurements
            
            args:
                \n\t- meas_list (list of string) : the list of measurements that have to be done. Possible measurements are &#34;FREQUENCY&#34;, &#34;AMPLITUDE&#34;, &#34;MIN&#34;, &#34;MAX&#34;, &#34;MEAN&#34;, &#34;RMS&#34;, &#34;PHASE&#34;, &#34;PK2Pk&#34;
                \n\t- ref_channel (string) : the reference channel if phase measurement is asked
                \n\t- force_trig (boolean) : if True, force the trigger to acquire the data. If False, an other trigger mechanism has to be used or manual triggering has to be done.
            return:
               \n\t- scaled_time, scaled_wave (numpy array) : time and waveform data vectors
               \n\t- measurement (dictionnary) : dictionnary with the value of the measurements. The first key of the dictionnary is the channel (ex. &#34;CH1&#34;) while the second key is the measurement name from meas_list. For example, measurement[&#34;CH1&#34;][&#34;AMPLITUDE&#34;] gives the amplitude calculated from the channel 1 signal
    
        &#34;&#34;&#34;
        
        self.pyvisa_resource.write(&#39;ACQUIRE:STATE ON&#39;)
        time.sleep(self.MID_SLEEP)
    
        if self.average:
            for i in range(self.num_average):
                self.pyvisa_resource.write(&#39;TRIGGER FORCE&#39;)
                time.sleep(self.MID_SLEEP)
        else:
            self.pyvisa_resource.write(&#39;TRIGGER FORCE&#39;)
    
        while float(self.pyvisa_resource.query(&#39;BUSY?&#39;,delay=self.BIG_SLEEP)):
            time.sleep(self.SMALL_SLEEP)
    
        time.sleep(self.SMALL_SLEEP)
    
        scaled_time={}
        scaled_wave={}
        measurement={}
    
        for channel in self.channel_used.keys():
            if self.channel_used[channel].upper()==&#34;ON&#34; or self.channel_used[channel]==1:
                self.pyvisa_resource.write(&#34;DATA:SOURCE1 %s&#34;%channel)
                time.sleep(self.MID_SLEEP)
                scaled_time[channel], scaled_wave[channel]=self.acquire_wave()
                measurement[channel]=self.get_measurement_list(channel,meas_list,ref_channel)
    
        return scaled_time, scaled_wave, measurement
    
    def acquire_single_channel_with_measurement(self,meas_list,channel,ref_channel=&#34;CH1&#34;, force_trig=False):
        &#34;&#34;&#34; Function to acquire the data of a single channel from the Tektronix oscilloscope along a list of measurements
            
            args:
                \n\t- meas_list (list of string) : the list of measurements that have to be done. Possible measurements are &#34;FREQUENCY&#34;, &#34;AMPLITUDE&#34;, &#34;MIN&#34;, &#34;MAX&#34;, &#34;MEAN&#34;, &#34;RMS&#34;, &#34;PHASE&#34;, &#34;PK2Pk&#34;
                \n\t- channel (string) : the channel on which the measurement has to be done
                \n\t- ref_channel (string) : the reference channel if phase measurement is asked
                \n\t- force_trig (boolean) : if True, force the trigger to acquire the data. If False, an other trigger mechanism has to be used or manual triggering has to be done.
            return:
               \n\t- scaled_time, scaled_wave (numpy array) : time and waveform data vectors
               \n\t- measurement (dictionnary) : dictionnary with the value of the measurements. The keys of the dictionnary are meas_list
                
        &#34;&#34;&#34;
        self.pyvisa_resource.write(&#39;ACQUIRE:STATE ON&#39;)
        time.sleep(self.MID_SLEEP)
        if force_trig:
            if self.average:
                for i in range(self.num_average):
                    self.pyvisa_resource.write(&#39;TRIGGER FORCE&#39;)
                    time.sleep(self.MID_SLEEP)
            else:
                self.pyvisa_resource.write(&#39;TRIGGER FORCE&#39;)
    
        while float(self.pyvisa_resource.query(&#39;BUSY?&#39;,delay=self.BIG_SLEEP)):
            time.sleep(self.SMALL_SLEEP)
    
        time.sleep(self.SMALL_SLEEP)
    
        self.pyvisa_resource.write(&#34;DATA:SOURCE1 %s&#34;%channel)
        time.sleep(self.MID_SLEEP)
        scaled_time, scaled_wave=self.acquire_wave()
        measurement=self.get_measurement_list(channel,meas_list,ref_channel)
        return scaled_time, scaled_wave,measurement
        
    def set_edge_trigger(self,channel=&#34;CH1&#34;, level=0):
        &#34;&#34;&#34; Function to set a rising edge trigger 
            
            args:
                \n\t- channel (string) : specify the channel for the triggering mechanism
                \n\t- level (scalar) : the voltage level of trigger

        &#34;&#34;&#34;
        
        time.sleep(self.SMALL_SLEEP)
        self.pyvisa_resource.write(&#39;TRIGger:A:TYPe EDGE&#39;)
        time.sleep(self.SMALL_SLEEP)
        self.pyvisa_resource.write(&#39;TRIGger:A:EDGE:SOUrce %s&#39;%channel)
        time.sleep(self.SMALL_SLEEP)
        self.pyvisa_resource.write(&#39;TRIGger:A:LEVel:%s %f&#39;%(channel,level))
        time.sleep(self.SMALL_SLEEP)
        self.pyvisa_resource.write(&#34;TRIG:A:EDGE:SLOPE RIS&#34;)

        
    def set_horizontal_properties(self,record_length,sample_rate):
        &#34;&#34;&#34; Function to set the horizontal (time axis) properties of the oscilloscope 
            
            args:
                \n\t- record_length (integer) : specify the number of points for the acquisition. For TBS2000, the suppored values are: 1000, 2000, 20000, 200000, 2000000, and 5000000. For MSO2024, the suppored values are 100000, and 1000000.
                \n\t- sample_rate (scalar) : specify the sampling rate in samples/s for the acquisition. The total time window can then be calculated as record_length/sampling_rate

        &#34;&#34;&#34;

        while float(self.pyvisa_resource.query(&#39;BUSY?&#39;,delay=self.BIG_SLEEP)):
            time.sleep(self.SMALL_SLEEP)

        # record_length max = 125e6
        # sample_rate max = 500e9 sample/seconds
        time.sleep(self.SMALL_SLEEP)

        self.pyvisa_resource.write(&#39;HORIZONTAL:MODE MANUAL&#39;)
        time.sleep(self.SMALL_SLEEP)
        self.pyvisa_resource.write(&#39;HORizontal:MODe:MANual:CONFIGure RECORDLength&#39;)
        time.sleep(self.SMALL_SLEEP)
        self.pyvisa_resource.write(&#39;HORIZONTAL:RECORDLENGTH %e&#39;%record_length)
        time.sleep(self.SMALL_SLEEP)
        true_record_length = int(self.pyvisa_resource.query(&#39;horizontal:recordlength?&#39;,delay=self.MID_SLEEP))
        if self.model_tbs:
            n_divisions=int(float(self.pyvisa_resource.query(&#39;HORizontal:DIVisions?&#39;)))
            self.pyvisa_resource.write(&#39;HORIZONTAL:SCALE %.3e&#39;%(true_record_length/sample_rate/n_divisions))            
        else:            
            self.pyvisa_resource.write(&#39;HORIZONTAL:SAMPLERATE %e&#39;%sample_rate)
        
        time.sleep(self.SMALL_SLEEP)
        self.pyvisa_resource.write(&#39;data:stop %e&#39;%true_record_length) # last sample

        
    def set_channel_properties(self, channel, scale, offset=0, coupling=&#34;DC&#34;, bandwidth=&#34;FULL&#34;, termination=1e6):
        &#34;&#34;&#34; Function to set the properties of a channel of the oscilloscope 
            
            args:
                \n\t- channel (string) : the channel from which the data has to be taken
                \n\t- scale (scalar) : the dimension of one vertical divistion in Volts. The full scale is made of 10 divisions
                \n\t- offset (scalar) : the offset in volt of the vertical position of the signal
                \n\t- coupling (string) : the coupling of the channel. Choice between &#34;AC&#34; to remove the DC component or &#34;DC&#34; to keep it
                \n\t- bandwidth (scalar or string) : the selectable low-pass bandwidth limit filter of the specified channel. &#34;FULL&#34; disables any optional bandwidth limiting. The specified channel operates at its maximum bandwidth.
                \n\t- termination (scalar) : The vertical termination for the specified analog channel. Choice between 50 or 1e6 Ohms. 

        &#34;&#34;&#34;
        
        while float(self.pyvisa_resource.query(&#39;BUSY?&#39;,delay=self.BIG_SLEEP)):
            time.sleep(self.SMALL_SLEEP)
        time.sleep(self.SMALL_SLEEP)

        self.pyvisa_resource.write(&#39;%s:SCALE %e&#39;%(channel,scale))
        time.sleep(self.SMALL_SLEEP)
        self.pyvisa_resource.write(&#39;%s:TERmination %e&#39;%(channel,termination))
        time.sleep(self.SMALL_SLEEP)
        self.pyvisa_resource.write(&#39;%s:OFFSet %e&#39;%(channel,offset))
        time.sleep(self.SMALL_SLEEP)
        self.pyvisa_resource.write(&#39;%s:COUPLING %s&#39;%(channel,coupling))
        time.sleep(self.SMALL_SLEEP)
        if bandwidth.upper()==&#34;FULL&#34;:
            self.pyvisa_resource.write(&#39;%s:BANdwidth %s&#39;%(channel,bandwidth))
        else:
            self.pyvisa_resource.write(&#39;%s:BANdwidth %e&#39;%(channel,bandwidth))
                    
    def set_state(self, state=&#34;ON&#34;):
        &#34;&#34;&#34; Function to set the acquisition state 
            
            args:
                \n\t- state (string) : When state is set to &#34;ON&#34; or &#34;RUN&#34;, a new acquisition will be started. When state is set to &#34;OFF&#34; or &#34;STOP&#34;, the acquisition is stopped.
                If the last acquisition was a single acquisition sequence, a new single sequence acquisition will be started. If the last acquisition was continuous, a new continuous acquisition will be started.
                If &#34;RUN&#34; is issued in the middle of completing a single sequence acquisition (for example, averaging or enveloping), the acquisition sequence is restarted, 
                and any accumulated data is discarded. Also, the instrument resets the number of acquisitions. If the &#34;RUN&#34; argument is issued while in continuous mode, a reset occurs and acquired data continues to acquire.
        &#34;&#34;&#34;
        time.sleep(self.SMALL_SLEEP)
        self.pyvisa_resource.write(&#39;ACQUIRE:STATE %s&#39;%state)

    def get_sample_rate(self):
        &#34;&#34;&#34; Function to get the effective sample rate 
            
            return:
                \n\t- sample_rate (float) : the effective sample rate
        
        &#34;&#34;&#34;
        
        time.sleep(self.SMALL_SLEEP)
        sample_rate=float(self.pyvisa_resource.query(&#39;HORizontal:SAMPLERate?&#39;))
        return sample_rate
        
    def force_trig(self):
        &#34;&#34;&#34; Function to force the triggering of the oscilloscope 
        &#34;&#34;&#34;
        if self.average:
            for i in range(self.num_average):
                self.pyvisa_resource.write(&#39;TRIGGER FORCE&#39;)
                time.sleep(self.MID_SLEEP)
        else:
            self.pyvisa_resource.write(&#39;TRIGGER FORCE&#39;)</code></pre>
</details>
<div class="desc"><p>Class to control tektronix oscilloscope</p>
<p>Function called when an instance of the class is created</p>
<pre><code>args:
</code></pre>
<ul>
<li>
<p>address (string) : the address of the equipment to be connected</p>
</li>
<li>
<p>rm (pyvisa object) : the pyvisa resource manager used to set the communication with the equipment</p>
</li>
<li>
<p>timeout (scalar) : the timeout set for the communication with the equipment</p>
</li>
</ul></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dopes.equipment_control.equipment.equipment" href="equipment.html#dopes.equipment_control.equipment.equipment">equipment</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="dopes.equipment_control.oscilloscope.oscilloscope.company"><code class="name">var <span class="ident">company</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dopes.equipment_control.oscilloscope.oscilloscope.model"><code class="name">var <span class="ident">model</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="dopes.equipment_control.oscilloscope.oscilloscope.url"><code class="name">var <span class="ident">url</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dopes.equipment_control.oscilloscope.oscilloscope.acquire_all_channels"><code class="name flex">
<span>def <span class="ident">acquire_all_channels</span></span>(<span>self, force_trig=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acquire_all_channels(self, force_trig=False):
    &#34;&#34;&#34; Function to acquire the data of all active channels from the Tektronix oscilloscope 
        
        args:
            \n\t- force_trig (boolean) : if True, force the trigger to acquire the data. If False, an other trigger mechanism has to be used or manual triggering has to be done.
        return:
           \n\t- scaled_time, scaled_wave (numpy array) : time and waveform data vectors

    &#34;&#34;&#34;
    
    self.pyvisa_resource.write(&#39;ACQUIRE:STATE ON&#39;)
    time.sleep(self.MID_SLEEP)

    if self.average:
        for i in range(self.num_average):
            self.pyvisa_resource.write(&#39;TRIGGER FORCE&#39;)
            time.sleep(self.MID_SLEEP)
    else:
        time.sleep(self.MID_SLEEP)
        self.pyvisa_resource.write(&#39;TRIGGER FORCE&#39;)


    while float(self.pyvisa_resource.query(&#39;BUSY?&#39;,delay=self.BIG_SLEEP)):
        time.sleep(self.SMALL_SLEEP)

    scaled_time={}
    scaled_wave={}
    for channel in self.channel_used.keys():
        if self.channel_used[channel].upper()==&#34;ON&#34; or self.channel_used[channel]==1:
            self.pyvisa_resource.write(&#34;DATA:SOURCE %s&#34;%channel)
            scaled_time[channel], scaled_wave[channel]=self.acquire_wave()
            time.sleep(self.MID_SLEEP)

    return scaled_time, scaled_wave</code></pre>
</details>
<div class="desc"><p>Function to acquire the data of all active channels from the Tektronix oscilloscope </p>
<pre><code>args:
</code></pre>
<ul>
<li>
<p>force_trig (boolean) : if True, force the trigger to acquire the data. If False, an other trigger mechanism has to be used or manual triggering has to be done.
return:</p>
</li>
<li>
<p>scaled_time, scaled_wave (numpy array) : time and waveform data vectors</p>
</li>
</ul></div>
</dd>
<dt id="dopes.equipment_control.oscilloscope.oscilloscope.acquire_channels_with_measurement"><code class="name flex">
<span>def <span class="ident">acquire_channels_with_measurement</span></span>(<span>self, meas_list, force_trig=False, ref_channel='CH1')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acquire_channels_with_measurement(self,meas_list,force_trig=False,ref_channel=&#34;CH1&#34;):
    &#34;&#34;&#34; Function to acquire the data of all active channels from the Tektronix oscilloscope along a list of measurements
        
        args:
            \n\t- meas_list (list of string) : the list of measurements that have to be done. Possible measurements are &#34;FREQUENCY&#34;, &#34;AMPLITUDE&#34;, &#34;MIN&#34;, &#34;MAX&#34;, &#34;MEAN&#34;, &#34;RMS&#34;, &#34;PHASE&#34;, &#34;PK2Pk&#34;
            \n\t- ref_channel (string) : the reference channel if phase measurement is asked
            \n\t- force_trig (boolean) : if True, force the trigger to acquire the data. If False, an other trigger mechanism has to be used or manual triggering has to be done.
        return:
           \n\t- scaled_time, scaled_wave (numpy array) : time and waveform data vectors
           \n\t- measurement (dictionnary) : dictionnary with the value of the measurements. The first key of the dictionnary is the channel (ex. &#34;CH1&#34;) while the second key is the measurement name from meas_list. For example, measurement[&#34;CH1&#34;][&#34;AMPLITUDE&#34;] gives the amplitude calculated from the channel 1 signal

    &#34;&#34;&#34;
    
    self.pyvisa_resource.write(&#39;ACQUIRE:STATE ON&#39;)
    time.sleep(self.MID_SLEEP)

    if self.average:
        for i in range(self.num_average):
            self.pyvisa_resource.write(&#39;TRIGGER FORCE&#39;)
            time.sleep(self.MID_SLEEP)
    else:
        self.pyvisa_resource.write(&#39;TRIGGER FORCE&#39;)

    while float(self.pyvisa_resource.query(&#39;BUSY?&#39;,delay=self.BIG_SLEEP)):
        time.sleep(self.SMALL_SLEEP)

    time.sleep(self.SMALL_SLEEP)

    scaled_time={}
    scaled_wave={}
    measurement={}

    for channel in self.channel_used.keys():
        if self.channel_used[channel].upper()==&#34;ON&#34; or self.channel_used[channel]==1:
            self.pyvisa_resource.write(&#34;DATA:SOURCE1 %s&#34;%channel)
            time.sleep(self.MID_SLEEP)
            scaled_time[channel], scaled_wave[channel]=self.acquire_wave()
            measurement[channel]=self.get_measurement_list(channel,meas_list,ref_channel)

    return scaled_time, scaled_wave, measurement</code></pre>
</details>
<div class="desc"><p>Function to acquire the data of all active channels from the Tektronix oscilloscope along a list of measurements</p>
<pre><code>args:
</code></pre>
<ul>
<li>
<p>meas_list (list of string) : the list of measurements that have to be done. Possible measurements are "FREQUENCY", "AMPLITUDE", "MIN", "MAX", "MEAN", "RMS", "PHASE", "PK2Pk"</p>
</li>
<li>
<p>ref_channel (string) : the reference channel if phase measurement is asked</p>
</li>
<li>
<p>force_trig (boolean) : if True, force the trigger to acquire the data. If False, an other trigger mechanism has to be used or manual triggering has to be done.
return:</p>
</li>
<li>
<p>scaled_time, scaled_wave (numpy array) : time and waveform data vectors</p>
</li>
<li>
<p>measurement (dictionnary) : dictionnary with the value of the measurements. The first key of the dictionnary is the channel (ex. "CH1") while the second key is the measurement name from meas_list. For example, measurement["CH1"]["AMPLITUDE"] gives the amplitude calculated from the channel 1 signal</p>
</li>
</ul></div>
</dd>
<dt id="dopes.equipment_control.oscilloscope.oscilloscope.acquire_single_channel"><code class="name flex">
<span>def <span class="ident">acquire_single_channel</span></span>(<span>self, channel='CH1', force_trig=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acquire_single_channel(self,channel=&#34;CH1&#34;, force_trig=False):
    &#34;&#34;&#34; Function to acquire the data of a single channel from the Tektronix oscilloscope 
        
        args:
            \n\t- channel (string) : the channel from which the data has to be taken
            \n\t- force_trig (boolean) : if True, force the trigger to acquire the data. If False, an other trigger mechanism has to be used or manual triggering has to be done.
        return:
           \n\t- scaled_time, scaled_wave (numpy array) : time and waveform data vectors

    &#34;&#34;&#34;
    self.pyvisa_resource.write(&#39;ACQUIRE:STATE ON&#39;)
    time.sleep(self.MID_SLEEP)
    if force_trig:
        if self.average:
            for i in range(self.num_average):
                self.pyvisa_resource.write(&#39;TRIGGER FORCE&#39;)
                time.sleep(self.MID_SLEEP)
        else:
            self.pyvisa_resource.write(&#39;TRIGGER FORCE&#39;)

    while float(self.pyvisa_resource.query(&#39;BUSY?&#39;,delay=self.BIG_SLEEP)):
        time.sleep(self.SMALL_SLEEP)
    time.sleep(self.SMALL_SLEEP)

    self.pyvisa_resource.write(&#34;DATA:SOURCE %s&#34;%channel)
    time.sleep(self.MID_SLEEP)
    scaled_time, scaled_wave=self.acquire_wave()
    return scaled_time, scaled_wave</code></pre>
</details>
<div class="desc"><p>Function to acquire the data of a single channel from the Tektronix oscilloscope </p>
<pre><code>args:
</code></pre>
<ul>
<li>
<p>channel (string) : the channel from which the data has to be taken</p>
</li>
<li>
<p>force_trig (boolean) : if True, force the trigger to acquire the data. If False, an other trigger mechanism has to be used or manual triggering has to be done.
return:</p>
</li>
<li>
<p>scaled_time, scaled_wave (numpy array) : time and waveform data vectors</p>
</li>
</ul></div>
</dd>
<dt id="dopes.equipment_control.oscilloscope.oscilloscope.acquire_single_channel_with_measurement"><code class="name flex">
<span>def <span class="ident">acquire_single_channel_with_measurement</span></span>(<span>self, meas_list, channel, ref_channel='CH1', force_trig=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acquire_single_channel_with_measurement(self,meas_list,channel,ref_channel=&#34;CH1&#34;, force_trig=False):
    &#34;&#34;&#34; Function to acquire the data of a single channel from the Tektronix oscilloscope along a list of measurements
        
        args:
            \n\t- meas_list (list of string) : the list of measurements that have to be done. Possible measurements are &#34;FREQUENCY&#34;, &#34;AMPLITUDE&#34;, &#34;MIN&#34;, &#34;MAX&#34;, &#34;MEAN&#34;, &#34;RMS&#34;, &#34;PHASE&#34;, &#34;PK2Pk&#34;
            \n\t- channel (string) : the channel on which the measurement has to be done
            \n\t- ref_channel (string) : the reference channel if phase measurement is asked
            \n\t- force_trig (boolean) : if True, force the trigger to acquire the data. If False, an other trigger mechanism has to be used or manual triggering has to be done.
        return:
           \n\t- scaled_time, scaled_wave (numpy array) : time and waveform data vectors
           \n\t- measurement (dictionnary) : dictionnary with the value of the measurements. The keys of the dictionnary are meas_list
            
    &#34;&#34;&#34;
    self.pyvisa_resource.write(&#39;ACQUIRE:STATE ON&#39;)
    time.sleep(self.MID_SLEEP)
    if force_trig:
        if self.average:
            for i in range(self.num_average):
                self.pyvisa_resource.write(&#39;TRIGGER FORCE&#39;)
                time.sleep(self.MID_SLEEP)
        else:
            self.pyvisa_resource.write(&#39;TRIGGER FORCE&#39;)

    while float(self.pyvisa_resource.query(&#39;BUSY?&#39;,delay=self.BIG_SLEEP)):
        time.sleep(self.SMALL_SLEEP)

    time.sleep(self.SMALL_SLEEP)

    self.pyvisa_resource.write(&#34;DATA:SOURCE1 %s&#34;%channel)
    time.sleep(self.MID_SLEEP)
    scaled_time, scaled_wave=self.acquire_wave()
    measurement=self.get_measurement_list(channel,meas_list,ref_channel)
    return scaled_time, scaled_wave,measurement</code></pre>
</details>
<div class="desc"><p>Function to acquire the data of a single channel from the Tektronix oscilloscope along a list of measurements</p>
<pre><code>args:
</code></pre>
<ul>
<li>
<p>meas_list (list of string) : the list of measurements that have to be done. Possible measurements are "FREQUENCY", "AMPLITUDE", "MIN", "MAX", "MEAN", "RMS", "PHASE", "PK2Pk"</p>
</li>
<li>
<p>channel (string) : the channel on which the measurement has to be done</p>
</li>
<li>
<p>ref_channel (string) : the reference channel if phase measurement is asked</p>
</li>
<li>
<p>force_trig (boolean) : if True, force the trigger to acquire the data. If False, an other trigger mechanism has to be used or manual triggering has to be done.
return:</p>
</li>
<li>
<p>scaled_time, scaled_wave (numpy array) : time and waveform data vectors</p>
</li>
<li>
<p>measurement (dictionnary) : dictionnary with the value of the measurements. The keys of the dictionnary are meas_list</p>
</li>
</ul></div>
</dd>
<dt id="dopes.equipment_control.oscilloscope.oscilloscope.acquire_wave"><code class="name flex">
<span>def <span class="ident">acquire_wave</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acquire_wave(self):
    &#34;&#34;&#34; Intermediate function to acquire the data from the Tektronix oscilloscope
    
        return:
           \n\t- scaled_time, scaled_wave (numpy array) : time and waveform data vectors

    &#34;&#34;&#34;
    
    while float(self.pyvisa_resource.query(&#39;BUSY?&#39;,delay=self.BIG_SLEEP)):
        time.sleep(self.SMALL_SLEEP)
        
    if self.data_bytes==1:
        datatype=&#34;b&#34;
    elif self.data_bytes==2:
        datatype=&#34;h&#34;
    time.sleep(self.SMALL_SLEEP)               
    bin_wave = self.pyvisa_resource.query_binary_values(&#39;curve?&#39;, datatype=datatype, container=np.array,delay=self.MID_SLEEP)
    time.sleep(self.SMALL_SLEEP)

    tscale = float(self.pyvisa_resource.query(&#39;wfmoutpre:xincr?&#39;,delay=self.MID_SLEEP))
    time.sleep(self.SMALL_SLEEP)
    tstart = float(self.pyvisa_resource.query(&#39;wfmoutpre:xzero?&#39;,delay=self.MID_SLEEP))
    time.sleep(self.SMALL_SLEEP)
    vscale = float(self.pyvisa_resource.query(&#39;wfmoutpre:ymult?&#39;,delay=self.MID_SLEEP)) # volts / level
    time.sleep(self.SMALL_SLEEP)
    voff = float(self.pyvisa_resource.query(&#39;wfmoutpre:yzero?&#39;,delay=self.MID_SLEEP)) # reference voltage
    time.sleep(self.SMALL_SLEEP)
    vpos = float(self.pyvisa_resource.query(&#39;wfmoutpre:yoff?&#39;,delay=self.MID_SLEEP)) # reference position (level)
    time.sleep(self.SMALL_SLEEP)
    record = int(self.pyvisa_resource.query(&#39;horizontal:recordlength?&#39;,delay=self.MID_SLEEP))
    # create scaled vectors
    # horizontal (time)
    total_time = tscale * record
    tstop = tstart + total_time
    scaled_time = np.linspace(tstart, tstop, num=record, endpoint=False)
    # vertical (voltage)
    unscaled_wave = np.array(bin_wave, dtype=datatype) # data type conversion
    scaled_wave = (unscaled_wave - vpos) * vscale + voff
    
    return scaled_time, scaled_wave</code></pre>
</details>
<div class="desc"><p>Intermediate function to acquire the data from the Tektronix oscilloscope</p>
<pre><code>return:
</code></pre>
<ul>
<li>scaled_time, scaled_wave (numpy array) : time and waveform data vectors</li>
</ul></div>
</dd>
<dt id="dopes.equipment_control.oscilloscope.oscilloscope.force_trig"><code class="name flex">
<span>def <span class="ident">force_trig</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def force_trig(self):
    &#34;&#34;&#34; Function to force the triggering of the oscilloscope 
    &#34;&#34;&#34;
    if self.average:
        for i in range(self.num_average):
            self.pyvisa_resource.write(&#39;TRIGGER FORCE&#39;)
            time.sleep(self.MID_SLEEP)
    else:
        self.pyvisa_resource.write(&#39;TRIGGER FORCE&#39;)</code></pre>
</details>
<div class="desc"><p>Function to force the triggering of the oscilloscope</p></div>
</dd>
<dt id="dopes.equipment_control.oscilloscope.oscilloscope.get_measurement"><code class="name flex">
<span>def <span class="ident">get_measurement</span></span>(<span>self, channel, meas_type, ref_channel='CH1')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_measurement(self,channel,meas_type,ref_channel=&#34;CH1&#34;):
    &#34;&#34;&#34; Function to get the measurement from a previous acquisition  
        
        args:
            \n\t- channel (string) : the channel on which the measurement has to be done
            \n\t- meas_type (string) : the measurement that has to be done. Possible measurements are &#34;FREQUENCY&#34;, &#34;AMPLITUDE&#34;, &#34;MIN&#34;, &#34;MAX&#34;, &#34;MEAN&#34;, &#34;RMS&#34;, &#34;PHASE&#34;, &#34;PK2Pk&#34;
            \n\t- ref_channel (string) : the reference channel if phase measurement is asked

        return:
           \n\t- meas (scalar) : the value of the measurement taken

    &#34;&#34;&#34;
    while float(self.pyvisa_resource.query(&#39;BUSY?&#39;,delay=self.BIG_SLEEP)):
        time.sleep(self.SMALL_SLEEP)

    time.sleep(self.SMALL_SLEEP)

    if meas_type.upper()==&#34;PHASE&#34;:
        self.pyvisa_resource.write(&#39;MEASUREMENT:IMMED:TYPE %s&#39;%meas_type)
        time.sleep(self.SMALL_SLEEP)
        self.pyvisa_resource.write(&#39;MEASUREMENT:IMMED:SOURCE1 %s&#39;%channel)
        time.sleep(self.SMALL_SLEEP)
        self.pyvisa_resource.write(&#39;MEASUREMENT:IMMED:SOURCE2 %s&#39;%ref_channel)
        time.sleep(self.SMALL_SLEEP)
        self.pyvisa_resource.write(&#34;MEASUREMENT:IMMED:TOEDGE OPPositeas&#34;)
        time.sleep(self.SMALL_SLEEP)
        print(self.pyvisa_resource.query(&#39;MEASUREMENT:IMMED:VALUE?&#39;, delay=self.MID_SLEEP))
        meas=float(self.pyvisa_resource.query(&#39;MEASUREMENT:IMMED:VALUE?&#39;, delay=self.MID_SLEEP))-180
        
    else:
        self.pyvisa_resource.write(&#39;MEASUREMENT:IMMED:TYPE %s&#39;%meas_type)
        time.sleep(self.SMALL_SLEEP)

        self.pyvisa_resource.write(&#39;MEASUREMENT:IMMED:SOURCE1 %s&#39;%channel)
        time.sleep(self.SMALL_SLEEP)
        meas=self.pyvisa_resource.query(&#39;MEASUREMENT:IMMED:VALUE?&#39;, delay=self.BIG_SLEEP)
    return float(meas)</code></pre>
</details>
<div class="desc"><p>Function to get the measurement from a previous acquisition
</p>
<pre><code>args:
</code></pre>
<ul>
<li>
<p>channel (string) : the channel on which the measurement has to be done</p>
</li>
<li>
<p>meas_type (string) : the measurement that has to be done. Possible measurements are "FREQUENCY", "AMPLITUDE", "MIN", "MAX", "MEAN", "RMS", "PHASE", "PK2Pk"</p>
</li>
<li>
<p>ref_channel (string) : the reference channel if phase measurement is asked</p>
<p>return:</p>
</li>
<li>
<p>meas (scalar) : the value of the measurement taken</p>
</li>
</ul></div>
</dd>
<dt id="dopes.equipment_control.oscilloscope.oscilloscope.get_measurement_list"><code class="name flex">
<span>def <span class="ident">get_measurement_list</span></span>(<span>self, channel, meas_list, ref_channel='CH1')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_measurement_list(self,channel,meas_list,ref_channel=&#34;CH1&#34;):
    &#34;&#34;&#34; Function to get a list of measurements from a previous acquisition  
        
        args:
            \n\t- channel (string) : the channel on which the measurement has to be done
            \n\t- meas_list (list of string) : the list of measurements that have to be done. Possible measurements are &#34;FREQUENCY&#34;, &#34;AMPLITUDE&#34;, &#34;MIN&#34;, &#34;MAX&#34;, &#34;MEAN&#34;, &#34;RMS&#34;, &#34;PHASE&#34;, &#34;PK2Pk&#34;
            \n\t- ref_channel (string) : the reference channel if phase measurement is asked

        return:
           \n\t- meas_dic (dictionnary) : dictionnary with the value of the measurements. The keys of the dictionnary are meas_list

    &#34;&#34;&#34;        
    meas_dic={}
    for meas_type in meas_list:
        time.sleep(self.SMALL_SLEEP)
        meas_dic[meas_type]=self.get_measurement(channel,meas_type,ref_channel)

        
    return meas_dic</code></pre>
</details>
<div class="desc"><p>Function to get a list of measurements from a previous acquisition
</p>
<pre><code>args:
</code></pre>
<ul>
<li>
<p>channel (string) : the channel on which the measurement has to be done</p>
</li>
<li>
<p>meas_list (list of string) : the list of measurements that have to be done. Possible measurements are "FREQUENCY", "AMPLITUDE", "MIN", "MAX", "MEAN", "RMS", "PHASE", "PK2Pk"</p>
</li>
<li>
<p>ref_channel (string) : the reference channel if phase measurement is asked</p>
<p>return:</p>
</li>
<li>
<p>meas_dic (dictionnary) : dictionnary with the value of the measurements. The keys of the dictionnary are meas_list</p>
</li>
</ul></div>
</dd>
<dt id="dopes.equipment_control.oscilloscope.oscilloscope.get_sample_rate"><code class="name flex">
<span>def <span class="ident">get_sample_rate</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sample_rate(self):
    &#34;&#34;&#34; Function to get the effective sample rate 
        
        return:
            \n\t- sample_rate (float) : the effective sample rate
    
    &#34;&#34;&#34;
    
    time.sleep(self.SMALL_SLEEP)
    sample_rate=float(self.pyvisa_resource.query(&#39;HORizontal:SAMPLERate?&#39;))
    return sample_rate</code></pre>
</details>
<div class="desc"><p>Function to get the effective sample rate </p>
<pre><code>return:
</code></pre>
<ul>
<li>sample_rate (float) : the effective sample rate</li>
</ul></div>
</dd>
<dt id="dopes.equipment_control.oscilloscope.oscilloscope.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>self,<br>channel_used={'CH1': 'ON', 'CH2': 'OFF', 'CH3': 'OFF', 'CH4': 'OFF'},<br>autoset=True,<br>continuous=True,<br>num_sequence=1,<br>high_resolution=False,<br>average=False,<br>num_average=10,<br>data_bytes=1,<br>command_delay=0.02,<br>query_delay=0.1,<br>sync_delay=0.2)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize(self, channel_used={&#34;CH1&#34;:&#34;ON&#34;,&#34;CH2&#34;:&#34;OFF&#34;,&#34;CH3&#34;:&#34;OFF&#34;,&#34;CH4&#34;:&#34;OFF&#34;},
               autoset=True,continuous=True, num_sequence=1,high_resolution=False, average=False,num_average=10,data_bytes=1, command_delay=0.02, query_delay=0.1, sync_delay=0.2):
    &#34;&#34;&#34; Function to initialize the Tektronix oscilloscope  with the desired settings
    
        args:
           \n\t- channel_used (dictionnary) : dictionnary for which the key are the name of the channel (&#34;CH1&#34;,&#34;CH2&#34;,&#34;CH3&#34;,&#34;CH4&#34;) and the value is &#34;ON&#34; or &#34;OFF&#34; to activate or desactivate the channel
           \n\t- autoset (boolean) : if True, the oscilloscope performs an autoset during the initialization
           \n\t- continuous (boolean) : if True, the oscilloscope continue running after taken an acquisition
           \n\t- num_sequence (integer) : the number of sequence the oscilloscope will take for each acquisition. This is not an averaging.
           \n\t- high_resolution (boolean) : if True, the oscilloscope will enter high resolution mode, i.e. averaging over a fixed period in fast frame acquisition. High resolution is automatically turn on when 2 bytes are asked with TBS oscilloscope
           \n\t- average (boolean) : if True, the oscilloscope will take several signal to perform an averaging
           \n\t- num_average (integer) : the number of acquisitions to make the averaging
           \n\t- data_bytes (integer) : the number of bytes for the vertical resolution of the data (1 or 2 accepted)
    &#34;&#34;&#34;
    self.SMALL_SLEEP=command_delay
    self.MID_SLEEP=query_delay
    self.BIG_SLEEP=sync_delay
    
    self.channel_used=channel_used
    self.average=average
    self.num_average=num_average
    self.data_bytes=data_bytes
    
    
    self.pyvisa_resource.encoding = &#39;ascii&#39;
    self.pyvisa_resource.read_termination = &#39;\n&#39;
    self.pyvisa_resource.write_termination = None
    self.pyvisa_resource.send_termination = False
    
    identity=self.pyvisa_resource.query(&#34;*IDN?&#34;)
    self.model_tbs= (identity.upper().find(&#34;TBS&#34;)&gt;=0)
    
    if self.model_tbs and data_bytes==2 and high_resolution==False:
        high_resolution=True
        print(&#34;TBS oscilloscope can only work under 2 bytes with high resolution mode.\nThe equipment has been swith to high resolution mode.&#34;)

    self.pyvisa_resource.write(&#39;*CLS&#39;) # clear ESR
    self.pyvisa_resource.write(&#39;*RST&#39;) # clear ESR

    for key in channel_used.keys():        
        self.pyvisa_resource.write(&#39;SELECT:%s %s&#39;%(key,channel_used[key]))
            

    if autoset:
        self.pyvisa_resource.write(&#39;autoset EXECUTE&#39;) # autoset
        time.sleep(5)
    else:
        self.pyvisa_resource.write(&#39;HORIZONTAL:MODE AUTO&#39;)
        time.sleep(1)

    self.pyvisa_resource.write(&#39;ACQUIRE:STATE OFF&#39;)

    self.pyvisa_resource.query(&#39;*opc?&#39;,delay=1) # sync

    self.pyvisa_resource.write(&#34;HEADER 0&#34;)
    self.pyvisa_resource.write(&#34;DATA:ENCDG RIBINARY&#34;)   # Signed Binary Format, LSB order
    self.pyvisa_resource.write(&#34;DATA:WIDTH %d&#34;%data_bytes) # 1 byte per sample
    self.pyvisa_resource.write(&#34;DATA:START 1&#34;)
    record = int(self.pyvisa_resource.query(&#39;horizontal:recordlength?&#39;,delay=self.MID_SLEEP))
    self.pyvisa_resource.write(&#39;data:stop {}&#39;.format(record)) # last sample
    

    if average:
        self.pyvisa_resource.write(&#39;ACQUIRE:MODE AVERAGE&#39;)
        self.pyvisa_resource.write(&#39;ACQUIRE:NUMAVG %d&#39;%num_average)
    elif high_resolution:
        self.pyvisa_resource.write(&#39;ACQUIRE:MODE HIRES&#39;)
    else:
        self.pyvisa_resource.write(&#39;ACQUIRE:MODE SAMPLE&#39;)
    
    if continuous:
        self.pyvisa_resource.write(&#39;ACQUIRE:STOPAFTER RUNSTOP&#39;)
        self.pyvisa_resource.write(&#39;ACQUIRE:STATE RUN&#39;)
    else:
        self.pyvisa_resource.write(&#39;ACQUIRE:STOPAFTER SEQUENCE&#39;)
        self.pyvisa_resource.write(&#39;ACQUIRE:SEQUENCE:NUMSEQUENCE %d&#39;%num_sequence)    </code></pre>
</details>
<div class="desc"><p>Function to initialize the Tektronix oscilloscope
with the desired settings</p>
<pre><code>args:
</code></pre>
<ul>
<li>
<p>channel_used (dictionnary) : dictionnary for which the key are the name of the channel ("CH1","CH2","CH3","CH4") and the value is "ON" or "OFF" to activate or desactivate the channel</p>
</li>
<li>
<p>autoset (boolean) : if True, the oscilloscope performs an autoset during the initialization</p>
</li>
<li>
<p>continuous (boolean) : if True, the oscilloscope continue running after taken an acquisition</p>
</li>
<li>
<p>num_sequence (integer) : the number of sequence the oscilloscope will take for each acquisition. This is not an averaging.</p>
</li>
<li>
<p>high_resolution (boolean) : if True, the oscilloscope will enter high resolution mode, i.e. averaging over a fixed period in fast frame acquisition. High resolution is automatically turn on when 2 bytes are asked with TBS oscilloscope</p>
</li>
<li>
<p>average (boolean) : if True, the oscilloscope will take several signal to perform an averaging</p>
</li>
<li>
<p>num_average (integer) : the number of acquisitions to make the averaging</p>
</li>
<li>
<p>data_bytes (integer) : the number of bytes for the vertical resolution of the data (1 or 2 accepted)</p>
</li>
</ul></div>
</dd>
<dt id="dopes.equipment_control.oscilloscope.oscilloscope.set_channel_properties"><code class="name flex">
<span>def <span class="ident">set_channel_properties</span></span>(<span>self, channel, scale, offset=0, coupling='DC', bandwidth='FULL', termination=1000000.0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_channel_properties(self, channel, scale, offset=0, coupling=&#34;DC&#34;, bandwidth=&#34;FULL&#34;, termination=1e6):
    &#34;&#34;&#34; Function to set the properties of a channel of the oscilloscope 
        
        args:
            \n\t- channel (string) : the channel from which the data has to be taken
            \n\t- scale (scalar) : the dimension of one vertical divistion in Volts. The full scale is made of 10 divisions
            \n\t- offset (scalar) : the offset in volt of the vertical position of the signal
            \n\t- coupling (string) : the coupling of the channel. Choice between &#34;AC&#34; to remove the DC component or &#34;DC&#34; to keep it
            \n\t- bandwidth (scalar or string) : the selectable low-pass bandwidth limit filter of the specified channel. &#34;FULL&#34; disables any optional bandwidth limiting. The specified channel operates at its maximum bandwidth.
            \n\t- termination (scalar) : The vertical termination for the specified analog channel. Choice between 50 or 1e6 Ohms. 

    &#34;&#34;&#34;
    
    while float(self.pyvisa_resource.query(&#39;BUSY?&#39;,delay=self.BIG_SLEEP)):
        time.sleep(self.SMALL_SLEEP)
    time.sleep(self.SMALL_SLEEP)

    self.pyvisa_resource.write(&#39;%s:SCALE %e&#39;%(channel,scale))
    time.sleep(self.SMALL_SLEEP)
    self.pyvisa_resource.write(&#39;%s:TERmination %e&#39;%(channel,termination))
    time.sleep(self.SMALL_SLEEP)
    self.pyvisa_resource.write(&#39;%s:OFFSet %e&#39;%(channel,offset))
    time.sleep(self.SMALL_SLEEP)
    self.pyvisa_resource.write(&#39;%s:COUPLING %s&#39;%(channel,coupling))
    time.sleep(self.SMALL_SLEEP)
    if bandwidth.upper()==&#34;FULL&#34;:
        self.pyvisa_resource.write(&#39;%s:BANdwidth %s&#39;%(channel,bandwidth))
    else:
        self.pyvisa_resource.write(&#39;%s:BANdwidth %e&#39;%(channel,bandwidth))</code></pre>
</details>
<div class="desc"><p>Function to set the properties of a channel of the oscilloscope </p>
<pre><code>args:
</code></pre>
<ul>
<li>
<p>channel (string) : the channel from which the data has to be taken</p>
</li>
<li>
<p>scale (scalar) : the dimension of one vertical divistion in Volts. The full scale is made of 10 divisions</p>
</li>
<li>
<p>offset (scalar) : the offset in volt of the vertical position of the signal</p>
</li>
<li>
<p>coupling (string) : the coupling of the channel. Choice between "AC" to remove the DC component or "DC" to keep it</p>
</li>
<li>
<p>bandwidth (scalar or string) : the selectable low-pass bandwidth limit filter of the specified channel. "FULL" disables any optional bandwidth limiting. The specified channel operates at its maximum bandwidth.</p>
</li>
<li>
<p>termination (scalar) : The vertical termination for the specified analog channel. Choice between 50 or 1e6 Ohms.</p>
</li>
</ul></div>
</dd>
<dt id="dopes.equipment_control.oscilloscope.oscilloscope.set_edge_trigger"><code class="name flex">
<span>def <span class="ident">set_edge_trigger</span></span>(<span>self, channel='CH1', level=0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_edge_trigger(self,channel=&#34;CH1&#34;, level=0):
    &#34;&#34;&#34; Function to set a rising edge trigger 
        
        args:
            \n\t- channel (string) : specify the channel for the triggering mechanism
            \n\t- level (scalar) : the voltage level of trigger

    &#34;&#34;&#34;
    
    time.sleep(self.SMALL_SLEEP)
    self.pyvisa_resource.write(&#39;TRIGger:A:TYPe EDGE&#39;)
    time.sleep(self.SMALL_SLEEP)
    self.pyvisa_resource.write(&#39;TRIGger:A:EDGE:SOUrce %s&#39;%channel)
    time.sleep(self.SMALL_SLEEP)
    self.pyvisa_resource.write(&#39;TRIGger:A:LEVel:%s %f&#39;%(channel,level))
    time.sleep(self.SMALL_SLEEP)
    self.pyvisa_resource.write(&#34;TRIG:A:EDGE:SLOPE RIS&#34;)</code></pre>
</details>
<div class="desc"><p>Function to set a rising edge trigger </p>
<pre><code>args:
</code></pre>
<ul>
<li>
<p>channel (string) : specify the channel for the triggering mechanism</p>
</li>
<li>
<p>level (scalar) : the voltage level of trigger</p>
</li>
</ul></div>
</dd>
<dt id="dopes.equipment_control.oscilloscope.oscilloscope.set_horizontal_properties"><code class="name flex">
<span>def <span class="ident">set_horizontal_properties</span></span>(<span>self, record_length, sample_rate)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_horizontal_properties(self,record_length,sample_rate):
    &#34;&#34;&#34; Function to set the horizontal (time axis) properties of the oscilloscope 
        
        args:
            \n\t- record_length (integer) : specify the number of points for the acquisition. For TBS2000, the suppored values are: 1000, 2000, 20000, 200000, 2000000, and 5000000. For MSO2024, the suppored values are 100000, and 1000000.
            \n\t- sample_rate (scalar) : specify the sampling rate in samples/s for the acquisition. The total time window can then be calculated as record_length/sampling_rate

    &#34;&#34;&#34;

    while float(self.pyvisa_resource.query(&#39;BUSY?&#39;,delay=self.BIG_SLEEP)):
        time.sleep(self.SMALL_SLEEP)

    # record_length max = 125e6
    # sample_rate max = 500e9 sample/seconds
    time.sleep(self.SMALL_SLEEP)

    self.pyvisa_resource.write(&#39;HORIZONTAL:MODE MANUAL&#39;)
    time.sleep(self.SMALL_SLEEP)
    self.pyvisa_resource.write(&#39;HORizontal:MODe:MANual:CONFIGure RECORDLength&#39;)
    time.sleep(self.SMALL_SLEEP)
    self.pyvisa_resource.write(&#39;HORIZONTAL:RECORDLENGTH %e&#39;%record_length)
    time.sleep(self.SMALL_SLEEP)
    true_record_length = int(self.pyvisa_resource.query(&#39;horizontal:recordlength?&#39;,delay=self.MID_SLEEP))
    if self.model_tbs:
        n_divisions=int(float(self.pyvisa_resource.query(&#39;HORizontal:DIVisions?&#39;)))
        self.pyvisa_resource.write(&#39;HORIZONTAL:SCALE %.3e&#39;%(true_record_length/sample_rate/n_divisions))            
    else:            
        self.pyvisa_resource.write(&#39;HORIZONTAL:SAMPLERATE %e&#39;%sample_rate)
    
    time.sleep(self.SMALL_SLEEP)
    self.pyvisa_resource.write(&#39;data:stop %e&#39;%true_record_length) # last sample</code></pre>
</details>
<div class="desc"><p>Function to set the horizontal (time axis) properties of the oscilloscope </p>
<pre><code>args:
</code></pre>
<ul>
<li>
<p>record_length (integer) : specify the number of points for the acquisition. For TBS2000, the suppored values are: 1000, 2000, 20000, 200000, 2000000, and 5000000. For MSO2024, the suppored values are 100000, and 1000000.</p>
</li>
<li>
<p>sample_rate (scalar) : specify the sampling rate in samples/s for the acquisition. The total time window can then be calculated as record_length/sampling_rate</p>
</li>
</ul></div>
</dd>
<dt id="dopes.equipment_control.oscilloscope.oscilloscope.set_state"><code class="name flex">
<span>def <span class="ident">set_state</span></span>(<span>self, state='ON')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_state(self, state=&#34;ON&#34;):
    &#34;&#34;&#34; Function to set the acquisition state 
        
        args:
            \n\t- state (string) : When state is set to &#34;ON&#34; or &#34;RUN&#34;, a new acquisition will be started. When state is set to &#34;OFF&#34; or &#34;STOP&#34;, the acquisition is stopped.
            If the last acquisition was a single acquisition sequence, a new single sequence acquisition will be started. If the last acquisition was continuous, a new continuous acquisition will be started.
            If &#34;RUN&#34; is issued in the middle of completing a single sequence acquisition (for example, averaging or enveloping), the acquisition sequence is restarted, 
            and any accumulated data is discarded. Also, the instrument resets the number of acquisitions. If the &#34;RUN&#34; argument is issued while in continuous mode, a reset occurs and acquired data continues to acquire.
    &#34;&#34;&#34;
    time.sleep(self.SMALL_SLEEP)
    self.pyvisa_resource.write(&#39;ACQUIRE:STATE %s&#39;%state)</code></pre>
</details>
<div class="desc"><p>Function to set the acquisition state </p>
<pre><code>args:
</code></pre>
<ul>
<li>state (string) : When state is set to "ON" or "RUN", a new acquisition will be started. When state is set to "OFF" or "STOP", the acquisition is stopped.
If the last acquisition was a single acquisition sequence, a new single sequence acquisition will be started. If the last acquisition was continuous, a new continuous acquisition will be started.
If "RUN" is issued in the middle of completing a single sequence acquisition (for example, averaging or enveloping), the acquisition sequence is restarted,
and any accumulated data is discarded. Also, the instrument resets the number of acquisitions. If the "RUN" argument is issued while in continuous mode, a reset occurs and acquired data continues to acquire.</li>
</ul></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dopes.equipment_control.equipment.equipment" href="equipment.html#dopes.equipment_control.equipment.equipment">equipment</a></b></code>:
<ul class="hlist">
<li><code><a title="dopes.equipment_control.equipment.equipment.close_connection" href="equipment.html#dopes.equipment_control.equipment.equipment.close_connection">close_connection</a></code></li>
<li><code><a title="dopes.equipment_control.equipment.equipment.set_connection_parameter" href="equipment.html#dopes.equipment_control.equipment.equipment.set_connection_parameter">set_connection_parameter</a></code></li>
<li><code><a title="dopes.equipment_control.equipment.equipment.set_connection_parameter_dic" href="equipment.html#dopes.equipment_control.equipment.equipment.set_connection_parameter_dic">set_connection_parameter_dic</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dopes.equipment_control" href="index.html">dopes.equipment_control</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dopes.equipment_control.oscilloscope.oscilloscope" href="#dopes.equipment_control.oscilloscope.oscilloscope">oscilloscope</a></code></h4>
<ul class="">
<li><code><a title="dopes.equipment_control.oscilloscope.oscilloscope.acquire_all_channels" href="#dopes.equipment_control.oscilloscope.oscilloscope.acquire_all_channels">acquire_all_channels</a></code></li>
<li><code><a title="dopes.equipment_control.oscilloscope.oscilloscope.acquire_channels_with_measurement" href="#dopes.equipment_control.oscilloscope.oscilloscope.acquire_channels_with_measurement">acquire_channels_with_measurement</a></code></li>
<li><code><a title="dopes.equipment_control.oscilloscope.oscilloscope.acquire_single_channel" href="#dopes.equipment_control.oscilloscope.oscilloscope.acquire_single_channel">acquire_single_channel</a></code></li>
<li><code><a title="dopes.equipment_control.oscilloscope.oscilloscope.acquire_single_channel_with_measurement" href="#dopes.equipment_control.oscilloscope.oscilloscope.acquire_single_channel_with_measurement">acquire_single_channel_with_measurement</a></code></li>
<li><code><a title="dopes.equipment_control.oscilloscope.oscilloscope.acquire_wave" href="#dopes.equipment_control.oscilloscope.oscilloscope.acquire_wave">acquire_wave</a></code></li>
<li><code><a title="dopes.equipment_control.oscilloscope.oscilloscope.company" href="#dopes.equipment_control.oscilloscope.oscilloscope.company">company</a></code></li>
<li><code><a title="dopes.equipment_control.oscilloscope.oscilloscope.force_trig" href="#dopes.equipment_control.oscilloscope.oscilloscope.force_trig">force_trig</a></code></li>
<li><code><a title="dopes.equipment_control.oscilloscope.oscilloscope.get_measurement" href="#dopes.equipment_control.oscilloscope.oscilloscope.get_measurement">get_measurement</a></code></li>
<li><code><a title="dopes.equipment_control.oscilloscope.oscilloscope.get_measurement_list" href="#dopes.equipment_control.oscilloscope.oscilloscope.get_measurement_list">get_measurement_list</a></code></li>
<li><code><a title="dopes.equipment_control.oscilloscope.oscilloscope.get_sample_rate" href="#dopes.equipment_control.oscilloscope.oscilloscope.get_sample_rate">get_sample_rate</a></code></li>
<li><code><a title="dopes.equipment_control.oscilloscope.oscilloscope.initialize" href="#dopes.equipment_control.oscilloscope.oscilloscope.initialize">initialize</a></code></li>
<li><code><a title="dopes.equipment_control.oscilloscope.oscilloscope.model" href="#dopes.equipment_control.oscilloscope.oscilloscope.model">model</a></code></li>
<li><code><a title="dopes.equipment_control.oscilloscope.oscilloscope.set_channel_properties" href="#dopes.equipment_control.oscilloscope.oscilloscope.set_channel_properties">set_channel_properties</a></code></li>
<li><code><a title="dopes.equipment_control.oscilloscope.oscilloscope.set_edge_trigger" href="#dopes.equipment_control.oscilloscope.oscilloscope.set_edge_trigger">set_edge_trigger</a></code></li>
<li><code><a title="dopes.equipment_control.oscilloscope.oscilloscope.set_horizontal_properties" href="#dopes.equipment_control.oscilloscope.oscilloscope.set_horizontal_properties">set_horizontal_properties</a></code></li>
<li><code><a title="dopes.equipment_control.oscilloscope.oscilloscope.set_state" href="#dopes.equipment_control.oscilloscope.oscilloscope.set_state">set_state</a></code></li>
<li><code><a title="dopes.equipment_control.oscilloscope.oscilloscope.url" href="#dopes.equipment_control.oscilloscope.oscilloscope.url">url</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
