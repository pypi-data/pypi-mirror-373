<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>dopes.data_analysis.polytec API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dopes.data_analysis.polytec</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dopes.data_analysis.polytec.find_max"><code class="name flex">
<span>def <span class="ident">find_max</span></span>(<span>x, y, z, kind='maximum', height=None, width=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_max(x,y,z,kind=&#34;maximum&#34;,height=None,width=None):
    &#34;&#34;&#34; Function to find maximal values
    
        args:
           \n\t- x, y (array) : 1D array for the x and y position of the pixel 
           \n\t- z (array) : 1D array with the values at position (x,y) and with the same dimension as x and y
           \n\t- kind (string) : the method to determine the maximum. &#34;maximum&#34; only takes the max value of the z array while &#34;peaks&#34; is looking for the maximal peak. This last method is more robust with regards to outlier. The minimum height and width can be specified.
           \n\t- height (None, scalar or 2-element sequence) : required height of peaks. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required height.
           \n\t- width (None, scalar or 2-element sequence) : required width of peaks in samples. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required width.
        
        return:
           \n\t- x_max,y_max,z_max : three elements with the x, y position of the maximum value of the z array
    &#34;&#34;&#34;
    if kind==&#34;maximum&#34;:
        index=np.nanargmax(z)
        x_max=x[index]
        y_max=y[index]
        z_max=z[index]
        
    elif kind == &#34;peaks&#34;:
        n_interp=int(np.sqrt(len(z)))
        X,Y,Z=medfilt_2D(x,y,z,n_interp)


        if height is None:
            height = np.nanmax(Z[:,int(n_interp/2)])*0.1
        if width is None:
            width = n_interp/np.nanmax(x)*0.1
        
        param_peaks=find_peaks(Z[:,int(n_interp/2)],height=height,width=width)
        peak_x=param_peaks[0][np.nanargmax(param_peaks[1][&#34;peak_heights&#34;])]

        param_peaks=find_peaks(Z[peak_x],height=height,width=width)
        peak_y=param_peaks[0][np.nanargmax(param_peaks[1][&#34;peak_heights&#34;])]
        peak_height=np.nanmax(param_peaks[1][&#34;peak_heights&#34;])
        
        x_max=X[peak_x,peak_y]
        y_max=Y[peak_x,peak_y]
        z_max=peak_height     

    
    return x_max,y_max,z_max</code></pre>
</details>
<div class="desc"><p>Function to find maximal values</p>
<p>args:</p>
<ul>
<li>
<p>x, y (array) : 1D array for the x and y position of the pixel </p>
</li>
<li>
<p>z (array) : 1D array with the values at position (x,y) and with the same dimension as x and y</p>
</li>
<li>
<p>kind (string) : the method to determine the maximum. "maximum" only takes the max value of the z array while "peaks" is looking for the maximal peak. This last method is more robust with regards to outlier. The minimum height and width can be specified.</p>
</li>
<li>
<p>height (None, scalar or 2-element sequence) : required height of peaks. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required height.</p>
</li>
<li>
<p>width (None, scalar or 2-element sequence) : required width of peaks in samples. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required width.</p>
</li>
</ul>
<p>return:</p>
<ul>
<li>x_max,y_max,z_max : three elements with the x, y position of the maximum value of the z array</li>
</ul></div>
</dd>
<dt id="dopes.data_analysis.polytec.medfilt_2D"><code class="name flex">
<span>def <span class="ident">medfilt_2D</span></span>(<span>x, y, z, kernel_size=9, n_interp=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def medfilt_2D(x,y,z,kernel_size=9,n_interp=None):
    &#34;&#34;&#34; Function to convert unstructured 1D data (three vectors) in 2D grid for which the z values have been filtered with a 2D median filter to remove the outliers
    
        args:
           \n\t- x, y (array) : 1D array for the x and y position of the pixel 
           \n\t- z (array) : 1D array with with the values at position (x,y), and with the same dimension as x and y
           \n\t- kernel_size (int) : size of the median filter window.    
           \n\t- n_interp (int) : the number of points for the dimensions of the interpolation along x and y. if None, n_interp is set as the square root of the dimension of the z array
                
        return:
           \n\t- X,Y,Z : three meshgrids of the same dimension (n_interp x n_interp) with the x,y coordinates and the z values filtered. The X and Y grid are linearly spaced from the minimal and maximal valeus of x and y, respectively.
            
    &#34;&#34;&#34;

    X, Y, Z_interp = unstructured_to_regular(x,y,z,n_interp)
    Z_med = medfilt2d(Z_interp,kernel_size)
    
    return X,Y,Z_med</code></pre>
</details>
<div class="desc"><p>Function to convert unstructured 1D data (three vectors) in 2D grid for which the z values have been filtered with a 2D median filter to remove the outliers</p>
<p>args:</p>
<ul>
<li>
<p>x, y (array) : 1D array for the x and y position of the pixel </p>
</li>
<li>
<p>z (array) : 1D array with with the values at position (x,y), and with the same dimension as x and y</p>
</li>
<li>
<p>kernel_size (int) : size of the median filter window.
</p>
</li>
<li>
<p>n_interp (int) : the number of points for the dimensions of the interpolation along x and y. if None, n_interp is set as the square root of the dimension of the z array</p>
</li>
</ul>
<p>return:</p>
<ul>
<li>X,Y,Z : three meshgrids of the same dimension (n_interp x n_interp) with the x,y coordinates and the z values filtered. The X and Y grid are linearly spaced from the minimal and maximal valeus of x and y, respectively.</li>
</ul></div>
</dd>
<dt id="dopes.data_analysis.polytec.plot_1D_line_from_file"><code class="name flex">
<span>def <span class="ident">plot_1D_line_from_file</span></span>(<span>file_path,<br>unit_mult=(1, 1),<br>use_lines=None,<br>ax=None,<br>color_list=None,<br>ls_list=None,<br>marker_list=None,<br>**plot_kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_1D_line_from_file(file_path,unit_mult=(1,1),use_lines=None,ax=None,color_list=None,ls_list=None,marker_list=None,**plot_kwargs):
    &#34;&#34;&#34; Function to plot a line data from a file
    
        args:
           \n\t- file_path (string) : the file to read
           \n\t- unit_mult (array) : array of three scalar to multiply the data of the x, y and z vector.
           \n\t- use_lines (array) : list of lines to be plotted. Be careful that the number of column in the file is usually twice the number of lines (as each line has an x and z vector).
           \n\t- ax (list of two Axes) : the axes of the subplot in which plotting the map and the color bar next to it
           \n\t- color_list, ls_list, marker_list (array) : list of color, linestyle and marker to be used for the data lines found in the files. If the length of the list is smaller than the number of data lines, the last component is kept for the last data lines. 
           \n\t- plot_kwargs : this method also takes any keyword argument for the Axes.plot() function
           
        return:
            \n\t- fig, ax, data : the figure with its axe and the data array read from the file. If ax is provided, only data is returned
    &#34;&#34;&#34;    
    if use_lines is not None:
        index=np.transpose(np.array([use_lines])) @ (2 * np.ones((1,2*len(use_lines))))+ np.array([[0,1]*len(use_lines)])
        use_col=[int(i) for i in index[0]]
    else:
        use_col=None
        
    data=np.genfromtxt(file_path,skip_header=2,delimiter=&#34;\t&#34;,usecols=use_col)
    n_lines=int(len(data[0])/2)
    
    if ax is None:
        fig,ax=plt.subplots(dpi=200)
        
        ax.set_xlabel(&#34;d (mm)&#34;)
        ax.set_ylabel(&#34;z (mm)&#34;)
    if use_lines is None:
        lines_to_plot=range(n_lines)
    else:
        lines_to_plot=range(len(use_lines))


    for i in lines_to_plot:
        d_lines=data[:,2*i]*unit_mult[0]
        z_lines=proc.moving_median(data[:,2*i+1],9)*unit_mult[1]
        if color_list is not None:
            plot_kwargs[&#34;color&#34;]=color_list[np.min((i,len(color_list)-1))]
        if ls_list is not None:
            plot_kwargs[&#34;ls&#34;]=ls_list[np.min((i,len(ls_list)-1))]     
            plot_kwargs.pop(&#34;linestyle&#34;,None)    
            
        if marker_list is not None:
            plot_kwargs[&#34;marker&#34;]=marker_list[np.min((i,len(marker_list)-1))] 

        
        ax.plot(d_lines,z_lines,**plot_kwargs)

    if ax is None:        
        return fig,ax, data
    else:
        return data</code></pre>
</details>
<div class="desc"><p>Function to plot a line data from a file</p>
<p>args:</p>
<ul>
<li>
<p>file_path (string) : the file to read</p>
</li>
<li>
<p>unit_mult (array) : array of three scalar to multiply the data of the x, y and z vector.</p>
</li>
<li>
<p>use_lines (array) : list of lines to be plotted. Be careful that the number of column in the file is usually twice the number of lines (as each line has an x and z vector).</p>
</li>
<li>
<p>ax (list of two Axes) : the axes of the subplot in which plotting the map and the color bar next to it</p>
</li>
<li>
<p>color_list, ls_list, marker_list (array) : list of color, linestyle and marker to be used for the data lines found in the files. If the length of the list is smaller than the number of data lines, the last component is kept for the last data lines. </p>
</li>
<li>
<p>plot_kwargs : this method also takes any keyword argument for the Axes.plot() function</p>
</li>
</ul>
<p>return:</p>
<ul>
<li>fig, ax, data : the figure with its axe and the data array read from the file. If ax is provided, only data is returned</li>
</ul></div>
</dd>
<dt id="dopes.data_analysis.polytec.plot_map"><code class="name flex">
<span>def <span class="ident">plot_map</span></span>(<span>x,<br>y,<br>z,<br>ax=None,<br>vmin=None,<br>vmax=None,<br>cmap='coolwarm',<br>medfilt=True,<br>kernel_size=9,<br>n_interp=None,<br>**contour_kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_map(x,y,z,ax=None,vmin=None,vmax=None,cmap=&#34;coolwarm&#34;,medfilt=True,kernel_size=9,n_interp=None, **contour_kwargs):
    &#34;&#34;&#34; Function to plot a 2D map from unstructured 1D data (three vectors)
    
        args:
           \n\t- x, y (array) : 1D array for the x and y position of the pixel 
           \n\t- z (array) : 1D array with with the values at position (x,y), and with the same dimension as x and y
           \n\t- ax (list of two Axes) : the axes of the subplot in which plotting the map and the color bar next to it
           \n\t- vmin, vmax (scalar) : define the data range that the colormap covers. By default, the colormap covers the complete value range of the supplied data. If vmin or vmax are not given, the default color scaling is based on levels.
           \n\t- cmap (str or Colormap) : the Colormap instance or registered colormap name used to map scalar data to colors.
           \n\t- medfilt (boolean) : if True apply a median filter on the data by interpolating it on a n_interp x n_interp grid
           \n\t- kernel_size (int) : size of the median filter window.    
           \n\t- n_interp (int) : the number of points for the dimensions of the interpolation along x and y. if None, n_interp is set as the square root of the dimension of the z array
           \n\t- contour_kwargs : this method also takes any keyword argument for the Axes.contourf() and axes.tricontourf()
           
        return:
            \n\t- fig, ax_map, ax_bar : the figure with the 2D map axe (ax_map) and the axe with the color bar (ax_bar)
            
    &#34;&#34;&#34;
    if vmin==None:
        vmin=0

    if ax==None:
        fig,ax=plt.subplots(1,2,gridspec_kw={&#34;wspace&#34;:0.1,&#34;width_ratios&#34;:[5,0.2]})
    ax[0].set_xlabel(&#34;x (mm)&#34;)
    ax[0].set_ylabel(&#34;y (mm)&#34;)
  
    if medfilt:
        X,Y,Z=medfilt_2D(x,y,z,kernel_size,n_interp)
        if vmax==None:
            vmax=np.ceil(np.nanmax(Z)*1e3)/1e3
        ax[0].contourf(X, Y, Z, vmin=vmin, vmax=vmax,cmap=cmap,**contour_kwargs)

    else:
        if vmax==None:
            vmax=np.ceil(np.nanmax(z)*1e3)/1e3

        ax[0].tricontourf(x, y, z, vmin=vmin, vmax=vmax,cmap=cmap, **contour_kwargs)
        
    fig.colorbar(mpl.cm.ScalarMappable(norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax), cmap=cmap), 
                     orientation=&#39;vertical&#39;, label=&#34;Deflection (µm)&#34;,cax=ax[1])

    ax_map=ax[0]
    ax_bar=ax[1]
    
    return fig, ax_map, ax_bar</code></pre>
</details>
<div class="desc"><p>Function to plot a 2D map from unstructured 1D data (three vectors)</p>
<p>args:</p>
<ul>
<li>
<p>x, y (array) : 1D array for the x and y position of the pixel </p>
</li>
<li>
<p>z (array) : 1D array with with the values at position (x,y), and with the same dimension as x and y</p>
</li>
<li>
<p>ax (list of two Axes) : the axes of the subplot in which plotting the map and the color bar next to it</p>
</li>
<li>
<p>vmin, vmax (scalar) : define the data range that the colormap covers. By default, the colormap covers the complete value range of the supplied data. If vmin or vmax are not given, the default color scaling is based on levels.</p>
</li>
<li>
<p>cmap (str or Colormap) : the Colormap instance or registered colormap name used to map scalar data to colors.</p>
</li>
<li>
<p>medfilt (boolean) : if True apply a median filter on the data by interpolating it on a n_interp x n_interp grid</p>
</li>
<li>
<p>kernel_size (int) : size of the median filter window.
</p>
</li>
<li>
<p>n_interp (int) : the number of points for the dimensions of the interpolation along x and y. if None, n_interp is set as the square root of the dimension of the z array</p>
</li>
<li>
<p>contour_kwargs : this method also takes any keyword argument for the Axes.contourf() and axes.tricontourf()</p>
</li>
</ul>
<p>return:</p>
<ul>
<li>fig, ax_map, ax_bar : the figure with the 2D map axe (ax_map) and the axe with the color bar (ax_bar)</li>
</ul></div>
</dd>
<dt id="dopes.data_analysis.polytec.plot_map_from_file"><code class="name flex">
<span>def <span class="ident">plot_map_from_file</span></span>(<span>file_path,<br>n_step=1,<br>unit_mult=(1, 1, 1),<br>ax=None,<br>vmin=None,<br>vmax=None,<br>cmap='coolwarm',<br>medfilt=True,<br>kernel_size=9,<br>n_interp=None,<br>**contour_kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_map_from_file(file_path,n_step=1,unit_mult=(1,1,1),ax=None,vmin=None,vmax=None,cmap=&#34;coolwarm&#34;,medfilt=True,kernel_size=9,n_interp=None, **contour_kwargs):
    &#34;&#34;&#34; Function to plot a 2D map from a file of unstructured 1D data (three vectors x,y and z)
    
        args:
           \n\t- file_path (string) : the file to read
           \n\t- n_step (int) : reduce the number of point to be plotted by taking one point each n_point index of the x, y ,z vectors
           \n\t- unit_mult (array) : array of three scalar to multiply the data of the x, y and z vector.
           \n\t- ax (list of two Axes) : the axes of the subplot in which plotting the map and the color bar next to it
           \n\t- vmin, vmax (scalar) : define the data range that the colormap covers. By default, the colormap covers the complete value range of the supplied data. If vmin or vmax are not given, the default color scaling is based on levels.
           \n\t- cmap (string or Colormap) : the Colormap instance or registered colormap name used to map scalar data to colors.
           \n\t- medfilt (boolean) : if True apply a median filter on the data by interpolating it on a n_interp x n_interp grid
           \n\t- kernel_size (int) : size of the median filter window.    
           \n\t- n_interp (int) : the number of points for the dimensions of the interpolation along x and y. if None, n_interp is set as the square root of the dimension of the z array
           \n\t- contour_kwargs : this method also takes any keyword argument for the Axes.contourf() and axes.tricontourf()
           
        return:
            \n\t- fig, ax_map, ax_bar : the figure with the 2D map axe (ax_map) and the axe with the color bar (ax_bar)
    &#34;&#34;&#34;    
    n_step=10
    data=np.genfromtxt(file_path)
    x=data[::n_step,0] * unit_mult[0]
    y=data[::n_step,1] * unit_mult[1]
    z=data[::n_step,2] * unit_mult[2]


    if vmin==None:
        vmin=0

    if ax==None:
        fig,ax=plt.subplots(1,2,gridspec_kw={&#34;wspace&#34;:0.1,&#34;width_ratios&#34;:[5,0.2]})
        ax[0].set_xlabel(&#34;x (mm)&#34;)
        ax[0].set_ylabel(&#34;y (mm)&#34;)
      
    if medfilt:
        X,Y,Z=medfilt_2D(x,y,z,kernel_size,n_interp)
        if vmax==None:
            vmax=np.ceil(np.nanmax(Z)*1e3)/1e3
        ax[0].contourf(X, Y, Z, vmin=vmin, vmax=vmax,cmap=cmap,**contour_kwargs)

    else:
        if vmax==None:
            vmax=np.ceil(np.nanmax(z)*1e3)/1e3

        ax[0].tricontourf(x, y, z, vmin=vmin, vmax=vmax,cmap=cmap, **contour_kwargs)
        
    fig.colorbar(mpl.cm.ScalarMappable(norm = mpl.colors.Normalize(vmin=vmin, vmax=vmax), cmap=cmap), 
                     orientation=&#39;vertical&#39;, label=&#34;Deflection (µm)&#34;,cax=ax[1])

    ax_map=ax[0]
    ax_bar=ax[1]
    
    return fig, ax_map, ax_bar</code></pre>
</details>
<div class="desc"><p>Function to plot a 2D map from a file of unstructured 1D data (three vectors x,y and z)</p>
<p>args:</p>
<ul>
<li>
<p>file_path (string) : the file to read</p>
</li>
<li>
<p>n_step (int) : reduce the number of point to be plotted by taking one point each n_point index of the x, y ,z vectors</p>
</li>
<li>
<p>unit_mult (array) : array of three scalar to multiply the data of the x, y and z vector.</p>
</li>
<li>
<p>ax (list of two Axes) : the axes of the subplot in which plotting the map and the color bar next to it</p>
</li>
<li>
<p>vmin, vmax (scalar) : define the data range that the colormap covers. By default, the colormap covers the complete value range of the supplied data. If vmin or vmax are not given, the default color scaling is based on levels.</p>
</li>
<li>
<p>cmap (string or Colormap) : the Colormap instance or registered colormap name used to map scalar data to colors.</p>
</li>
<li>
<p>medfilt (boolean) : if True apply a median filter on the data by interpolating it on a n_interp x n_interp grid</p>
</li>
<li>
<p>kernel_size (int) : size of the median filter window.
</p>
</li>
<li>
<p>n_interp (int) : the number of points for the dimensions of the interpolation along x and y. if None, n_interp is set as the square root of the dimension of the z array</p>
</li>
<li>
<p>contour_kwargs : this method also takes any keyword argument for the Axes.contourf() and axes.tricontourf()</p>
</li>
</ul>
<p>return:</p>
<ul>
<li>fig, ax_map, ax_bar : the figure with the 2D map axe (ax_map) and the axe with the color bar (ax_bar)</li>
</ul></div>
</dd>
<dt id="dopes.data_analysis.polytec.unstructured_to_regular"><code class="name flex">
<span>def <span class="ident">unstructured_to_regular</span></span>(<span>x, y, z, n_interp=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unstructured_to_regular(x,y,z,n_interp=None):
    &#34;&#34;&#34; Function to convert unstructured 1D data (three vectors) in 2D grid
    
        args:
           \n\t- x, y (array) : 1D array for the x and y position of the pixel 
           \n\t- z (array) : 1D array with with the values at position (x,y), and with the same dimension as x and y
           \n\t- n_interp (int) : the number of points for the dimensions of the interpolation along x and y. if None, n_interp is set as the square root of the dimension of the z array
                
        return:
           \n\t- X,Y,Z : three meshgrids of the same dimension (n_interp x n_interp) with the x,y coordinates and the z values interpolated. The X and Y grid are linearly spaced from the minimal and maximal valeus of x and y, respectively.
            
    &#34;&#34;&#34;
    if n_interp==None:
        n_interp=int(np.sqrt(len(z)))
        
    x_interp = np.linspace(min(x), max(x),n_interp)
    y_interp = np.linspace(min(y), max(y),n_interp)
    X, Y = np.meshgrid(x_interp, y_interp)  # 2D grid for interpolation
    Z=griddata(list(zip(x, y)), z, (X, Y), method=&#39;linear&#39;)

    return X,Y,Z</code></pre>
</details>
<div class="desc"><p>Function to convert unstructured 1D data (three vectors) in 2D grid</p>
<p>args:</p>
<ul>
<li>
<p>x, y (array) : 1D array for the x and y position of the pixel </p>
</li>
<li>
<p>z (array) : 1D array with with the values at position (x,y), and with the same dimension as x and y</p>
</li>
<li>
<p>n_interp (int) : the number of points for the dimensions of the interpolation along x and y. if None, n_interp is set as the square root of the dimension of the z array</p>
</li>
</ul>
<p>return:</p>
<ul>
<li>X,Y,Z : three meshgrids of the same dimension (n_interp x n_interp) with the x,y coordinates and the z values interpolated. The X and Y grid are linearly spaced from the minimal and maximal valeus of x and y, respectively.</li>
</ul></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dopes.data_analysis" href="index.html">dopes.data_analysis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dopes.data_analysis.polytec.find_max" href="#dopes.data_analysis.polytec.find_max">find_max</a></code></li>
<li><code><a title="dopes.data_analysis.polytec.medfilt_2D" href="#dopes.data_analysis.polytec.medfilt_2D">medfilt_2D</a></code></li>
<li><code><a title="dopes.data_analysis.polytec.plot_1D_line_from_file" href="#dopes.data_analysis.polytec.plot_1D_line_from_file">plot_1D_line_from_file</a></code></li>
<li><code><a title="dopes.data_analysis.polytec.plot_map" href="#dopes.data_analysis.polytec.plot_map">plot_map</a></code></li>
<li><code><a title="dopes.data_analysis.polytec.plot_map_from_file" href="#dopes.data_analysis.polytec.plot_map_from_file">plot_map_from_file</a></code></li>
<li><code><a title="dopes.data_analysis.polytec.unstructured_to_regular" href="#dopes.data_analysis.polytec.unstructured_to_regular">unstructured_to_regular</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
