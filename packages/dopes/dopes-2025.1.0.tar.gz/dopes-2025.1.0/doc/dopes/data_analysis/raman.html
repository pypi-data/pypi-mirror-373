<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>dopes.data_analysis.raman API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dopes.data_analysis.raman</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dopes.data_analysis.raman.find_peaks"><code class="name flex">
<span>def <span class="ident">find_peaks</span></span>(<span>x, y, height=None, threshold=None, distance=None, width=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_peaks(x,y,height=None, threshold=None, distance=None, width=None):
    &#34;&#34;&#34; Function to find peaks in the Raman spectrum. Be careful that the method is not a fit put a peak detection.
    
        args:
           \n\t- x (array) : an array 
           \n\t- y (array) : the signal with peaks with the same dimension as x
           \n\t- height (None, scalar or 2-element sequence) : required height of peaks. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required height.
           \n\t- threshold (None, scalar or 2-element sequence) : required threshold of peaks, the vertical distance to its neighboring samples. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required threshold.
           \n\t- distance (scalar) : Required minimal horizontal distance in samples between neighbouring peaks. The distance should be higher than the step between two adjacents points from x. Smaller peaks are removed first until the condition is fulfilled for all remaining peaks.
           \n\t- width (None, scalar or 2-element sequence) : required width of peaks in samples. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required width.
        
        return:
           \n\t- (positions, heights, widths) : an array of three elements with the positions, the heights and the widths of the peaks
    &#34;&#34;&#34;
    peaks_properties={}
    dx=(np.max(x)-np.max(y))/len(x)
    
    if distance is not None:
        distance_index=int(np.round(distance/dx))
    else:
        distance_index=None
    
    peaks_index,prop=scipy.signal.find_peaks(y,height=height, threshold=threshold, distance=distance_index, width=width)
    if height is not None:
        peaks_properties[&#34;peak_heights&#34;]=prop[&#34;peak_heights&#34;]
    else:
        peaks_properties[&#34;peak_heights&#34;]=y[peaks_index]
        
    if width is not None:
        peaks_properties[&#34;widths&#34;]=prop[&#34;widths&#34;]
    else:
        peaks_properties[&#34;widths&#34;]=scipy.signal.peak_widths(y,peaks_index)[0]
    
    
    return x[peaks_index],peaks_properties[&#34;peak_heights&#34;],peaks_properties[&#34;widths&#34;]</code></pre>
</details>
<div class="desc"><p>Function to find peaks in the Raman spectrum. Be careful that the method is not a fit put a peak detection.</p>
<p>args:</p>
<ul>
<li>
<p>x (array) : an array </p>
</li>
<li>
<p>y (array) : the signal with peaks with the same dimension as x</p>
</li>
<li>
<p>height (None, scalar or 2-element sequence) : required height of peaks. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required height.</p>
</li>
<li>
<p>threshold (None, scalar or 2-element sequence) : required threshold of peaks, the vertical distance to its neighboring samples. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required threshold.</p>
</li>
<li>
<p>distance (scalar) : Required minimal horizontal distance in samples between neighbouring peaks. The distance should be higher than the step between two adjacents points from x. Smaller peaks are removed first until the condition is fulfilled for all remaining peaks.</p>
</li>
<li>
<p>width (None, scalar or 2-element sequence) : required width of peaks in samples. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required width.</p>
</li>
</ul>
<p>return:</p>
<ul>
<li>(positions, heights, widths) : an array of three elements with the positions, the heights and the widths of the peaks</li>
</ul></div>
</dd>
<dt id="dopes.data_analysis.raman.find_peaks_from_file"><code class="name flex">
<span>def <span class="ident">find_peaks_from_file</span></span>(<span>file_path, height=None, threshold=None, distance=None, width=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_peaks_from_file(file_path,height=None, threshold=None, distance=None, width=None):
    &#34;&#34;&#34; Function to find peaks in the Raman spectrum. Be careful that the method is not a fit put a peak detection.
    
        args:
           \n\t- x (array) : an array 
           \n\t- y (array) : the signal with peaks with the same dimension as x
           \n\t- height (None, scalar or 2-element sequence) : required height of peaks. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required height.
           \n\t- threshold (None, scalar or 2-element sequence) : required threshold of peaks, the vertical distance to its neighboring samples. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required threshold.
           \n\t- distance (scalar) : Required minimal horizontal distance in samples between neighbouring peaks. The distance should be higher than the step between two adjacents points from x. Smaller peaks are removed first until the condition is fulfilled for all remaining peaks.
           \n\t- width (None, scalar or 2-element sequence) : required width of peaks in samples. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required width.
        
        return:
           \n\t- (positions, heights, widths) : an array of three elements with the positions, the heights and the widths of the peaks
    &#34;&#34;&#34;
    data=file_handling.read_file(file_path,comments=&#34;#&#34;,delimiter=None)
    x=data[:,0]
    y=data[:,1]

    return find_peaks(x,y,height, threshold, distance, width)</code></pre>
</details>
<div class="desc"><p>Function to find peaks in the Raman spectrum. Be careful that the method is not a fit put a peak detection.</p>
<p>args:</p>
<ul>
<li>
<p>x (array) : an array </p>
</li>
<li>
<p>y (array) : the signal with peaks with the same dimension as x</p>
</li>
<li>
<p>height (None, scalar or 2-element sequence) : required height of peaks. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required height.</p>
</li>
<li>
<p>threshold (None, scalar or 2-element sequence) : required threshold of peaks, the vertical distance to its neighboring samples. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required threshold.</p>
</li>
<li>
<p>distance (scalar) : Required minimal horizontal distance in samples between neighbouring peaks. The distance should be higher than the step between two adjacents points from x. Smaller peaks are removed first until the condition is fulfilled for all remaining peaks.</p>
</li>
<li>
<p>width (None, scalar or 2-element sequence) : required width of peaks in samples. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required width.</p>
</li>
</ul>
<p>return:</p>
<ul>
<li>(positions, heights, widths) : an array of three elements with the positions, the heights and the widths of the peaks</li>
</ul></div>
</dd>
<dt id="dopes.data_analysis.raman.phonon_deformation_silicon"><code class="name flex">
<span>def <span class="ident">phonon_deformation_silicon</span></span>(<span>strain_matrix, p, q, r, sort=False, w0=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phonon_deformation_silicon(strain_matrix,p,q,r,sort=False,w0=None):
    &#34;&#34;&#34; Function to calculate the Raman shift from an arbitrary strain tensor using Phonon Deformation Potential (PDP) theory
    
        args:
           \n\t- strain_matrix (3x3 matrix) : the strain tensor
           \n\t- p (scalar) : the first phonon deformation potential    
           \n\t- q (scalar) : the second phonon deformation potential.    
           \n\t- r (scalar) : the third phonon deformation potential  
           \n\t- sort (boolean) : if true, sort the phonon modes from lowest to highest energy
           \n\t- w0 (scalar) : reference energy at zero strain, 520.7 cm-1 for silicon
           
        return:
           \n\t- an array of three elements with the energy of the three phonon modes (LO, TO1, and TO2).
    &#34;&#34;&#34;
    if w0==None:
        w0=520.7 # in cm-1
        
    p=p*w0**2
    q=q*w0**2
    r=r*w0**2
    exx=strain_matrix[0,0]
    eyy=strain_matrix[1,1]
    ezz=strain_matrix[2,2]
    eyz=strain_matrix[1,2]
    exz=strain_matrix[0,2]
    exy=strain_matrix[0,1]
    ezy=strain_matrix[2,1]
    ezx=strain_matrix[2,0]
    eyx=strain_matrix[1,0]
    P=np.array([[p*exx+q*(eyy+ezz),2*r*exy,2*r*exz],
                [2*r*eyx,p*eyy+q*(ezz+exx),2*r*eyz],
                [2*r*ezx,2*r*ezy,p*ezz+q*(eyy+exx)]])
    det=np.linalg.det(P)
    tr=np.trace(P)
    tr2=np.trace(P.dot(P))
    
    if sort : 
        lamb=np.sort(np.roots([1,-tr,-0.5*(tr2-tr**2),-det]))
        
    else :
        lamb=np.roots([1,-tr,-0.5*(tr2-tr**2),-det])
    return np.sqrt(lamb+w0**2)</code></pre>
</details>
<div class="desc"><p>Function to calculate the Raman shift from an arbitrary strain tensor using Phonon Deformation Potential (PDP) theory</p>
<p>args:</p>
<ul>
<li>
<p>strain_matrix (3x3 matrix) : the strain tensor</p>
</li>
<li>
<p>p (scalar) : the first phonon deformation potential
</p>
</li>
<li>
<p>q (scalar) : the second phonon deformation potential.
</p>
</li>
<li>
<p>r (scalar) : the third phonon deformation potential
</p>
</li>
<li>
<p>sort (boolean) : if true, sort the phonon modes from lowest to highest energy</p>
</li>
<li>
<p>w0 (scalar) : reference energy at zero strain, 520.7 cm-1 for silicon</p>
</li>
</ul>
<p>return:</p>
<ul>
<li>an array of three elements with the energy of the three phonon modes (LO, TO1, and TO2).</li>
</ul></div>
</dd>
<dt id="dopes.data_analysis.raman.plot_from_file"><code class="name flex">
<span>def <span class="ident">plot_from_file</span></span>(<span>file_path,<br>ax=None,<br>with_peaks=False,<br>with_peaks_label=False,<br>height=None,<br>threshold=None,<br>distance=None,<br>width=None,<br>**plot_kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_from_file(file_path,ax=None,with_peaks=False,with_peaks_label=False,height=None, threshold=None, distance=None, width=None,**plot_kwargs):
    &#34;&#34;&#34; Function to plot the Raman spectrum with the peaks indicated
    
        args:
           \n\t- file_path (string) : the file to read
           \n\t- ax (Axes) : the axes of the subplot in which plotting the Raman signal and peaks
           \n\t- with_peaks (boolean) : if True, find the peaks in the spectrum and show them on the graph. Be careful that the method is not a fit put a peak detection.
           \n\t- with_peaks_label (boolean) : if True, write the value of the peaks above each of them
           \n\t- height (None, scalar or 2-element sequence) : required height of peaks. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required height.
           \n\t- threshold (None, scalar or 2-element sequence) : required threshold of peaks, the vertical distance to its neighboring samples. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required threshold.
           \n\t- distance (scalar) : Required minimal horizontal distance in samples between neighbouring peaks. The distance should be higher than the step between two adjacents points from x. Smaller peaks are removed first until the condition is fulfilled for all remaining peaks.
           \n\t- width (None, scalar or 2-element sequence) : required width of peaks in samples. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required width.
           \n\t- **plot_kwargs : this method also takes any keyword argument for the Axes.plot() function such as linewidth, linestyle, marker, markersize, color, markeredgecolor, zorder, alpha, label, clip_on, ...
            
        return:
           \n\t- fig, ax : the Figure and Axes object created if None is specified for ax
    &#34;&#34;&#34;
    
    data=file_handling.read_file(file_path,comments=&#34;#&#34;,delimiter=None)
    x=data[:,0]
    y=data[:,1]
    
    if ax==None:
        fig=plt.figure()
        ax_data=fig.add_subplot()
    else:
        ax_data=ax
        
    if with_peaks:
        plot_with_peaks(x,y,ax=ax_data,height=height, threshold=threshold, distance=distance, width=width,with_peaks_label=with_peaks_label,**plot_kwargs)
    else:
        ax_data.plot(x,y,**plot_kwargs)
        
    if ax==None:
        return fig, ax_data</code></pre>
</details>
<div class="desc"><p>Function to plot the Raman spectrum with the peaks indicated</p>
<p>args:</p>
<ul>
<li>
<p>file_path (string) : the file to read</p>
</li>
<li>
<p>ax (Axes) : the axes of the subplot in which plotting the Raman signal and peaks</p>
</li>
<li>
<p>with_peaks (boolean) : if True, find the peaks in the spectrum and show them on the graph. Be careful that the method is not a fit put a peak detection.</p>
</li>
<li>
<p>with_peaks_label (boolean) : if True, write the value of the peaks above each of them</p>
</li>
<li>
<p>height (None, scalar or 2-element sequence) : required height of peaks. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required height.</p>
</li>
<li>
<p>threshold (None, scalar or 2-element sequence) : required threshold of peaks, the vertical distance to its neighboring samples. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required threshold.</p>
</li>
<li>
<p>distance (scalar) : Required minimal horizontal distance in samples between neighbouring peaks. The distance should be higher than the step between two adjacents points from x. Smaller peaks are removed first until the condition is fulfilled for all remaining peaks.</p>
</li>
<li>
<p>width (None, scalar or 2-element sequence) : required width of peaks in samples. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required width.</p>
</li>
<li>
<p>**plot_kwargs : this method also takes any keyword argument for the Axes.plot() function such as linewidth, linestyle, marker, markersize, color, markeredgecolor, zorder, alpha, label, clip_on, &hellip;</p>
</li>
</ul>
<p>return:</p>
<ul>
<li>fig, ax : the Figure and Axes object created if None is specified for ax</li>
</ul></div>
</dd>
<dt id="dopes.data_analysis.raman.plot_from_multiple_files"><code class="name flex">
<span>def <span class="ident">plot_from_multiple_files</span></span>(<span>file_paths,<br>with_peaks=False,<br>with_peaks_label=False,<br>height=None,<br>threshold=None,<br>distance=None,<br>width=None,<br>sharey=False,<br>ylabel=None,<br>**plot_kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_from_multiple_files(file_paths,with_peaks=False,with_peaks_label=False,height=None, threshold=None, distance=None, width=None,sharey=False,ylabel=None,**plot_kwargs):
    
    &#34;&#34;&#34; Function to plot the Raman spectrum with the peaks indicated
    
        args:
           \n\t- file_paths (list of string) : lis of the names for the files to read
           \n\t- ax (Axes) : the axes of the subplot in which plotting the Raman signal and peaks
           \n\t- with_peaks (boolean) : if True, find the peaks in the spectrum and show them on the graph. Be careful that the method is not a fit put a peak detection.
           \n\t- with_peaks_label (boolean) : if True, write the value of the peaks above each of them
           \n\t- height (None, scalar or 2-element sequence) : required height of peaks. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required height.
           \n\t- threshold (None, scalar or 2-element sequence) : required threshold of peaks, the vertical distance to its neighboring samples. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required threshold.
           \n\t- distance (scalar) : Required minimal horizontal distance in samples between neighbouring peaks. The distance should be higher than the step between two adjacents points from x. Smaller peaks are removed first until the condition is fulfilled for all remaining peaks.
           \n\t- width (None, scalar or 2-element sequence) : required width of peaks in samples. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required width.
           \n\t- **plot_kwargs : this method also takes any keyword argument for the Axes.plot() function such as linewidth, linestyle, marker, markersize, color, markeredgecolor, zorder, alpha, label, clip_on, ...
            
        return:
           \n\t- fig, ax : the Figure and a list with the axes object created
    &#34;&#34;&#34;
    
    n_plot=len(file_paths)
    fig,ax=plt.subplots(n_plot,1,sharex=True,sharey=sharey,figsize=(5,n_plot*2))
    
    for i in range(n_plot):
        ax[-i-1].spines.right.set_visible(False)
        ax[-i-1].spines.top.set_visible(False)
        if ylabel is not None:
            ax[-i-1].set_ylabel(ylabel)
        # if i != 0:
        #     ax[-i-1].xticklabels.bottom.set_visible(False)
        plot_from_file(file_paths[i],ax=ax[-i-1],with_peaks=with_peaks,with_peaks_label=with_peaks_label,height=height, threshold=threshold, distance=distance, width=width,**plot_kwargs)
        
    return fig, ax</code></pre>
</details>
<div class="desc"><p>Function to plot the Raman spectrum with the peaks indicated</p>
<p>args:</p>
<ul>
<li>
<p>file_paths (list of string) : lis of the names for the files to read</p>
</li>
<li>
<p>ax (Axes) : the axes of the subplot in which plotting the Raman signal and peaks</p>
</li>
<li>
<p>with_peaks (boolean) : if True, find the peaks in the spectrum and show them on the graph. Be careful that the method is not a fit put a peak detection.</p>
</li>
<li>
<p>with_peaks_label (boolean) : if True, write the value of the peaks above each of them</p>
</li>
<li>
<p>height (None, scalar or 2-element sequence) : required height of peaks. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required height.</p>
</li>
<li>
<p>threshold (None, scalar or 2-element sequence) : required threshold of peaks, the vertical distance to its neighboring samples. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required threshold.</p>
</li>
<li>
<p>distance (scalar) : Required minimal horizontal distance in samples between neighbouring peaks. The distance should be higher than the step between two adjacents points from x. Smaller peaks are removed first until the condition is fulfilled for all remaining peaks.</p>
</li>
<li>
<p>width (None, scalar or 2-element sequence) : required width of peaks in samples. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required width.</p>
</li>
<li>
<p>**plot_kwargs : this method also takes any keyword argument for the Axes.plot() function such as linewidth, linestyle, marker, markersize, color, markeredgecolor, zorder, alpha, label, clip_on, &hellip;</p>
</li>
</ul>
<p>return:</p>
<ul>
<li>fig, ax : the Figure and a list with the axes object created</li>
</ul></div>
</dd>
<dt id="dopes.data_analysis.raman.plot_with_peaks"><code class="name flex">
<span>def <span class="ident">plot_with_peaks</span></span>(<span>x,<br>y,<br>ax=None,<br>height=None,<br>threshold=None,<br>distance=None,<br>width=None,<br>with_peaks_label=False,<br>**plot_kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_with_peaks(x,y,ax=None,height=None, threshold=None, distance=None, width=None,with_peaks_label=False,**plot_kwargs):
    &#34;&#34;&#34; Function to plot the Raman spectrum with the peaks indicated.  Be careful that the method is not a fit put a peak detection.
    
        args:
           \n\t- x (array) : an array for the energy of the Raman spectrum
           \n\t- y (array) : the Raman signal with peaks with the same dimension as x
           \n\t- ax (Axes) : the axes of the subplot in which plotting the Raman signal and peaks
           \n\t- height (None, scalar or 2-element sequence) : required height of peaks. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required height.
           \n\t- threshold (None, scalar or 2-element sequence) : required threshold of peaks, the vertical distance to its neighboring samples. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required threshold.
           \n\t- distance (scalar) : Required minimal horizontal distance in samples between neighbouring peaks. The distance should be higher than the step between two adjacents points from x. Smaller peaks are removed first until the condition is fulfilled for all remaining peaks.
           \n\t- width (None, scalar or 2-element sequence) : required width of peaks in samples. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required width.
           \n\t- with_peaks_label (boolean) : if True, write the value of the peaks above each of them
           \n\t- **plot_kwargs : this method also takes any keyword argument for the Axes.plot() function such as linewidth, linestyle, marker, markersize, color, markeredgecolor, zorder, alpha, label, clip_on, ...
            
        return:
           \n\t- fig, ax : the Figure and Axes object created if None is specified for ax
    &#34;&#34;&#34;
    
    if ax==None:
        fig=plt.figure()
        ax_data=fig.add_subplot()
    else:
        ax_data=ax
    
    ax_data.plot(x,y,**plot_kwargs)
    position, heights, width=find_peaks(x,y,height=height, threshold=threshold, distance=distance, width=width)
    
    ax_data.plot(position,heights,marker=&#34;.&#34;,ls=&#34;&#34;,color=&#34;k&#34;)
    for i in range(len(heights)):
        ax_data.plot([position[i],position[i]],[0,heights[i]],marker=&#34;&#34;,ls=&#34;--&#34;,color=&#34;k&#34;)
        if with_peaks_label:
            ax_data.text(position[i],1.1*heights[i],&#34;%.2f&#34;%position[i],ha=&#34;center&#34;,va=&#34;bottom&#34;,rotation=&#34;vertical&#34;)
    if ax==None:
        return fig, ax_data</code></pre>
</details>
<div class="desc"><p>Function to plot the Raman spectrum with the peaks indicated.
Be careful that the method is not a fit put a peak detection.</p>
<p>args:</p>
<ul>
<li>
<p>x (array) : an array for the energy of the Raman spectrum</p>
</li>
<li>
<p>y (array) : the Raman signal with peaks with the same dimension as x</p>
</li>
<li>
<p>ax (Axes) : the axes of the subplot in which plotting the Raman signal and peaks</p>
</li>
<li>
<p>height (None, scalar or 2-element sequence) : required height of peaks. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required height.</p>
</li>
<li>
<p>threshold (None, scalar or 2-element sequence) : required threshold of peaks, the vertical distance to its neighboring samples. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required threshold.</p>
</li>
<li>
<p>distance (scalar) : Required minimal horizontal distance in samples between neighbouring peaks. The distance should be higher than the step between two adjacents points from x. Smaller peaks are removed first until the condition is fulfilled for all remaining peaks.</p>
</li>
<li>
<p>width (None, scalar or 2-element sequence) : required width of peaks in samples. Either a number, None, an array matching x or a 2-element sequence of the former. The first element is always interpreted as the minimal and the second, if supplied, as the maximal required width.</p>
</li>
<li>
<p>with_peaks_label (boolean) : if True, write the value of the peaks above each of them</p>
</li>
<li>
<p>**plot_kwargs : this method also takes any keyword argument for the Axes.plot() function such as linewidth, linestyle, marker, markersize, color, markeredgecolor, zorder, alpha, label, clip_on, &hellip;</p>
</li>
</ul>
<p>return:</p>
<ul>
<li>fig, ax : the Figure and Axes object created if None is specified for ax</li>
</ul></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dopes.data_analysis" href="index.html">dopes.data_analysis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dopes.data_analysis.raman.find_peaks" href="#dopes.data_analysis.raman.find_peaks">find_peaks</a></code></li>
<li><code><a title="dopes.data_analysis.raman.find_peaks_from_file" href="#dopes.data_analysis.raman.find_peaks_from_file">find_peaks_from_file</a></code></li>
<li><code><a title="dopes.data_analysis.raman.phonon_deformation_silicon" href="#dopes.data_analysis.raman.phonon_deformation_silicon">phonon_deformation_silicon</a></code></li>
<li><code><a title="dopes.data_analysis.raman.plot_from_file" href="#dopes.data_analysis.raman.plot_from_file">plot_from_file</a></code></li>
<li><code><a title="dopes.data_analysis.raman.plot_from_multiple_files" href="#dopes.data_analysis.raman.plot_from_multiple_files">plot_from_multiple_files</a></code></li>
<li><code><a title="dopes.data_analysis.raman.plot_with_peaks" href="#dopes.data_analysis.raman.plot_with_peaks">plot_with_peaks</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
