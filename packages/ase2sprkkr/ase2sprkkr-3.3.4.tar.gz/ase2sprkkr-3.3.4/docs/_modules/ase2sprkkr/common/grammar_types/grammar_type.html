

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ase2sprkkr.common.grammar_types.grammar_type &mdash; ASE2SPRKKR  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/mods.css?v=26f6988d" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            ASE2SPRKKR
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../usage.html">How to use the package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../how-to-install.html">More about the package installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../philosophy.html">Philosophy of the package (for developers)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference external" href="_static/slides.pdf#http://">Hastily written ASE2SPRKKR slides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../examples.html">Examples</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Links</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://ase2sprkkr.github.io/ase2sprkkr/">ASE2SPRKKR homepage</a></li>
<li class="toctree-l1"><a class="reference external" href="https://wiki.fysik.dtu.dk/ase/">ASE - atomic simulation environment</a></li>
<li class="toctree-l1"><a class="reference external" href="https://ebert.cup.uni-muenchen.de/index.php/en/software-en/13-sprkkr">SPR-KKR</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/ase2sprkkr/ase2sprkkr">GitHub repository</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pypi.org/project/ase2sprkkr">PyPI package</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.ebert.cup.uni-muenchen.de/index.php/en/repository/func-startdown/251/lang,en-gb/">SPR-KKR manual</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Class documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../auto/ase2sprkkr.html">ase2sprkkr</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">ASE2SPRKKR</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">ase2sprkkr.common.grammar_types.grammar_type</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ase2sprkkr.common.grammar_types.grammar_type</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; Basic types for GrammarTypes and usefull functions &quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Hashable</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pyparsing</span> <span class="k">as</span> <span class="nn">pp</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">grammar_types</span>

<span class="kn">from</span> <span class="nn">..decorators</span> <span class="kn">import</span> <span class="n">cached_class_property</span><span class="p">,</span> <span class="n">cache</span><span class="p">,</span> \
                         <span class="n">add_called_class_as_argument</span><span class="p">,</span> <span class="n">cached_property</span>
<span class="kn">from</span> <span class="nn">..alternative_types</span> <span class="kn">import</span> <span class="n">normalize_type</span><span class="p">,</span> <span class="n">allowed_types</span>
<span class="kn">from</span> <span class="nn">..grammar</span> <span class="kn">import</span> <span class="n">generate_grammar</span>
<span class="kn">from</span> <span class="nn">..formats</span> <span class="kn">import</span> <span class="n">full_format_for_string</span>


<div class="viewcode-block" id="GrammarType">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType">[docs]</a>
<span class="k">class</span> <span class="nc">GrammarType</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot; Base class for definition of configuration option types</span>

<span class="sd">      A type without value (e.g. Separator) are just syntactical</span>
<span class="sd">      elements in the potentials file, that do not carry an information.</span>
<span class="sd">      Such elements do not yields (name, value) pair during parsing the file.</span>

<span class="sd">      Do not confuse this with GrammarType.missing_value functionality.</span>
<span class="sd">      Missing_value is just the opposite: missing_value can be ommited in the file</span>
<span class="sd">      (or even the absence of the name in the file carry the information, that</span>
<span class="sd">      the Flag is False), but the name-value tuple of such Type is present</span>
<span class="sd">      in the parse result. On the other hand, has_value = False is in the file, but</span>
<span class="sd">      not in the result.</span>

<span class="sd">      **The functions called during...**</span>

<span class="sd">      ::</span>

<span class="sd">        User input:  convert, validate</span>

<span class="sd">        Output: string -&gt; _string</span>

<span class="sd">        Parsing: parse -&gt; ( &lt;_grammar parse actions&gt;, validate(why=&#39;parse&#39;) )</span>

<span class="sd">  &quot;&quot;&quot;</span>

  <span class="n">has_value</span> <span class="o">=</span> <span class="kc">True</span>

  <span class="n">name_in_grammar</span> <span class="o">=</span> <span class="kc">True</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot; Default value for ValueDefinition.name_in_grammar.</span>
<span class="sd">      Some types (e.g. Tables) commonly have no name (are identified</span>
<span class="sd">      by its position in the potential file) -- such type could redefine</span>
<span class="sd">      this class property.&quot;&quot;&quot;</span>

  <span class="n">default_value</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot; Default value for the given type. It can be overriden for particular instances</span>
<span class="sd">  in the constructor (or just by setting the attribute of an instantiated object). &quot;&quot;&quot;</span>

  <span class="n">numpy_type</span> <span class="o">=</span> <span class="nb">object</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot; The numpy dtype of the array, that contains values of this type (see e.g. :class:`Array`).</span>
<span class="sd">      The default type ``object`` can and should be redefined in the descendatns. &quot;&quot;&quot;</span>

  <span class="n">array_access</span> <span class="o">=</span> <span class="kc">False</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot; The value of this type can be accessed as array &quot;&quot;&quot;</span>

  <span class="n">is_independent_on_the_predecessor</span> <span class="o">=</span> <span class="kc">False</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot; Options of most grammar types do not identify themselves, so they have to be either identified by their names, or if name is not given, by their predecessors. Hoewever, e.g. keyword arguments can be identified just by their value.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="GrammarType.__init__">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType.__init__">[docs]</a>
  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">postfix</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="nb">format</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">after_format</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">default_value</span><span class="p">:</span><span class="n">Any</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">condition</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span><span class="nb">str</span><span class="p">]],</span><span class="kc">None</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">after_convert</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Any</span><span class="p">],</span><span class="kc">None</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">description</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Create the object.</span>

<span class="sd">      Parameters</span>
<span class="sd">      ----------</span>
<span class="sd">      prefix</span>
<span class="sd">        The string, that will be printed before the value</span>

<span class="sd">      postfix</span>
<span class="sd">        The string, that will be printed after the value</span>

<span class="sd">      format</span>
<span class="sd">        The (python) format string, that will be used for outputing the value.</span>
<span class="sd">        The format is passed as format argument to ``str.format`` routine.</span>

<span class="sd">      after_format</span>
<span class="sd">        In some cases, the additional formating is required after converting to the string</span>
<span class="sd">        and adding postfix/prefix.</span>

<span class="sd">      default_value</span>
<span class="sd">        The default value of the options of this type. ``None`` means no default value.</span>

<span class="sd">      condition</span>
<span class="sd">        Function, that check the validity of the value. It should return ``True`` for a valid</span>
<span class="sd">        value, and ``False`` or string for invalid. The string is interpreted as an error message</span>
<span class="sd">        that explains the invalidity of the value.</span>

<span class="sd">      after_convert</span>
<span class="sd">        Function, that - if it is given - is applied to the (entered or parsed) value. The function</span>
<span class="sd">        is applied on the result of the</span>
<span class="sd">        :meth:`convert&lt;ase2sprkkr.common.grammar_types.GrammarType.convert&gt;` method</span>
<span class="sd">      &quot;&quot;&quot;</span>

      <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span>
<span class="w">      </span><span class="sd">&quot;&quot;&quot; The string, that will be printed before the value &quot;&quot;&quot;</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">postfix</span> <span class="o">=</span> <span class="n">postfix</span>
<span class="w">      </span><span class="sd">&quot;&quot;&quot; The string, that will be printed after the value &quot;&quot;&quot;</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_format</span> <span class="o">=</span> <span class="nb">format</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">after_format</span> <span class="o">=</span> <span class="n">after_format</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">after_format</span> <span class="ow">or</span> <span class="s1">&#39;{&#39;</span> <span class="ow">in</span> <span class="n">after_format</span> <span class="k">else</span> \
                         <span class="sa">f</span><span class="s1">&#39;</span><span class="se">{{</span><span class="s1">:</span><span class="si">{</span><span class="n">after_format</span><span class="si">}</span><span class="se">}}</span><span class="s1">&#39;</span>
<span class="w">      </span><span class="sd">&quot;&quot;&quot; The (python) format string, that will be used for printing the value.</span>
<span class="sd">        The format is passed as format argument to ``str.format`` routine.  &quot;&quot;&quot;</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">condition</span> <span class="o">=</span> <span class="n">condition</span>
      <span class="k">if</span> <span class="n">after_convert</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">convert</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> \
              <span class="n">after_convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

<span class="w">      </span><span class="sd">&quot;&quot;&quot; Some subclasses has default_value defined via read-only property. &quot;&quot;&quot;</span>
      <span class="k">if</span> <span class="n">default_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">default_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">default_value</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_description</span> <span class="o">=</span> <span class="n">description</span></div>


  <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>

  <span class="nd">@cached_property</span>
  <span class="k">def</span> <span class="nf">format</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&quot;&quot;&quot; Return the resulting format string, applying the prefix and postfix &quot;&quot;&quot;</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">postfix</span><span class="p">:</span>
          <span class="k">return</span> <span class="kc">None</span>
      <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span>
      <span class="k">if</span> <span class="s1">&#39;{&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">out</span><span class="p">:</span>
            <span class="n">out</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">{{</span><span class="s1">:</span><span class="si">{</span><span class="n">out</span><span class="si">}</span><span class="se">}}</span><span class="s1">&#39;</span>
      <span class="n">escape</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;{&#39;</span><span class="p">,</span><span class="s1">&#39;{{&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;}&#39;</span><span class="p">,</span> <span class="s1">&#39;}}&#39;</span><span class="p">)</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">:</span>
        <span class="n">out</span><span class="o">=</span><span class="n">escape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">)</span> <span class="o">+</span> <span class="n">out</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">postfix</span><span class="p">:</span>
        <span class="n">out</span><span class="o">+=</span><span class="n">escape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postfix</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">out</span>

  <span class="nd">@format</span><span class="o">.</span><span class="n">setter</span>
  <span class="k">def</span> <span class="nf">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_format</span> <span class="o">=</span> <span class="n">v</span>
      <span class="k">if</span> <span class="s1">&#39;format&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
          <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;format&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="GrammarType.is_the_same_value">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType.is_the_same_value">[docs]</a>
  <span class="nd">@staticmethod</span>
  <span class="k">def</span> <span class="nf">is_the_same_value</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Comparison function for the values of &quot;this type&quot;.</span>

<span class="sd">    Not all values (e.g. numpy arrays) can be compared by equal sign,</span>
<span class="sd">    so this function has to be used for comparison of the values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span></div>


<div class="viewcode-block" id="GrammarType.grammar">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType.grammar">[docs]</a>
  <span class="nd">@cache</span>
  <span class="k">def</span> <span class="nf">grammar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_name</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return a pyparsing grammar for the type</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    param_name</span>
<span class="sd">      The name of the value, that can be assigned to the generated grammar element.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">grammar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">ParserElement</span><span class="p">):</span>
       <span class="n">grammar</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">Forward</span><span class="p">()</span>
       <span class="n">grammar</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grammar</span>
    <span class="k">else</span><span class="p">:</span>
       <span class="n">grammar</span> <span class="o">=</span> <span class="n">grammar</span><span class="p">(</span><span class="n">param_name</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">postfix</span><span class="p">:</span>
       <span class="k">with</span> <span class="n">generate_grammar</span><span class="p">():</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">:</span>
           <span class="n">grammar</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">Literal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">)</span><span class="o">.</span><span class="n">suppress</span><span class="p">()</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">)</span> <span class="o">+</span> <span class="n">grammar</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">postfix</span><span class="p">:</span>
           <span class="n">grammar</span> <span class="o">+=</span> <span class="n">pp</span><span class="o">.</span><span class="n">Literal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postfix</span><span class="p">)</span><span class="o">.</span><span class="n">suppress</span><span class="p">()</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">postfix</span><span class="p">)</span>
        <span class="n">grammar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">param_name</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_value</span><span class="p">:</span>
       <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
           <span class="k">try</span><span class="p">:</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">why</span><span class="o">=</span><span class="s1">&#39;parse&#39;</span><span class="p">,</span> <span class="n">param_name</span><span class="o">=</span><span class="n">param_name</span><span class="p">)</span>
           <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
             <span class="k">raise</span> <span class="n">pp</span><span class="o">.</span><span class="n">ParseException</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Validating of the parsed value failed&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
           <span class="k">return</span> <span class="n">x</span>

       <span class="n">grammar</span><span class="o">.</span><span class="n">addParseAction</span><span class="p">(</span><span class="n">validate</span><span class="p">)</span>
    <span class="n">grammar</span><span class="o">.</span><span class="n">grammar_type</span> <span class="o">=</span> <span class="bp">self</span>
    <span class="k">return</span> <span class="n">grammar</span></div>


<div class="viewcode-block" id="GrammarType.parse">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType.parse">[docs]</a>
  <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">whole_string</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse the string, return the obtained value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">()</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">whole_string</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="GrammarType.parse_from_stream">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType.parse_from_stream">[docs]</a>
  <span class="k">async</span> <span class="k">def</span> <span class="nf">parse_from_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">up_to</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">whole_string</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">stream</span><span class="o">.</span><span class="n">readuntil</span><span class="p">(</span><span class="n">up_to</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">up_to</span><span class="p">)]</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf8&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">start</span><span class="p">:</span>
       <span class="n">result</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">result</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">whole_string</span><span class="p">)</span></div>


<div class="viewcode-block" id="GrammarType.grammar_name">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType.grammar_name">[docs]</a>
  <span class="k">def</span> <span class="nf">grammar_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Human readable expression of the grammar. By default,</span>
<span class="sd">        this is what is set by grammar.setName, however, sometimes</span>
<span class="sd">        is desirable to set even shorter string &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">,</span> <span class="n">pp</span><span class="o">.</span><span class="n">ParserElement</span><span class="p">):</span>
       <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">)</span></div>


<div class="viewcode-block" id="GrammarType.transform_grammar">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType.transform_grammar">[docs]</a>
  <span class="k">def</span> <span class="nf">transform_grammar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">param_name</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; The chance for the resulting class to alter the resulting prefixed grammar &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">grammar</span></div>


<div class="viewcode-block" id="GrammarType.missing_value">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType.missing_value">[docs]</a>
  <span class="k">def</span> <span class="nf">missing_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Is the configuraion value a flag? I.e., can be =&lt;value&gt; ommited</span>
<span class="sd">    in the configuration?</span>

<span class="sd">    Return</span>
<span class="sd">    ------</span>
<span class="sd">    can_be_ommited : bool</span>
<span class="sd">        Is an ommision of the value possible, e.g. the option is given as Flag (only by name of the option)</span>
<span class="sd">    default_value</span>
<span class="sd">        The value used if the value is ommitted</span>
<span class="sd">    do_not_output_the_option</span>
<span class="sd">        The value, for which the variable should not be outputed at all (e.g. False for a flag)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="GrammarType.validate">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType.validate">[docs]</a>
  <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">param_name</span><span class="o">=</span><span class="s1">&#39;&lt;Unknown&gt;&#39;</span><span class="p">,</span> <span class="n">why</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;set&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Validate either the pyparsing result or a user given value.</span>

<span class="sd">    Do not override this method in subclasses for the validation implementation,</span>
<span class="sd">    this method calls :meth:`_validate`, which should contain the actual validation</span>

<span class="sd">    Parameters</span>
<span class="sd">    ---------</span>
<span class="sd">    value : mixed</span>
<span class="sd">      Value to be validated.</span>

<span class="sd">    param_name : str or callable</span>
<span class="sd">      Parameter name to be used in possible throwed exception (Optional).</span>
<span class="sd">      If it is callable, it should be a function that returns the param_name.</span>

<span class="sd">    why</span>
<span class="sd">      Possible values are:</span>

<span class="sd">      ``set``</span>
<span class="sd">         validation value setted by user (in rare cases, such value can be incomplete</span>
<span class="sd">         and requires `completing` during ``set_from_atoms`` call before saving the output)</span>
<span class="sd">      ``parse``</span>
<span class="sd">         validation during parsing input file, checks enforced</span>
<span class="sd">         by the grammar can be skipped</span>
<span class="sd">      ``save``</span>
<span class="sd">         validation before saving the values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">why</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_valueError</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">param_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">_valueError</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">param_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">condition</span><span class="p">:</span>
      <span class="n">err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">err</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_valueError</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">param_name</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="GrammarType._validate">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType._validate">[docs]</a>
  <span class="k">def</span> <span class="nf">_validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">why</span><span class="o">=</span><span class="s1">&#39;set&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return error message if the value is not valid. &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="GrammarType._valueError">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType._valueError">[docs]</a>
  <span class="k">def</span> <span class="nf">_valueError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">error_message</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">param_name</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">param_name</span><span class="p">):</span>
       <span class="n">param_name</span> <span class="o">=</span> <span class="n">param_name</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">param_name</span><span class="p">:</span>
       <span class="n">param</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;for paramater </span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s1"> of type </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">else</span><span class="p">:</span>
       <span class="n">param</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;for type </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">if</span> <span class="n">error_message</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
       <span class="n">error_message</span> <span class="o">=</span> <span class="s1">&#39;invalid value&#39;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">error_message</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Value &#39;</span><span class="si">{}</span><span class="s2">&#39; </span><span class="si">{}</span><span class="s2"> is not valid: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">error_message</span><span class="p">))</span> <span class="kn">from</span> <span class="nn">error_message</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Value &#39;</span><span class="si">{}</span><span class="s2">&#39; </span><span class="si">{}</span><span class="s2"> is not valid: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">error_message</span><span class="p">))</span></div>


<div class="viewcode-block" id="GrammarType.convert">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType.convert">[docs]</a>
  <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Convert a value from user to the &quot;cannonical form&quot; &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">value</span></div>


<div class="viewcode-block" id="GrammarType._string">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType._string">[docs]</a>
  <span class="k">def</span> <span class="nf">_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the value to the ouput.</span>

<span class="sd">    The :meth:`string` apply format and do some additional transformation (add prefix, postfix etc.),</span>
<span class="sd">    so the actual way how to convert the value for the output should be here. &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">val</span></div>


<div class="viewcode-block" id="GrammarType.string">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType.string">[docs]</a>
  <span class="k">def</span> <span class="nf">string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Convert the value to the string according to the class definition.</span>

<span class="sd">    Before redefining this method, you should consider, whether :meth:`_string` method could be</span>
<span class="sd">    redefined instead. Otherwise, you should call :meth:`apply_format` in the redefined method.</span>
<span class="sd">    to retain the common functionality (as adding prefix or postfix to the resulting</span>
<span class="sd">    string).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_string</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_format</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">val</span></div>


<div class="viewcode-block" id="GrammarType.apply_format">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType.apply_format">[docs]</a>
  <span class="k">def</span> <span class="nf">apply_format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Apply format to the outputed value. &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">:</span>
       <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
       <span class="n">val</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">after_format</span><span class="p">:</span>
      <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">after_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">val</span></div>


<div class="viewcode-block" id="GrammarType.format_string">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType.format_string">[docs]</a>
  <span class="k">def</span> <span class="nf">format_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Format string in a similiar manner as a value.</span>
<span class="sd">        It is usefull for simple types, where header of a table</span>
<span class="sd">        should be formatted in the same way.</span>
<span class="sd">        For complex types it may not give a reasonable results.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">:</span>
       <span class="n">out</span><span class="o">=</span><span class="n">full_format_for_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
       <span class="n">out</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">after_format</span><span class="p">:</span>
       <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">after_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="GrammarType.write">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType.write">[docs]</a>
  <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Output the value to the stream (in the propper format). &quot;&quot;&quot;</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">(</span><span class="n">val</span><span class="p">))</span></div>


<div class="viewcode-block" id="GrammarType.print">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType.print">[docs]</a>
  <span class="k">def</span> <span class="nf">print</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Output the value to stdout (in the propper format). &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">string</span><span class="p">(</span><span class="n">val</span><span class="p">))</span></div>


<div class="viewcode-block" id="GrammarType.copy">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType.copy">[docs]</a>
  <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="GrammarType.enrich">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType.enrich">[docs]</a>
  <span class="k">def</span> <span class="nf">enrich</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">option</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Some types can add properties to the options that have</span>
<span class="sd">    the type, e.g. see Sequence.enrich, which adds the ability to</span>
<span class="sd">    access the items of the sequence using [] &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


  <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

<div class="viewcode-block" id="GrammarType.additional_description">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType.additional_description">[docs]</a>
  <span class="k">def</span> <span class="nf">additional_description</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; If the description of the type does not fit on one line,</span>
<span class="sd">    this method should return</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    additional_description</span>
<span class="sd">      The additional description (e.g. possible choices) of the type. Multiline string.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_description</span>
    <span class="k">if</span> <span class="n">prefix</span> <span class="ow">and</span> <span class="n">out</span><span class="p">:</span>
       <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">prefix</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="GrammarType.type_validation">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType.type_validation">[docs]</a>
  <span class="k">def</span> <span class="nf">type_validation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">types</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Type</span><span class="p">],</span> <span class="n">Type</span><span class="p">],</span> <span class="n">typename</span><span class="p">:</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    value: mixed</span>
<span class="sd">      Value to be checked</span>

<span class="sd">    types</span>
<span class="sd">      The required type or types. If more types is given, it is sufficient, if the value is of</span>
<span class="sd">      any of given types.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    error_message: Union[str, bool]</span>
<span class="sd">      The function returns either False, if the value is ok, or string containing an error</span>
<span class="sd">      message describing the error.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">types</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">typename</span><span class="p">:</span>
       <span class="n">typename</span> <span class="o">=</span> <span class="n">types</span>
    <span class="n">typename</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">typename</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="s1">&#39;n&#39;</span> <span class="k">if</span> <span class="n">typename</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;e&#39;</span><span class="p">,</span><span class="s1">&#39;i&#39;</span><span class="p">,</span><span class="s1">&#39;o&#39;</span><span class="p">,</span><span class="s1">&#39;u&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;A</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> &lt;</span><span class="si">{</span><span class="n">typename</span><span class="si">}</span><span class="s2">&gt; value is required, a value </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> of type </span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="vm">__class__</span><span class="si">}</span><span class="s2"> have been given&quot;</span></div>


<div class="viewcode-block" id="GrammarType.copy_value">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType.copy_value">[docs]</a>
  <span class="k">def</span> <span class="nf">copy_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">value</span></div>


<div class="viewcode-block" id="GrammarType.used_in_definition">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType.used_in_definition">[docs]</a>
  <span class="k">def</span> <span class="nf">used_in_definition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">definition</span><span class="p">):</span>
      <span class="k">pass</span></div>


<div class="viewcode-block" id="GrammarType.added_to_container">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType.added_to_container">[docs]</a>
  <span class="k">def</span> <span class="nf">added_to_container</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">definition</span><span class="p">):</span>
      <span class="k">pass</span></div>


<div class="viewcode-block" id="GrammarType.numpy_dtype">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.GrammarType.html#ase2sprkkr.potentials.custom_potential_section.GrammarType.numpy_dtype">[docs]</a>
  <span class="k">def</span> <span class="nf">numpy_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&quot;&quot;&quot; Return its numpy dtype and shape &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">numpy_type</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">()</span></div>
</div>



<span class="nd">@add_called_class_as_argument</span>
<span class="k">def</span> <span class="nf">add_to_parent_validation</span><span class="p">(</span><span class="n">validation</span><span class="p">):</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">validation</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapped</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">why</span><span class="o">=</span><span class="s1">&#39;set&#39;</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_validate</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">why</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
           <span class="k">return</span> <span class="n">out</span>
        <span class="k">return</span> <span class="n">validation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">why</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapped</span>


<div class="viewcode-block" id="TypedGrammarType">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.TypedGrammarType.html#ase2sprkkr.potentials.custom_potential_section.TypedGrammarType">[docs]</a>
<span class="k">class</span> <span class="nc">TypedGrammarType</span><span class="p">(</span><span class="n">GrammarType</span><span class="p">):</span>

  <span class="nd">@cached_class_property</span>
  <span class="k">def</span> <span class="nf">datatype</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&quot;&quot;&quot; The (primary) type of the value. Redefine it in the descendants, if it is needed. &quot;&quot;&quot;</span>
      <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">numpy_type</span>

  <span class="nd">@cached_class_property</span>
  <span class="k">def</span> <span class="nf">allowed_types</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">      </span><span class="sd">&quot;&quot;&quot; Allowed alternative types, that will be converted to the &#39;primary&#39; datatype. &quot;&quot;&quot;</span>
      <span class="n">dt</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">datatype</span>
      <span class="k">return</span> <span class="n">allowed_types</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="p">))</span>

<div class="viewcode-block" id="TypedGrammarType.convert">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.TypedGrammarType.html#ase2sprkkr.potentials.custom_potential_section.TypedGrammarType.convert">[docs]</a>
  <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">):</span>
         <span class="k">return</span> <span class="n">value</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowed_types</span><span class="p">:</span>
          <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
             <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">value</span></div>


  <span class="nd">@cached_class_property</span>
  <span class="k">def</span> <span class="nf">datatype_name</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

<div class="viewcode-block" id="TypedGrammarType._validate">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.TypedGrammarType.html#ase2sprkkr.potentials.custom_potential_section.TypedGrammarType._validate">[docs]</a>
  <span class="k">def</span> <span class="nf">_validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">why</span><span class="o">=</span><span class="s1">&#39;set&#39;</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_validation</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">allowed_types</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">datatype_name</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="type_from_type">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.type_from_type.html#ase2sprkkr.potentials.custom_potential_section.type_from_type">[docs]</a>
<span class="k">def</span> <span class="nf">type_from_type</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="nb">format</span><span class="p">:</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span><span class="n">Dict</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">format_all</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">type_map</span><span class="p">:</span><span class="n">Dict</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot; Guess and return the grammar element (GrammarType class descendatnt) from a python type. E.g. int =&gt; Integer.</span>

<span class="sd">      The given format can be optionally set to the returned grammar element.</span>

<span class="sd">      Parameters</span>
<span class="sd">      ----------</span>
<span class="sd">      type: A python type or GrammarType</span>
<span class="sd">        A type to be converted to a grammar type (GrammarType class descendant)</span>

<span class="sd">      format</span>
<span class="sd">        The format to be applied to the resulting class. If dict is given, see :func:`format_for_type`</span>
<span class="sd">        for the way how the format is determined</span>

<span class="sd">      format_all</span>
<span class="sd">        If False (default), the format is not applied, if instance of GrammarType is given as</span>
<span class="sd">        the type parameter. Otherwise, a copy of the input type with the applied format is returned</span>

<span class="sd">      type_map</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">grammar_types</span><span class="o">.</span><span class="n">Keyword</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span>

  <span class="n">type_from_type_map</span> <span class="o">=</span> <span class="n">grammar_types</span><span class="o">.</span><span class="n">type_from_type_map</span>

  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">GrammarType</span><span class="p">):</span>
     <span class="k">if</span> <span class="n">format_all</span><span class="p">:</span>
        <span class="nb">type</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="nb">type</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">format_for_type</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="n">normalize_type</span><span class="p">(</span><span class="nb">type</span><span class="o">.</span><span class="n">numpy_type</span><span class="p">))</span>
     <span class="k">return</span> <span class="nb">type</span>

  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">):</span>
    <span class="nb">type</span> <span class="o">=</span> <span class="n">normalize_type</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span> <span class="ow">in</span> <span class="n">type_map</span><span class="p">:</span>
       <span class="nb">type</span> <span class="o">=</span> <span class="n">type_map</span><span class="p">[</span><span class="nb">type</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">type</span> <span class="ow">in</span> <span class="n">type_from_type_map</span><span class="p">:</span>
       <span class="nb">type</span> <span class="o">=</span> <span class="n">type_from_type_map</span><span class="p">[</span><span class="nb">type</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
       <span class="k">return</span> <span class="nb">type</span>

    <span class="nb">format</span> <span class="o">=</span> <span class="n">format_for_type</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">format</span><span class="p">:</span>
        <span class="nb">type</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="nb">type</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="nb">format</span>
  <span class="k">return</span> <span class="nb">type</span></div>



<div class="viewcode-block" id="type_from_value">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.type_from_value.html#ase2sprkkr.potentials.custom_potential_section.type_from_value">[docs]</a>
<span class="k">def</span> <span class="nf">type_from_value</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">type_map</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot; Gues the grammar type from a python value.</span>

<span class="sd">  ..doctest::</span>
<span class="sd">  &gt;&gt;&gt; type_from_value(2)</span>
<span class="sd">  &lt;Integer&gt;</span>

<span class="sd">  &gt;&gt;&gt; type_from_value(2.0)</span>
<span class="sd">  &lt;Real&gt;</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="n">type_from_set_map</span> <span class="o">=</span> <span class="n">grammar_types</span><span class="o">.</span><span class="n">type_from_set_map</span>

  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">recognized_set_types</span><span class="p">):</span>
     <span class="k">return</span> <span class="n">type_from_set_map</span><span class="p">[</span><span class="n">normalize_type</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">else</span> <span class="n">grammar_types</span><span class="o">.</span><span class="n">Integer</span><span class="o">.</span><span class="n">I</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
     <span class="k">try</span><span class="p">:</span>
        <span class="n">grammar_types</span><span class="o">.</span><span class="n">String</span><span class="o">.</span><span class="n">_grammar</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grammar_types</span><span class="o">.</span><span class="n">String</span><span class="o">.</span><span class="n">I</span>
     <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">grammar_types</span><span class="o">.</span><span class="n">QString</span><span class="o">.</span><span class="n">I</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">grammar_types</span><span class="o">.</span><span class="n">Keyword</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
  <span class="nb">type</span> <span class="o">=</span> <span class="n">type_from_type</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">type_map</span><span class="o">=</span><span class="n">type_map</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="n">value</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
     <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Cannot determine grammar type from value </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
  <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">default_value</span> <span class="o">=</span> <span class="n">value</span><span class="p">)</span></div>



<div class="viewcode-block" id="type_from_default_value">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.type_from_default_value.html#ase2sprkkr.potentials.custom_potential_section.type_from_default_value">[docs]</a>
<span class="k">def</span> <span class="nf">type_from_default_value</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">format_all</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">type_map</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">   </span><span class="sd">&quot;&quot;&quot; Guess the grammar type from a value, that will become the default value of the grammar type.</span>

<span class="sd">   It has to create a new object instance, as it has to set the default</span>
<span class="sd">   value property of the returned object. An (output) format can be applied to the</span>
<span class="sd">   resulting grammar type</span>

<span class="sd">   Grammar types passed as types are left as is, unless format_all flag is set.</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">GrammarType</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">type_from_type</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span> <span class="n">format_all</span><span class="o">=</span><span class="n">format_all</span><span class="p">,</span> <span class="n">type_map</span><span class="o">=</span><span class="p">{})</span>
   <span class="n">ptype</span> <span class="o">=</span> <span class="n">normalize_type</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
   <span class="n">gtype</span> <span class="o">=</span> <span class="n">type_from_type</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">type_map</span><span class="o">=</span><span class="n">type_map</span><span class="p">)</span><span class="o">.</span><span class="vm">__class__</span>
   <span class="k">return</span> <span class="n">gtype</span><span class="p">(</span><span class="n">default_value</span> <span class="o">=</span> <span class="n">value</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">format_for_type</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="n">ptype</span><span class="p">))</span></div>



<div class="viewcode-block" id="compare_numpy_values">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.compare_numpy_values.html#ase2sprkkr.potentials.custom_potential_section.compare_numpy_values">[docs]</a>
<span class="k">def</span> <span class="nf">compare_numpy_values</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; The numpy arrays cannot be compared by =, that&#39;s why this method.</span>
<span class="sd">    However, the method is still far from to be perfect, it can not</span>
<span class="sd">    compare nested numpy arrays.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span></div>



<div class="viewcode-block" id="format_for_type">
<a class="viewcode-back" href="../../../../auto/ase2sprkkr.common.grammar_types.grammar_type.format_for_type.html#ase2sprkkr.potentials.custom_potential_section.format_for_type">[docs]</a>
<span class="k">def</span> <span class="nf">format_for_type</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Returns the format appropriate to the given type</span>

<span class="sd">  Parameters</span>
<span class="sd">  ----------</span>
<span class="sd">  format: str or dict</span>
<span class="sd">    If it is str, just return it.</span>
<span class="sd">    Dict should has the form { type : format_for_the_type } + { None : default_format }</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
     <span class="k">if</span> <span class="nb">type</span> <span class="ow">in</span> <span class="nb">format</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">format</span><span class="p">[</span><span class="nb">type</span><span class="p">]</span>
     <span class="k">return</span> <span class="nb">format</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
  <span class="k">return</span> <span class="nb">format</span></div>



<span class="n">recognized_set_types</span> <span class="o">=</span> <span class="p">(</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="p">)</span>
<span class="sd">&quot;&quot;&quot; The types, that are recognized as &#39;list of values&#39; and so that will</span>
<span class="sd">be accepted as values for array_like type (e.g. :class:`Array` or :class:`SetOf`). &quot;&quot;&quot;</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Matyáš Novák &amp; Jano Minár.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>