[
  {
    "input": "[EXAMPLE — STYLE & STRUCTURE ONLY, DO NOT COPY ASSUMPTIONS]\nGRAPH SUMMARY: 210 nodes, 402 edges.\n\nTEST SUMMARY:\n• Total: 65\n• Executed: 65 (✅58, ❌2, ⚠️5)\n• Failures detail:\n  - Tests.AsyncQueueTests::EnqueueDequeue_Race: InvalidOperationException: queue empty\n\nCRITICAL PATHS for each failed test:\n\nTest: Tests.AsyncQueueTests::EnqueueDequeue_Race\nError: InvalidOperationException: queue empty\nUpstream:\n  • AsyncQueue.cs::DequeueAsync → AsyncQueue.cs::TryDequeue\nDownstream:\n  • Tests.AsyncQueueTests::EnqueueDequeue_Race\n\nFUNCTION SNIPPETS:\n\nAsyncQueue.cs::DequeueAsync (line 74):\n    public async Task<T> DequeueAsync() {\n        return TryDequeue(); // no await on producer signal\n    }\n\nAsyncQueue.cs::TryDequeue (line 33):\n    public T TryDequeue() { /* returns default if empty */ }",
    "output": "{\n  \"analysis\": [\n    {\n      \"test_name\": \"Tests.AsyncQueueTests::EnqueueDequeue_Race\",\n      \"error\": \"InvalidOperationException: queue empty\",\n      \"call_path\": [\"AsyncQueue.cs::DequeueAsync\", \"AsyncQueue.cs::TryDequeue\"],\n      \"reasoning\": [\n        \"1) DequeueAsync does not await the producer signal and directly calls TryDequeue\",\n        \"2) In a race condition, the consumer runs ahead of the producer\",\n        \"3) TryDequeue executes on an empty queue and throws an exception\"\n      ],\n      \"root_cause\": \"Lack of proper synchronization/signaling between producer/consumer\",\n      \"suggested_fixes\": [\n        \"Use SemaphoreSlim/TaskCompletionSource for signaling item readiness\",\n        \"Implement controlled behavior in TryDequeue for empty cases and concurrency tests\"\n      ]\n    }\n  ]\n}"
  },
  {
    "input": "[EXAMPLE — STYLE & STRUCTURE ONLY, DO NOT COPY ASSUMPTIONS]\nGRAPH SUMMARY: 152 nodes, 289 edges.\n\nTEST SUMMARY:\n• Total: 87\n• Executed: 87 (✅76, ❌2, ⚠️9)\n• Failures detail:\n  - tests/test_math.py::test_divide_by_zero: ZeroDivisionError: division by zero\n\nCRITICAL PATHS for each failed test:\n\nTest: tests/test_math.py::test_divide_by_zero\nError: ZeroDivisionError: division by zero\nUpstream:\n  • math_utils.py::safe_divide → math_utils.py::_normalize_inputs\nDownstream:\n  • tests/test_math.py::test_divide_by_zero\n\nFUNCTION SNIPPETS:\n\nmath_utils.py::safe_divide (line 42):\n\"\"\"\nDivide a by b, guarding invalid inputs.\n\"\"\"\n    def safe_divide(a, b):\n        return a / b\n\nmath_utils.py::_normalize_inputs (line 12):\n\"\"\"\nEnsure inputs are numeric and non-null.\n\"\"\"\n    def _normalize_inputs(a, b):\n        ...",
    "output": "{\n  \"analysis\": [\n    {\n      \"test_name\": \"tests/test_math.py::test_divide_by_zero\",\n      \"error\": \"ZeroDivisionError: division by zero\",\n      \"call_path\": [\"math_utils.py::safe_divide\", \"math_utils.py::_normalize_inputs\"],\n      \"reasoning\": [\n        \"1) safe_divide does not check if b is zero and directly executes a/b\",\n        \"2) _normalize_inputs only checks for None, not for zero value of b\",\n        \"3) The failure occurs because safe_divide executes on zero value of b\"\n      ],\n      \"root_cause\": \"Missing guard against division by zero in safe_divide\",\n      \"suggested_fixes\": [\n        \"Add a check for b==0 and return a safe value or controlled exception\",\n        \"Add a b!=0 check in _normalize_inputs and write unit tests for it\"\n      ]\n    }\n  ]\n}"
  }
]
