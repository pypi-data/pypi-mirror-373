package eventstore

import (
    "context"
    "encoding/json"
    "fmt"
    "time"

    "github.com/nats-io/nats.go"
    "go.uber.org/zap"
    "{{ .ProjectName }}/internal/domain/event"
)

// NatsEventStore NATS事件存储
type NatsEventStore struct {
    conn   *nats.Conn
    js     nats.JetStreamContext
    stream string
    logger *zap.Logger
}

// NewNatsEventStore 创建NATS事件存储
func NewNatsEventStore(url string, stream string, logger *zap.Logger) (*NatsEventStore, error) {
    // 连接到NATS
    conn, err := nats.Connect(url)
    if err != nil {
        return nil, fmt.Errorf("failed to connect to NATS: %w", err)
    }
    
    // 获取JetStream上下文
    js, err := conn.JetStream()
    if err != nil {
        return nil, fmt.Errorf("failed to get JetStream: %w", err)
    }
    
    // 创建流
    streamConfig := &nats.StreamConfig{
        Name:      stream,
        Subjects:  []string{"events.*"},
        Storage:   nats.FileStorage,
        Retention: nats.LimitsPolicy,
        MaxAge:    24 * 365 * time.Hour, // 1年
    }
    
    _, err = js.AddStream(streamConfig)
    if err != nil && err != nats.ErrStreamNameAlreadyInUse {
        return nil, fmt.Errorf("failed to create stream: %w", err)
    }
    
    return &NatsEventStore{
        conn:   conn,
        js:     js,
        stream: stream,
        logger: logger,
    }, nil
}

// Publish 发布事件
func (s *NatsEventStore) Publish(ctx context.Context, event event.Event) error {
    data, err := json.Marshal(event)
    if err != nil {
        return fmt.Errorf("failed to marshal event: %w", err)
    }
    
    subject := fmt.Sprintf("events.%s", event.GetType())
    
    _, err = s.js.Publish(subject, data)
    if err != nil {
        return fmt.Errorf("failed to publish event: %w", err)
    }
    
    s.logger.Info("事件发布成功",
        zap.String("event_type", event.GetType()),
        zap.String("event_id", event.GetID()),
    )
    return nil
}

// Subscribe 订阅事件
func (s *NatsEventStore) Subscribe(ctx context.Context, eventType string, handler func(event.Event) error) error {
    subject := fmt.Sprintf("events.%s", eventType)
    
    _, err := s.js.Subscribe(subject, func(msg *nats.Msg) {
        var eventData map[string]interface{}
        if err := json.Unmarshal(msg.Data, &eventData); err != nil {
            s.logger.Error("反序列化事件失败", zap.Error(err))
            return
        }
        
        // 创建具体的事件实例
        var event event.Event
        switch eventType {
        case "{{ .NameLower }}.created":
            event = &event.{{ .NameUpper }}Created{}
        case "{{ .NameLower }}.updated":
            event = &event.{{ .NameUpper }}Updated{}
        case "{{ .NameLower }}.deleted":
            event = &event.{{ .NameUpper }}Deleted{}
        default:
            s.logger.Warn("未知事件类型", zap.String("event_type", eventType))
            return
        }
        
        if err := json.Unmarshal(msg.Data, event); err != nil {
            s.logger.Error("反序列化事件失败", zap.Error(err))
            return
        }
        
        if err := handler(event); err != nil {
            s.logger.Error("处理事件失败", zap.Error(err))
            return
        }
        
        msg.Ack()
    }, nats.Durable(eventType))
    
    if err != nil {
        return fmt.Errorf("failed to subscribe to events: %w", err)
    }
    
    return nil
}

// Close 关闭连接
func (s *NatsEventStore) Close() error {
    if s.conn != nil {
        s.conn.Close()
    }
    return nil
}