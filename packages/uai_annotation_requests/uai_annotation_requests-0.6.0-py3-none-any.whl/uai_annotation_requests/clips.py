"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from typing import List, Mapping, Optional
from uai_annotation_requests import models, utils
from uai_annotation_requests._hooks import HookContext
from uai_annotation_requests.types import OptionalNullable, UNSET
from uai_annotation_requests.utils.unmarshal_json_response import (
    unmarshal_json_response,
)


class Clips(BaseSDK):
    def get_clips(
        self,
        *,
        project_id: str,
        annotation_request_id: Optional[List[str]] = None,
        state: Optional[List[models.ClipBusinessState]] = None,
        clip_reference_id: Optional[List[str]] = None,
        is_export_downloaded: Optional[bool] = None,
        sort_by: Optional[models.SortBy] = None,
        sort_order: Optional[models.SortOrder] = None,
        skip: Optional[int] = None,
        limit: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ClipsList:
        r"""Get clips in the project filtered by clip reference ids and
        states.

        For example, querying for clips with state 'Exported'
        lists all the clips that have annotations to fetch.

        Combinding the filters state and isExportDownloaded
        makes it possible to list all the clips that are exported
        and haven't yet been downloaded by the client, ex:
        `?state=Exported&isExportDownloade=false`

        :param project_id: the project id to get clips for
        :param annotation_request_id: filter clips by annotation request ids
        :param state: filter clips by clip states
        :param clip_reference_id: filter by clip reference ids
        :param is_export_downloaded: filter clips by if the exported annotations are previously downloaded or not
        :param sort_by: sort the clips
        :param sort_order: ascending or descending sort order
        :param skip: skip the N first clips, can be used in combination with limit to implement pagination
        :param limit: limits the output to N number of clips
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetClipsRequest(
            project_id=project_id,
            annotation_request_id=annotation_request_id,
            state=state,
            clip_reference_id=clip_reference_id,
            is_export_downloaded=is_export_downloaded,
            sort_by=sort_by,
            sort_order=sort_order,
            skip=skip,
            limit=limit,
        )

        req = self._build_request(
            method="GET",
            path="/v1/projects/{projectId}/clips",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetClips",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "401", "403", "4XX", "503", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ClipsList, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, ["503", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    async def get_clips_async(
        self,
        *,
        project_id: str,
        annotation_request_id: Optional[List[str]] = None,
        state: Optional[List[models.ClipBusinessState]] = None,
        clip_reference_id: Optional[List[str]] = None,
        is_export_downloaded: Optional[bool] = None,
        sort_by: Optional[models.SortBy] = None,
        sort_order: Optional[models.SortOrder] = None,
        skip: Optional[int] = None,
        limit: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ClipsList:
        r"""Get clips in the project filtered by clip reference ids and
        states.

        For example, querying for clips with state 'Exported'
        lists all the clips that have annotations to fetch.

        Combinding the filters state and isExportDownloaded
        makes it possible to list all the clips that are exported
        and haven't yet been downloaded by the client, ex:
        `?state=Exported&isExportDownloade=false`

        :param project_id: the project id to get clips for
        :param annotation_request_id: filter clips by annotation request ids
        :param state: filter clips by clip states
        :param clip_reference_id: filter by clip reference ids
        :param is_export_downloaded: filter clips by if the exported annotations are previously downloaded or not
        :param sort_by: sort the clips
        :param sort_order: ascending or descending sort order
        :param skip: skip the N first clips, can be used in combination with limit to implement pagination
        :param limit: limits the output to N number of clips
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetClipsRequest(
            project_id=project_id,
            annotation_request_id=annotation_request_id,
            state=state,
            clip_reference_id=clip_reference_id,
            is_export_downloaded=is_export_downloaded,
            sort_by=sort_by,
            sort_order=sort_order,
            skip=skip,
            limit=limit,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/projects/{projectId}/clips",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetClips",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "401", "403", "4XX", "503", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ClipsList, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, ["503", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    def get_annotations(
        self,
        *,
        project_id: str,
        clip_reference_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ClipExportURL:
        r"""Get annotations for a clip.

        The clip must be in state Exported.

        :param project_id:
        :param clip_reference_id:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetAnnotationsRequest(
            project_id=project_id,
            clip_reference_id=clip_reference_id,
        )

        req = self._build_request(
            method="GET",
            path="/v1/projects/{projectId}/clips/{clipReferenceId}/annotations",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetAnnotations",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "401", "403", "4XX", "503", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ClipExportURL, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, ["503", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    async def get_annotations_async(
        self,
        *,
        project_id: str,
        clip_reference_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ClipExportURL:
        r"""Get annotations for a clip.

        The clip must be in state Exported.

        :param project_id:
        :param clip_reference_id:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetAnnotationsRequest(
            project_id=project_id,
            clip_reference_id=clip_reference_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/projects/{projectId}/clips/{clipReferenceId}/annotations",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="GetAnnotations",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["400", "401", "403", "4XX", "503", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ClipExportURL, http_res)
        if utils.match_response(http_res, ["400", "401", "403", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, ["503", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)
