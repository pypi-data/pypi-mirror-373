import{p as j,aU as _,c as I,b$ as F,bj as L,bE as w,bY as O,b as M,d as k,F as v}from"./main-BERoK-j2.js";const S=(e,t,n)=>{if(e==null||t==null)return-1;if(!t.length)return 0;e=e.toString().toLocaleLowerCase(),t=t.toString().toLocaleLowerCase();const r=[];let l=e.indexOf(t);for(;~l;)r.push([l,l+t.length]),l=e.indexOf(t,l+t.length);return r.length?r:-1};function p(e,t){if(!(e==null||typeof e=="boolean"||e===-1))return typeof e=="number"?[[e,e+t.length]]:Array.isArray(e[0])?e:[e]}const x=j({customFilter:Function,customKeyFilter:Object,filterKeys:[Array,String],filterMode:{type:String,default:"intersection"},noFilter:Boolean},"filter");function A(e,t,n){const r=[],l=n?.default??S,f=n?.filterKeys?w(n.filterKeys):!1,o=Object.keys(n?.customKeyFilter??{}).length;if(!e?.length)return r;e:for(let c=0;c<e.length;c++){const[s,m=s]=w(e[c]),g={},a={};let i=-1;if((t||o>0)&&!n?.noFilter){if(typeof s=="object"){if(s.type==="divider"||s.type==="subheader")continue;const b=f||Object.keys(m);for(const d of b){const y=O(m,d),K=n?.customKeyFilter?.[d];if(i=K?K(y,t,s):l(y,t,s),i!==-1&&i!==!1)K?g[d]=p(i,t):a[d]=p(i,t);else if(n?.filterMode==="every")continue e}}else i=l(s,t,s),i!==-1&&i!==!1&&(a.title=p(i,t));const u=Object.keys(a).length,h=Object.keys(g).length;if(!u&&!h||n?.filterMode==="union"&&h!==o&&!u||n?.filterMode==="intersection"&&(h!==o||!u))continue}r.push({index:c,matches:{...a,...g}})}return r}function C(e,t,n,r){const l=_([]),f=_(new Map),o=I(()=>r?.transform?F(t).map(s=>[s,r.transform(s)]):F(t));L(()=>{const s=typeof n=="function"?n():F(n),m=typeof s!="string"&&typeof s!="number"?"":String(s),g=A(o.value,m,{customKeyFilter:{...e.customKeyFilter,...F(r?.customKeyFilter)},default:e.customFilter,filterKeys:e.filterKeys,filterMode:e.filterMode,noFilter:e.noFilter}),a=F(t),i=[],u=new Map;g.forEach(h=>{let{index:b,matches:d}=h;const y=a[b];i.push(y),u.set(y.value,d)}),l.value=i,f.value=u});function c(s){return f.value.get(s.value)}return{filteredItems:l,filteredMatches:f,getMatches:c}}function E(e,t,n){return n==null||!n.length?t:n.map((r,l)=>{const f=l===0?0:n[l-1][1],o=[M("span",{class:k(`${e}__unmask`)},[t.slice(f,r[0])]),M("span",{class:k(`${e}__mask`)},[t.slice(r[0],r[1])])];return l===n.length-1&&o.push(M("span",{class:k(`${e}__unmask`)},[t.slice(r[1])])),M(v,null,[o])})}export{E as h,x as m,C as u};
