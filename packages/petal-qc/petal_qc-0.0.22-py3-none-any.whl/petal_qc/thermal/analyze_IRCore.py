#!/usr/bin/env python3
"""Analyze the JS files generated by create_IRCore."""
import json
import os
import sys
import bisect
from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np
from scipy.interpolate import CubicSpline
from petal_qc.utils.utils import find_file
from petal_qc.utils.utils import output_folder
import petal_qc.utils.docx_utils as docx_utils

from petal_qc.thermal import IRCore
from petal_qc.thermal import Petal_IR_Analysis
import petal_qc.utils.utils as utils

CO2_Temp_setting = -35

def get_array_as_string(A):
    """Return a string rerpresentation."""
    sss="["
    for v in A:
        sss += " {:5.3f}".format(v)

    sss+=" ]"
    return sss

def get_acceptance_band():
    """returns the width of the acceptance band."""
    band = 0.1*CO2_Temp_setting  # 10% of setting point
    return abs(band)


def get_names(files):
    """GEt names from filenames."""
    names = []
    for ifile in files:
        ifile = Path(ifile)
        names.append(ifile.stem)
    return names

def add_figures_to_doc(doc, figures, name=None):
    """Add figures to doc.

    Args:
        doc (Document): Document
        figures (list): List of figures.

    """
    if doc is None or len(figures)==0:
        return

    if name:
        doc.add_heading(name, level=1)

    for F in figures:
        doc.add_picture(F, True, 12, caption=F._suptitle.get_text())


class GoldenAxis(object):
    """Get best X path."""
    def __init__(self) -> None:
        self.xaxis = []   # Set of coordinates
        self.nitems = []  # number of curves with this axis
        self.index = []
        self.size = []
        self.current = 0

    @staticmethod
    def round_npts(V):
        """Return the closest multiple of 10."""
        npts = len(V)
        return int(int(npts/10.0 + 0.5)*10)

    def check_axis(self, X, indx):
        """Check in X array is there or not.

        Args:
            X (np.ndarray): The axis to check.
            i (int): the index in the array of results.

        """
        npts = self.round_npts(X)
        for i, v in enumerate(self.xaxis):
            nv = self.size[i]
            if npts == nv:
                self.nitems[i] += 1
                self.index[i].append(indx)
                return

        self.xaxis.append(X)
        self.size.append(npts)
        self.nitems.append(1)
        self.index.append([indx])

    def get_axis(self):
        """Get the actual axis."""
        imax = -1
        indx = -1
        for i, n in enumerate(self.nitems):
            if n > imax:
                imax = n
                indx = i

        return np.linspace(0., 1.0, num=self.size[indx])


def compute_average(values):
    """Compute the mean of arrays in input."""
    data = np.zeros([len(values), len(values[0])])
    for i, V in enumerate(values):
        data[i, :] = V

    avg = np.mean(data, axis=0)
    return avg


def create_golden_average(files, options):
    """Create golden average.

    Args:
    ----
        files (list): List of input files
        options: other options.

    """
    names = get_names(files)
    result_list = []
    # Create the axes
    axes = [GoldenAxis() for i in range(2)]

    # Get the Xaxis.
    # Will be the linspace between 0 and 1 with the most repeated
    # number of points.
    for i, ifile in enumerate(files):
        ifile = find_file(options.folder, ifile)
        if not ifile.exists():
            print("+++ File {} does not exist.".format(ifile))
            continue

        alias = names[i]
        result = IRCore.IRCore.read_json(ifile)
        if result.aliasID is None or result.aliasID == "":
            result.aliasID = names[i]

        result_list.append(result)

        # Loop to get best axis
        R = result.results
        for iside in range(2):
            the_axis = R[iside].path_length
            axes[iside].check_axis(the_axis, i)

    # Prepare the results for the golden average.
    xvalues = [axes[i].get_axis() for i in range(2)]
    for i, R in enumerate(result_list):
        R.golden = []
        for iside in range(2):
            G = Petal_IR_Analysis.AnalysisResult()
            splnT = CubicSpline(R.results[iside].path_length, R.results[iside].path_temp)
            splnS = CubicSpline(R.results[iside].path_length, R.results[iside].path_spread)
            G.path_length = xvalues[iside]
            G.path_temp = np.array([splnT(x) for x in G.path_length])
            G.path_spread = np.array([splnS(x) for x in G.path_length])
            G.sensor_avg = np.array(R.results[iside].sensor_avg)
            G.sensor_std = np.array(R.results[iside].sensor_std)
            R.golden.append(G)

        if options.debug:
            fig, ax = plt.subplots(2, 1, tight_layout=True)
            fig.suptitle(R.aliasID)
            for i in range(2):
                ax[i].plot(R.results[i].path_length, R.results[i].path_temp, label="original")
                ax[i].plot(R.golden[i].path_length, R.golden[i].path_temp, label="golden")
                if options.legend:
                    ax[i].legend()

    # Create the golden object
    golden = [Petal_IR_Analysis.AnalysisResult() for i in range(2)]
    for i, G in enumerate(golden):
        G.path_length = xvalues[i]
        G.path_temp = compute_average([R.golden[i].path_temp for R in result_list])
        G.path_spread = compute_average([R.golden[i].path_spread for R in result_list])
        G.sensor_avg = compute_average([R.golden[i].sensor_avg for R in result_list])
        G.sensor_std = compute_average([R.golden[i].sensor_std for R in result_list])

    return golden, result_list

def golden_from_json(js_golden):
    """Converst a JSon golden into a Golden object."""
    golden = [Petal_IR_Analysis.AnalysisResult() for i in range(2)]
    for i, G in enumerate(golden):
        G.path_length = np.array(js_golden[i]["path_length"])
        G.path_temp = np.array(js_golden[i]["path_temp"])
        G.path_spread = np.array(js_golden[i]["path_spread"])
        G.sensor_avg = np.array(js_golden[i]["sensor_avg"])
        G.sensor_std = np.array(js_golden[i]["sensor_std"])

    return golden

def get_golden_axis(R, golden):
    """Compute result on golden points."""
    xvalues = [ [x for x in golden[i].path_length] for i in range(2) ]
    R.golden = []
    for iside in range(2):
        G = Petal_IR_Analysis.AnalysisResult()
        splnT = CubicSpline(R.results[iside].path_length, R.results[iside].path_temp)
        splnS = CubicSpline(R.results[iside].path_length, R.results[iside].path_spread)
        G.path_length = np.array(xvalues[iside])
        G.path_temp = np.array([splnT(x) for x in G.path_length])
        G.path_spread = np.array([splnS(x) for x in G.path_length])
        G.sensor_avg = np.array(R.results[iside].sensor_avg)
        G.sensor_std = np.array(R.results[iside].sensor_std)
        R.golden.append(G)


def plot_profile_and_golden(golden, core, value, show_legend=True):
    """Plot petal core and golden average.

    Args:
    ----
        resuls: results from create_golden_average
        golden: golden values (from create_golgen_average)
        value: value to show, ej path_temp, path_spread, sensor_avg, sensor_std

    """
    tick_labels = ["R0", "R1", "R2", "R3", "R3", "R4", "R4", "R5", "R5", "EoS"]
    figures = []
    factor = 1.0
    if value.find("sensor") >= 0:
        factor = 2.0

    # Get acceptance band
    band = get_acceptance_band()

    for iside in range(2):
        fig, ax = plt.subplots(2, 1, tight_layout=True, figsize=(7, 9), gridspec_kw={'height_ratios': (0.6, 0.4)})
        figures.append(fig)
        fig.suptitle("Petal core .vs. Golden for {} - side {}.".format(value, iside))
        for a in ax:
            a.grid()

        if value.find("path") < 0:
            for i in range(2):
                ax[i].set_xticks(range(10), labels=tick_labels)

        RS = core.results[iside]
        # convert to golden X
        # TODO: get X, Y from petal core. Move golden to this X axis and draw differences.
        # This only happens for the "_path" values, not for the sensors.
        if value.find("path") >= 0:
            X = RS.path_length
            Y = getattr(RS, value)
            spln = CubicSpline(golden[iside].path_length, getattr(golden[iside], value))
            gY = np.array([spln(x) for x in X])
        else:
            X = np.array([float(x) for x in range(10)])
            Y = getattr(RS, value)
            gY = getattr(golden[iside], value)

        delta = Y - gY
        ax[0].plot(X, Y, '-', label=core.aliasID, linewidth=1)
        ax[1].plot(X, delta, '-', label=core.aliasID, linewidth=1)

        # Draw golden line
        ax[0].plot(X, gY, '-', label="Golden", linewidth=4, alpha=0.4, color="black")

        Tmean = np.mean(Y)
        Tband = factor*abs(Tmean)/3

        if show_legend:
            ax[0].legend(ncol=4, fontsize="x-small")
            
        ax[0].set_title("T$_{prof}$ values")
        if value.find("temp") >= 0 or value.find("_avg") >= 0:
            ax[0].set_ylim(Tmean-Tband, Tmean+Tband)
            ax[0].fill_between(X, gY + band, gY - band,
                               facecolor="yellow", alpha=0.25,
                               label="Acceptance band")

            ax[1].fill_between(X, band, -band,
                               facecolor="yellow", alpha=0.25,
                               label="Acceptance band")

        if show_legend:
            ax[1].legend(ncol=4, fontsize="x-small")
        
        ax[1].set_title("T$_{prof}$ - Golden avg.")
        if value.find("temp") >= 0 or value.find("_avg") >= 0:
            ax[1].set_ylim(-Tband, Tband)

    return figures

def show_golden_average(golden, results, value, show_legend=True):
    """Create golden average.

    Args:
    ----
        golden: golden values (from create_golgen_average)
        resuls: results from create_golden_average
        value: value to show, ej path_temp, path_spread, sensor_avg, sensor_std

    """
    tick_labels = ["R0", "R1", "R2", "R3", "R3", "R4", "R4", "R5", "R5", "EoS"]
    figures = []
    factor = 1.0
    if value.find("sensor") >= 0:
        factor = 2.0

    # Get acceptance band
    band = get_acceptance_band()

    for iside in range(2):
        fig, ax = plt.subplots(2, 1, tight_layout=True, figsize=(7,9), gridspec_kw={'height_ratios': (0.6, 0.4)})
        figures.append(fig)
        fig.suptitle("Golden average for {} - side {}.".format(value, iside))
        for a in ax:
            a.grid()

        if value.find("path") < 0:
            for i in range(2):
                ax[i].set_xticks(range(10), labels=tick_labels)

        G = golden[iside]
        for R in results:
            RS = R.results[iside]
            Y = getattr(RS, value)
            gY = getattr(G, value)
            O = getattr(R.golden[iside], value) - gY
            if value.find("path") >= 0:
                X = RS.path_length
                gX = golden[iside].path_length
                spln = CubicSpline(gX, gY)
                delta = Y - np.array([spln(x) for x in X])

            else:
                X = np.array([float(x) for x in range(10)])
                gX = X
                delta = Y - gY

            ax[0].plot(X, Y, '-', label=R.aliasID, linewidth=1)
            ax[1].plot(X, delta, '-', label=R.aliasID, linewidth=1)

        Tmean = np.mean(Y)
        Tband = factor*abs(Tmean)/3
        ax[0].plot(gX, gY, '-', label="Golden", linewidth=4, alpha=0.4, color="black")

        if show_legend:
            ax[0].legend(ncol=4, fontsize="x-small")
        
        ax[0].set_title("T$_{prof}$ values")
        if value.find("temp") >= 0 or value.find("_avg") >= 0:
            ax[0].set_ylim(Tmean-Tband, Tmean+Tband)
            ax[0].fill_between(gX,
                               getattr(golden[iside], value) + band,
                               getattr(golden[iside], value) - band,
                               facecolor="yellow", alpha=0.25,
                               label="Acceptance band")

            ax[1].fill_between(gX, band, -band,
                               facecolor="yellow", alpha=0.25,
                               label="Acceptance band")

        if show_legend:
            ax[1].legend(ncol=4, fontsize="x-small")
        
        ax[1].set_title("T$_{prof}$ - Golden avg.")
        if value.find("temp") >= 0 or value.find("_avg") >= 0:
            ax[1].set_ylim(-Tband, Tband)

    return figures

def compare_golden(core, golden, value):
    """Comapres petal core with golden average.

    Args:
    ----
        core (AnalisysResult): The petal core
        golden (AnalysisResult): The golden avrage
        value (str): The name of the variable to compare

    Returns:
        (pass, max difference, array of location of outsiders)

    """
    Y = getattr(core, value)
    gY = getattr(golden, value)
    if value.find("path") >= 0:
        X = core.path_length
        gX = golden.path_length

    else:
        X = np.array([float(x) for x in range(10)])
        gX = X

    # compute difference
    band = get_acceptance_band()
    outsiders = []
    mxval = -1
    indx = 1
    for x, y in zip(X, Y):
        indx = bisect.bisect_left(gX, x, lo=(indx-1 if indx>1 else 0))
        val = gY[indx]
        diff = abs(y-val)

        delta = abs(diff-band)/band
        if diff>band and delta>0.01:
            outsiders.append(x)
            mxval = max(diff, mxval)

    rc = mxval < band
    return rc, mxval, outsiders


def analyze_petal_cores(files, golden, options):
    """Create golden average.

    Args:
        files (list): List of input files
        golden: the golden object
        options: other options.

    Return:
        array with JSon objects corresponding to the PDB test.

    """
    output = []
    cores = []
    names = get_names(files)
    for i, ifile in enumerate(files):
        ifile = find_file(options.folder, ifile)
        if not ifile.exists():
            print("+++ File {} does not exist.".format(ifile))
            continue

        alias = names[i]
        core = IRCore.IRCore.read_json(ifile)
        if core.aliasID is None or core.aliasID == "":
            core.aliasID = names[i]

        if core.coreID is None or core.coreID == "":
            print("+++ File {} does not have component serial number.")
            continue

        cores.append(core)
        out = [{}, {}]
        for iside in range(2):
            for val in ("path_temp", "sensor_avg"):
                out[iside][val] = compare_golden(core.results[iside], golden[iside], val)

        dbOut = {
            "component": core.coreID,
            "testType": "THERMAL_EVALUATION",
            "institution": core.institute,
            "runNumber": "1",
            "date": core.date,
            "passed": True,
            "problems": True,
            "comments": [],
            "defects": [],
            "results": {}
        }

        if options.add_attachments:
            golden_file = Path(options.golden).expanduser().resolve()
            dbOut["attachments"] = [
                {
                    "path": ifile.as_posix(),
                    "title": "Raw data (IRCore)",
                    "description": "Raw Data of the test"
                },
                {
                    "path": golden_file.as_posix(),
                    "title": "Golden",
                    "description": "The golden object used for this test."
                }
            ]

        for iside, side in enumerate(out):
            for key, val in side.items():
                if val[0]:
                    continue

                noutsiders = len(val[2])
                #if noutsiders < 2:
                #    dbOut["comments"].append(
                #        "{} in side {}: 1 point out of acceptance band. {}".format(
                #            key, iside, val[2])
                #    )
                if noutsiders>0:
                    dbOut["defects"].append(
                        {"name": key,
                         "description": "{} in side {}: {} points out of acceptance band. {}".format(key, iside, noutsiders, get_array_as_string(val[2])),
                         "properties": {"msg": "{} > {}".format(val[1], get_acceptance_band())}
                         }
                    )
        dbOut["passed"] = len(dbOut["defects"]) == 0
        dbOut["problems"] = len(dbOut["comments"]) > 0

        if options.out is None:
            ofile = "{}-Thermal.json".format(core.coreID)
        else:
            ofile = options.out

        # Check if we are given an output folder
        ofile = output_folder(options.folder, ofile)
        with open(ofile, 'w', encoding="UTF-8") as fp:
            print("writing {}".format(ofile))
            json.dump(dbOut, fp, indent=3, cls=IRCore.NumpyArrayEncoder)

        output.append(dbOut)

    return output, cores

def analyze_IRCore(options, show=True):
    """Main entry."""
    output = None
    if options.create_golden:
        golden, results = create_golden_average(options.files, options)
        if options.out is None:
            options.out = "out-golden.json"

        ofile = output_folder(options.folder, options.out)
        with open(ofile, 'w') as fp:
            json.dump(golden, fp, indent=3, cls=IRCore.NumpyArrayEncoder)

        show_golden_average(golden, results, "path_temp", options.legend)
        show_golden_average(golden, results, "path_spread", options.legend)
        show_golden_average(golden, results, "sensor_avg", options.legend)
        show_golden_average(golden, results, "sensor_std", options.legend)

    else:
        if options.golden is None:
            print("I need a golden file to compare with")
            sys.exit(1)

        golden_file = Path(options.golden).expanduser().resolve()
        if not golden_file.exists():
            golden_file = find_file(options.folder, options.golden)
            if not golden_file.exists():
                print("Golden file {} does not exist.".format(options.golden))
                sys.exit(1)

        with open(golden_file, 'r', encoding="utf-8") as fp:
            J = json.load(fp)

        golden = [Petal_IR_Analysis.AnalysisResult() for i in range(2)]
        for i, Jside in enumerate(J):
            golden[i].from_json(Jside)

        output, cores  = analyze_petal_cores(options.files, golden, options)

        if show or options.report:
            for C in cores:
                get_golden_axis(C, golden)

            if options.report:
                document = docx_utils.Document()
                document.add_page_numbers()
                document.styles['Normal'].font.name = "Calibri"
                document.add_heading("Comparing to Golden", 0)
            else:
                document = None

            F = show_golden_average(golden, cores, "path_temp", options.legend)
            add_figures_to_doc(document, F, "Temperature along pipe")
            F = show_golden_average(golden, cores, "path_spread", options.legend)
            add_figures_to_doc(document, F, "Spread along pipe")
            F = show_golden_average(golden, cores, "sensor_avg", options.legend)
            add_figures_to_doc(document, F, "Sensor avg")
            F = show_golden_average(golden, cores, "sensor_std", options.legend)
            add_figures_to_doc(document, F, "Sensor std")

            if document and not hasattr(options, "no_golden_doc"):
                ofile = utils.output_folder(options.folder, options.comparison)
                document.save(ofile)

    if show:
        plt.show()

    return output


def main():
    """Main entry."""
    from argparse import ArgumentParser
    # Argument parser
    parser = ArgumentParser()
    parser.add_argument('files', nargs='*', help="Input files")
    parser.add_argument("--create-golden", action="store_true", default=False, help="Draw golden average")
    parser.add_argument("--add_attachments", action="store_true", default=False,
                        help="If true add the attachments section os DB file.")
    parser.add_argument("--golden", default=None, help="The golden to compare width")
    parser.add_argument("--prefix", default="golden", help="Prefix for figures")
    parser.add_argument("--debug", action="store_true", default=False, help="Set to debug")
    parser.add_argument("--report", action="store_true", default=False, help="Set to produce plots for report")
    parser.add_argument("--no-legend", dest="legend", action="store_false", default=True, help="Do not show the legend in plots.")
    parser.add_argument("--out", default=None, help="File to store Golden.")
    parser.add_argument("--folder", default=None, help="Folder to store output files. Superseeds folder in --out")
    parser.add_argument("--comparison", default="Compare-to-Golden.docx", help="Path to comparison to golden of all input files.")

    options = parser.parse_args()
    if len(options.files) == 0:
        print("I need an input file")
        sys.exit()

    analyze_IRCore(options)

if __name__ == "__main__":
    main()
