#!/usr/bin/env python3
"""Analyze the table generated by createMetrologyTable.

   It should also work with the table created by analyzeMetrologyTable, which is
   the new default.
"""

import sys
from pathlib import Path
import math
import argparse
import pandas as pd
import numpy as np
from numpy.linalg import norm
import matplotlib.pyplot as plt
from lmfit.models import LinearModel

from petal_qc.utils.fit_utils import draw_best_fit

fig_width = 12.0
fig_height = 1.2*fig_width/3.0



def distance(P1, P2, P3):
    """Distance of P3 to line defined by P1-P2.

    Args:
        P1: Point 1 of the line
        P2: Point 2 of the line
        P3: Actual point

    Returns:
        float: distance
    """
    C = np.cross(P2-P1, P3-P1)
    D = C/norm(P2-P1)
    return D

def remove_outliers_indx(data, cut=2.0, debug=False):
    """Remove points far away form the rest.

    Args:
    ----
        data : The data
        cut: max allowed distance
        debug: be verbose if True.

    Returns
    -------
        index of valid pints in data array.

    """
    d = np.abs(data - np.median(data))
    mdev = np.median(d)
    s = d / (mdev if mdev else 1.)
    indx = np.where(s < cut)[0]
    return indx

def draw_delta_scatter(ax, x, y, title, x_lim=None, y_lim=None, radius=None):

    if x_lim is None:
        x_lim=(-150, 150)

    if y_lim is None:
        y_lim=(-150, 150)

    if radius is None:
        radius = (25, 100)

    ax.set_title(title)
    ax.set_aspect('equal', adjustable='box')
    ax.set_xlim(x_lim)
    ax.set_ylim(y_lim)
    circle = plt.Circle((0,0), radius[1], color="red", alpha=0.25)
    ax.add_patch(circle)
    circle = plt.Circle((0,0), radius[0], color="green", alpha=0.25)
    ax.add_patch(circle)

    ax.set_xlabel("X (µm)")
    ax.set_ylabel("Y (µm)")
    ax.grid()

    ax.scatter(x, y, marker='.')


def analyze_fiducials(options, T):
    """Analyze relative position of locator fiducials.

    Args:
        options (_type_): Program options
        T (DataFrame): Pandas data frame.
    """
    side = T["side"].values[0]
    if options.mould > 0:
        x = 1000*T.loc[T['mould'] == options.mould, 'fd_dx'].values
        y = 1000*T.loc[T['mould'] == options.mould, 'fd_dy'].values

    else:
        x = 1000*T['fd_dx'].values
        y = 1000*T['fd_dy'].values

    fig, ax = plt.subplots(nrows=1, ncols=2, tight_layout=True, figsize=(fig_width, fig_height))
    fig.suptitle("Relative Position FD01-FD02 [{}]".format(side))
    draw_delta_scatter(ax[0], x, y, "FD01-FD02")
    # ax[0].set_title("FD01-FD02")
    # ax[0].set_aspect('equal', adjustable='box')
    # ax[0].set_xlim(-150, 150)
    # ax[0].set_ylim(-150, 150)
    # circle = plt.Circle((0,0), 100, color="red", alpha=0.25)
    # ax[0].add_patch(circle)
    # circle = plt.Circle((0,0), 25, color="green", alpha=0.25)
    # ax[0].add_patch(circle)
    #
    # ax[0].set_xlabel("X (µm)")
    # ax[0].set_ylabel("Y (µm)")
    # ax[0].grid()
    #
    # ax[0].scatter(x, y, marker='.')

    model = LinearModel()
    params = model.guess(y, x=x)
    result = model.fit(y, params, x=x)


    P1 = np.array([0, result.eval(x=0)])
    P2 = np.array([1, result.eval(x=1)])
    values = []
    for v, w in zip(x, y):
        P3 = np.array([v, w])
        values.append(distance(P1, P2, P3))

    indx = remove_outliers_indx(values)

    xx = x[indx]
    yy = y[indx]
    params = model.guess(yy, xx)
    result = model.fit(yy, params, x=xx)
    result.plot_fit(ax=ax[0])
    print("slope {:.5f}, intercept {:.5f}".format(result.best_values['slope'], result.best_values["intercept"]))
    angle = 180*math.atan( result.best_values['slope'])/math.pi
    print("angle {:.5f} deg.".format(angle))

    ax[1].set_xlim(-50, 50)
    ax[1].set_xlabel("distance to line (µm)")
    ax[1].grid()
    ax[1].hist(values)

    # ax[2].set_xlim(-75, 75)
    # ax[2].set_xlabel("delta_X (µm)")
    # ax[2].grid()
    # ax[2].hist(x)

    # ax[3].set_xlim(-150, 150)
    # ax[3].set_xlabel("delta_Y (µm)")
    # ax[3].grid()
    # ax[3].hist(y)

def analyze_delta_pos(options, T):
    """ Study dependency of delta pos in PL01-FD01 with the other locators.

    Args:
        options (_type_): Program options
        T (DataFrame): Pandas data frame.
    """
    side = T["side"].values[0]
    x = T["pl01_dx"].values
    y = T["pl01_dy"].values
    delta_pl01 = 1000*np.column_stack((x, y))
    norm = np.array([ np.linalg.norm(P)  for P in delta_pl01])
    indx = np.where(norm<75.0)

    delta_pl02 = 1000*np.column_stack((T["pl02_dx"].values, T["pl02_dy"].values))
    delta_pl03 = 1000*np.column_stack((T["pl03_dx"].values, T["pl03_dy"].values))

    fig, ax = plt.subplots(nrows=1, ncols=2, tight_layout=True, figsize=(fig_width, fig_height))
    fig.suptitle("Delta from PL01 [{}]".format(side))
    draw_delta_scatter(ax[0], delta_pl02[indx, 0], delta_pl02[indx, 1], "PL02")
    draw_delta_scatter(ax[1], delta_pl03[indx, 0], delta_pl03[indx, 1], "PL02")


def analyze_parallelism(options, T):
    """Analyze parallelism.

    Args:
        options (_type_): Program options
        T (DataFrame): Pandas data frame.
    """
    if options.institute is None:
        df = T
    else:
        df = T.loc[T["institute"] == options.institute]


    side = df["side"].values[0]
    labels = []
    for L in df["petal_id"].values:
        ival = int(L[5:])
        labels.append(ival)

    x = 1000*df["flatness"].values
    y = 1000*df["parallelism"].values

    fig, ax = plt.subplots(nrows=1, ncols=1, tight_layout=True)
    fig.suptitle("Parallelism .vs. flatness [{}]".format(side))

    ax.scatter(x, y, marker='.')
    for xp, yp, lbl in zip(x, y, labels):
        ax.text(xp, yp, "{}".format(lbl))

    ax.set_xlabel("flatness (µm)")
    ax.set_ylabel("parallelism (µm)")
    ax.grid()

    fig, ax = plt.subplots(nrows=1, ncols=1, tight_layout=True)
    fig.suptitle("Offset [{}]".format(side))
    ax.hist(1000*T["offset"].values)


def main(options):
    """main entry."""
    T = pd.read_csv(options.files[0])

    # analyze fiducials
    analyze_fiducials(options, T)

    # Understand deviation from nominal.
    analyze_delta_pos(options, T)

    # Correlate planarity y parallelism
    analyze_parallelism(options, T)

    plt.show()

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('files', nargs='*', help="Input files")
    parser.add_argument('--mould', default=-1, type=int, help="mould index")
    parser.add_argument("--institute",
                    default=None,
                    help="Either IFIC or DESY to treat the different files")

    opts = parser.parse_args()
    if len(opts.files) == 0:
        print("I need at least one input file")
        sys.exit()

    main(opts)